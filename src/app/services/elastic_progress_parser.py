#!/usr/bin/env python3
"""
Elastic Progress Parser for VCCTL

Handles parsing of elastic moduli calculation progress from JSON files
generated by the elastic.c program.
"""

import json
import logging
from typing import Optional, Dict, Any
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass


@dataclass
class ElasticProgress:
    """Data class for elastic moduli calculation progress."""
    cycle: int = 0
    max_cycle: int = 0
    gradient: float = 0.0
    timestamp: Optional[str] = None
    percent_complete: float = 0.0
    is_complete: bool = False

    def calculate_progress(self) -> float:
        """Calculate progress percentage from cycle information."""
        if self.max_cycle > 0:
            self.percent_complete = min(100.0, (self.cycle / self.max_cycle) * 100.0)
            self.is_complete = self.cycle >= self.max_cycle
        return self.percent_complete


class ElasticProgressParser:
    """Parser for elastic moduli calculation progress information."""

    def __init__(self):
        self.logger = logging.getLogger('VCCTL.ElasticProgressParser')

    def parse_json_progress(self, json_file_path: str) -> Optional[ElasticProgress]:
        """
        Parse progress from elastic_progress.json file.

        Args:
            json_file_path: Path to elastic_progress.json file

        Returns:
            ElasticProgress object or None if parsing failed
        """
        try:
            json_path = Path(json_file_path)
            if not json_path.exists():
                return None

            with open(json_path, 'r') as f:
                # Handle potential malformed JSON by reading line by line
                content = f.read().strip()

                # Remove 'json ' prefix if present (some files have this)
                if content.startswith('json '):
                    content = content[5:]

                data = json.loads(content)

            progress = ElasticProgress()

            # Parse cycle information
            progress.cycle = data.get('cycle', 0)
            progress.max_cycle = data.get('maxcycle', 0)
            progress.timestamp = data.get('timestamp')

            # Use the quantitative percent_complete from elastic.c if available
            if 'percent_complete' in data:
                progress.percent_complete = float(data['percent_complete'])
                # For backward compatibility, still store gradient if present
                progress.gradient = data.get('gradient', 0.0)
            else:
                # Fall back to old calculation for backward compatibility
                progress.gradient = data.get('gradient', 0.0)
                progress.calculate_progress()

            self.logger.debug(f"Parsed elastic progress: cycle {progress.cycle}/{progress.max_cycle} "
                            f"({progress.percent_complete:.1f}%)")

            return progress

        except (json.JSONDecodeError, IOError, KeyError) as e:
            self.logger.debug(f"Failed to parse elastic progress from {json_file_path}: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Unexpected error parsing elastic progress: {e}")
            return None

    def monitor_progress_file(self, operation_dir: str, operation_name: str) -> Optional[ElasticProgress]:
        """
        Monitor elastic progress file for a specific operation.

        Args:
            operation_dir: Directory containing the elastic operation
            operation_name: Name of the operation

        Returns:
            Latest ElasticProgress or None if not available
        """
        try:
            # Look for elastic_progress.json in the operation directory
            progress_file = Path(operation_dir) / "elastic_progress.json"
            return self.parse_json_progress(str(progress_file))

        except Exception as e:
            self.logger.error(f"Error monitoring progress for {operation_name}: {e}")
            return None