2,82c2,86
<  *
<  * Program disrealnew.c to hydrate three-dimensional cement
<  * and gypsum particles in a 3-D box with periodic boundaries.
<  * Uses cellular automata techniques and preserves correct
<  * hydration volume stoichiometry.
<  *
<  * History of modifications:
<  *
<  *     (1) Heat of formation data added 12/92
<  *     (2) 3D version created 7/94
<  *     (3) General C version created 8/94
<  *     (4) Modified to have pseudo-continuous dissolution 11/94
<  *     (5) In this program, dissolved silicates are located close
<  *            to dissolution source within a 17*17*17 box centered
<  *            at dissolution source
<  *     (6) Hydration under self-desiccating conditions included 9/95
<  *     (7) Additions for adiabatic hydration conditions included 9/96
<  *     (8) Adjustments for pozzolanic reaction included 11/96
<  *     (9) Additions for calcium chloride to Friedel's salt added 4/97
<  *    (10) Additions for stratlingite formation added 4/97
<  *    (11) Additions for anhydrite to gypsum conversion added 5/97
<  *    (12) Additions for calcium aluminodisilicate added 7/97
<  *    (13) Ettringite unstable above 70 C added 9/98
<  *    (14) Hemihydrate to gypsum conversion added 9/98
<  *    (15) Decided to base Alpha only on four major clinker phases 9/98
<  *    (16) Updated dissolution to allow next nearest neighbors, etc. 9/98
<  *    (17) Created stable iron-rich ettringite 3/99
<  *    (18) Phases renumbered 1/00
<  *    (19) Changed Cshscale to 70000 to better model induction CS 6/01
<  *    (20) Sulfate reactions modified by Claus-Jochen Haecker 6/00
<  *    (21) Reactions between CaCO3 and Afm phase added 8/00
<  *    (22) Slag incorporation 2/01
<  *    (23) pH and pore solution concentration added 8/01
<  *    (24) Influence of pH on hydration added 2/13/02
<  *    (25) Surface retardation added 3/28/02
<  *    (26) Critical amount of CSH needed to end induction changed from
<  *            mass basis to volume basis 7/10/02
<  *    (27) Allow formation of a crack in the microstructure at
<  *            any cycle during hydration.  User specifies crack
<  *            width and orientation, as well as the cycle at which
<  *            to form the crack 5/24/04
<  *    (28) Incorporate Na2SO4 (thenardite) and K2SO4 (arcanite)
<  *            as solid phases which can dissolve and influence the
<  *            pore solution composition 6/4/04
<  *    (29) Allow different initial temperature for fictitious
<  *            aggregate particles 11/15/04
<  *    (30) Allow input of continuous isothermal calorimetry data
<  *            for calibration of kinetics, to partially supplant
<  *            the time conversion factor 6/29/07
<  *    (31) More robust fitting to calorimetry data and chemical
<  *            shrinkage data 3/6/13
<  *    (32) Changed Cshscale to 35000, 12/22/2021
<  *    (33) Added ability for and CSH CH to nucleate on silica
<  *            fume, 12/22/2021
<  *
<  * Other notes:
<  *
<  *     (a) Temperature-variable C-S-H properties added 8/98
<  *            molar volumes and water consumption based on values
<  *            given in Geiker thesis on chemical shrinkage
<  *     (b) Modelling of induction period based on an impermeable layer
<  *            theory
<  *
<  * Programmers:   Dale P. Bentz and Jeffrey W. Bullard
<  *                Engineering Laboratory
<  *                NIST
<  *                100 Bureau Drive Mail Stop 8621
<  *                Gaithersburg, MD  20899-8621   USA
<  *                (301) 975-5865      FAX: (301) 990-6891
<  *                E-mail: dale.bentz@nist.gov
<  *
<  * Contact:       Jeffrey W. Bullard
<  *                Zachry Department of Civil and Environmental Engineering
<  *                Department of Materials Science and Engineering
<  *                Texas A&M University
<  *                3136 TAMU
<  *                College Station, TX  77845   USA
<  *                (979) 458-6482
<  *                E-mail: jwbullard@tamu.edu
<  *******************************************************/
< #include "disrealnew.h"
---
> *                                                                      
> * Program disrealnew.c to hydrate three-dimensional cement 
> * and gypsum particles in a 3-D box with periodic boundaries.
> * Uses cellular automata techniques and preserves correct
> * hydration volume stoichiometry.
> *
> * History of modifications:
> *
> *     (1) Heat of formation data added 12/92 
> *     (2) 3D version created 7/94
> *     (3) General C version created 8/94
> *     (4) Modified to have pseudo-continuous dissolution 11/94
> *     (5) In this program, dissolved silicates are located close
> *            to dissolution source within a 17*17*17 box centered
> *            at dissolution source
> *     (6) Hydration under self-desiccating conditions included 9/95
> *     (7) Additions for adiabatic hydration conditions included 9/96
> *     (8) Adjustments for pozzolanic reaction included 11/96
> *     (9) Additions for calcium chloride to Friedel's salt added 4/97
> *    (10) Additions for stratlingite formation added 4/97
> *    (11) Additions for anhydrite to gypsum conversion added 5/97
> *    (12) Additions for calcium aluminodisilicate added 7/97
> *    (13) Ettringite unstable above 70 C added 9/98
> *    (14) Hemihydrate to gypsum conversion added 9/98
> *    (15) Decided to base Alpha only on four major clinker phases 9/98
> *    (16) Updated dissolution to allow next nearest neighbors, etc. 9/98
> *    (17) Created stable iron-rich ettringite 3/99
> *    (18) Phases renumbered 1/00
> *    (19) Changed Cshscale to 70000 to better model induction CS 6/01
> *    (20) Sulfate reactions modified by Claus-Jochen Haecker 6/00
> *    (21) Reactions between CaCO3 and Afm phase added 8/00
> *    (22) Slag incorporation 2/01
> *    (23) pH and pore solution concentration added 8/01
> *    (24) Influence of pH on hydration added 2/13/02
> *    (25) Surface retardation added 3/28/02
> *    (26) Critical amount of CSH needed to end induction changed from
> *            mass basis to volume basis 7/10/02
> *    (27) Allow formation of a crack in the microstructure at
> *            any cycle during hydration.  User specifies crack
> *            width and orientation, as well as the cycle at which
> *            to form the crack 5/24/04
> *    (28) Incorporate Na2SO4 (thenardite) and K2SO4 (arcanite)
> *            as solid phases which can dissolve and influence the
> *            pore solution composition 6/4/04
> *    (29) Allow different initial temperature for fictitious
> *            aggregate particles 11/15/04
> *    (30) Allow input of continuous isothermal calorimetry data
> *            for calibration of kinetics, to partially supplant
> *            the time conversion factor 6/29/07
> *    (31) More robust fitting to calorimetry data and chemical
> *            shrinkage data 3/6/13
> *    (32) Changed Cshscale to 35000, 12/22/2021
> *    (33) Added ability for and CSH CH to nucleate on silica
> *            fume, 12/22/2021
> *
> * Other notes:
> *
> *     (a) Temperature-variable C-S-H properties added 8/98
> *            molar volumes and water consumption based on values
> *            given in Geiker thesis on chemical shrinkage
> *     (b) Modelling of induction period based on an impermeable layer
> *            theory
> *
> * Programmers:   Dale P. Bentz and Jeffrey W. Bullard
> *                Engineering Laboratory
> *                NIST
> *                100 Bureau Drive Mail Stop 8621
> *                Gaithersburg, MD  20899-8621   USA
> *                (301) 975-5865      FAX: (301) 990-6891
> *                E-mail: dale.bentz@nist.gov
> *                                                                     
> * Contact:       Jeffrey W. Bullard
> *                Zachry Department of Civil and Environmental Engineering
> *                Department of Materials Science and Engineering
> *                Texas A&M University
> *                3136 TAMU
> *                College Station, TX  77845   USA
> *                (979) 458-6482
> *                E-mail: jwbullard@tamu.edu
> *******************************************************/
> #include <stdio.h>
> #include <string.h>
> #include <math.h>
> #include <stdlib.h>
> #include <ctype.h>
83a88
> #include "disrealnew.h"
86,92c91,96
<  *    Function declarations
<  ***/
< int checkargs(int argc, char *argv[]);
< void printHelp(void);
< int get_input(float *pnucch, float *pscalech, float *pnuchg, float *pscalehg,
<               float *pnucfh3, float *pscalefh3, float *pnucgyp,
<               float *pscalegyp, int *nmovstep);
---
> *    Function declarations
> ***/
> void checkargs(int argc, char *argv[]);
> int get_input(float *pnucch, float *pscalech, float *pnuchg,
>                 float *pscalehg, float *pnucfh3, float *pscalefh3,
>                 float *pnucgyp, float *pscalegyp, int *nmovstep);
112,113c116
< void findnewtime(float dval, float act_nrg, float *previousUncorrectedTime,
<                  char *typestring);
---
> void findnewtime(float dval, float act_nrg, float *previousUncorrectedTime, char *typestring);
116d118
< char *rfc8601_timespec(struct timespec *tv);
119,125c121,128
<  *    Supplementary programs
<  ***/
< #include "include/burn3d.h"     /* percolation of porosity assessment */
< #include "include/burnset.h"    /* set point assessment */
< #include "include/hydrealnew.h" /* hydration execution */
< #include "include/pHpred.h"     /* pore solution pH prediction */
< #include "include/parthyd.h"    /* particle hydration assessment */
---
> *    Supplementary programs
> ***/
> #include "include/properties.h"        /* Physical properties of the phases */
> #include "include/burn3d.h"            /* percolation of porosity assessment */
> #include "include/burnset.h"        /* set point assessment */
> #include "include/parthyd.h"        /* particle hydration assessment */
> #include "include/hydrealnew.h"        /* hydration execution */
> #include "include/pHpred.h"            /* pore solution pH prediction */
127,149c130,146
< int main(int argc, char *argv[]) {
<   int ntimes, valin, nmovstep;
<   int cycflag, ix, iy, iz;
<   int pixtmp, i, j, k;
<   int customentry;
<   float pnucch, pscalech, pnuchg, pscalehg, pnucfh3, pscalefh3;
<   float psfact, betfact, pnucgyp, pscalegyp;
<   float thtimelo, thtimehi, thtemplo, thtemphi;
<   float kslag;
<   float act_nrg, recip_Tdiff, tmod, smod;
<   float dval, previousUncorrectedTime;
<   double gfloat, space, mass_cement, mass_cem_now, mass_cur, kpozz;
<   double time_spent;
<   char typestring[MAXSTRING];
<   char strsuff[MAXSTRING], strsuffa[MAXSTRING], strsuffb[MAXSTRING];
<   char buff[MAXSTRING], instring[MAXSTRING];
<   char commachar;
<   char *rfc8601;
<   time_t current_time;
<   clock_t begin, end;
<   struct tm *local_time;
<   struct timespec tv;
<   FILE *outfile, *thfile;
---
> int main(int argc, char *argv[])
> {
>     int ntimes,valin,nmovstep;    
>     int cycflag,ix,iy,iz;
>     int pixtmp,i,j,k;
>     int customentry;
>     float pnucch,pscalech,pnuchg,pscalehg,pnucfh3,pscalefh3;
>     float psfact,betfact,pnucgyp,pscalegyp;
>     float thtimelo,thtimehi,thtemplo,thtemphi;
>     float kslag;
>     float act_nrg,recip_Tdiff,tmod,smod;
>     float dval,previousUncorrectedTime;
>     double gfloat,space,mass_cement,mass_cem_now,mass_cur,kpozz;
>     char typestring[MAXSTRING];
>     char strsuff[MAXSTRING],strsuffa[MAXSTRING],strsuffb[MAXSTRING];
>     char buff[MAXSTRING],instring[MAXSTRING];
>     FILE *outfile,*thfile;
151c148
<   /* Get the simulation start time */
---
>     /* Initialize global arrays */
153,154c150,152
<   printf("\n\nHowdy!");
<   fflush(stdout);
---
>     for (ix = 0; ix <= NPHASES; ix++) {
>         Discount[ix] = Count[ix] = 0;
>     }
156,157c154,160
<   begin = clock();
<   current_time = time(NULL);
---
>     for (ix = 0; ix < 3; ix++) {
>         Nphc[ix] = 0;
>         Indx[ix] = 0;
>         Bvec[ix] = 0.0;
>         Con_fracp[ix] = 0.0;
>         Con_fracs[ix] = 0.0;
>     }
159,160c162,172
<   /* Get the local time using the current time */
<   local_time = localtime(&current_time);
---
>     for (ix = 0; ix <= NSPHASES; ix++) {
>         PHcoeff[ix][0] = 0.0;
>         PHcoeff[ix][1] = 0.0;
>         PHcoeff[ix][2] = 0.0;
>         FitpH[ix][0][0] = 0.0;
>         FitpH[ix][0][1] = 0.0;
>         FitpH[ix][0][2] = 0.0;
>         FitpH[ix][1][0] = 0.0;
>         FitpH[ix][1][1] = 0.0;
>         FitpH[ix][1][2] = 0.0;
>     }
162,164c174,176
<   /* Display the local time */
<   fprintf(Logfile, "=== BEGIN DISREALNEW SIMULATION ===");
<   fprintf(Logfile, "\nStart time: %s\n\n", asctime(local_time));
---
>     Antsize = sizeof(struct Ants);
>     Togosize = sizeof(struct Togo);
>     Alksulfsize = sizeof(struct Alksulf);
166c178
<   /* Initialize global arrays */
---
>     cycflag = 0;
168,170c180,181
<   for (ix = 0; ix <= NPHASES; ix++) {
<     Discount[ix] = Count[ix] = 0;
<   }
---
>     thtimelo = thtimehi = thtemplo = thtemphi = 0.0;
>     thfile = NULL;
172,178c183
<   for (ix = 0; ix < 3; ix++) {
<     Nphc[ix] = 0;
<     Indx[ix] = 0;
<     Bvec[ix] = 0.0;
<     Con_fracp[ix] = 0.0;
<     Con_fracs[ix] = 0.0;
<   }
---
>     checkargs(argc,argv);
180,190c185,189
<   for (ix = 0; ix <= NSPHASES; ix++) {
<     PHcoeff[ix][0] = 0.0;
<     PHcoeff[ix][1] = 0.0;
<     PHcoeff[ix][2] = 0.0;
<     FitpH[ix][0][0] = 0.0;
<     FitpH[ix][0][1] = 0.0;
<     FitpH[ix][0][2] = 0.0;
<     FitpH[ix][1][0] = 0.0;
<     FitpH[ix][1][1] = 0.0;
<     FitpH[ix][1][2] = 0.0;
<   }
---
> /*
>     printf("Enter name of progress file: \n");
>     read_string(instring,sizeof(instring));
>     sprintf(Progfilename,"%s",instring);
> */
192,194c191,197
<   Antsize = sizeof(struct Ants);
<   Togosize = sizeof(struct Togo);
<   Alksulfsize = sizeof(struct Alksulf);
---
>     printf("\nExecuting disrealnew now...\n");
>      if (get_input(&pnucch,&pscalech,&pnuchg,&pscalehg,
>                      &pnucfh3,&pscalefh3,&pnucgyp,&pscalegyp,
>                      &nmovstep)) {
>          printf("\nForced to exit prematurely\n");
>          exit(1);
>      }
196c199
<   cycflag = 0;
---
>     ntimes = (int) Maxdiffsteps;
198,199c201
<   thtimelo = thtimehi = thtemplo = thtemphi = 0.0;
<   thfile = NULL;
---
>     init();
201c203,205
<   checkargs(argc, argv);
---
>     /***
>     *    Open and read temperature history file
>     ***/
203,215c207,223
<   /* Initialize global filename arrays with defaults */
<   if (LogFileName[0] == '\0') {
<     sprintf(LogFileName, "disrealnew.log");
<   }
<   if (WorkingDirectory[0] == '\0') {
<     sprintf(WorkingDirectory, "./");
<   }
<   if (ProgressFileName[0] == '\0') {
<     sprintf(ProgressFileName, "progress.json");
<   }
<   if (ParameterFileName[0] == '\0') {
<     sprintf(ParameterFileName, "parameters.csv");
<   }
---
>      if (Adiaflag == 2) {
>          sprintf(buff,"%stemphist.dat",Outputdir);
>          thfile = filehandler("disrealnew",buff,"READ");
>          if (!thfile) {
>              freeallmem();
>              exit(1);
>          }
>          fscanf(thfile,"%s",instring);
>         thtimelo = atof(instring);
>          fscanf(thfile,"%s",instring);
>         thtimehi = atof(instring);
>          fscanf(thfile,"%s",instring);
>         thtemplo = atof(instring);
>          fscanf(thfile,"%s",instring);
>         thtemphi = atof(instring);
>          if (Verbose) printf("%f %f %f %f\n",thtimelo,thtimehi,thtemplo,thtemphi);
>      }
217,221c225,228
<   /* Open the log file and keep it open throughout */
<   if ((Logfile = fopen(LogFileName, "w")) == NULL) {
<     fprintf(stderr, "\nERROR:  Could not open %s\n\n", LogFileName);
<     exit(1);
<   }
---
>     /***
>     *    Set up names for output files, and
>     *    print headers where necessary
>     ***/
223,242c230,233
<   if (get_input(&pnucch, &pscalech, &pnuchg, &pscalehg, &pnucfh3, &pscalefh3,
<                 &pnucgyp, &pscalegyp, &nmovstep)) {
<     fprintf(stderr, "\nForced to exit prematurely\n\n");
<     exit(1);
<   }
< 
<   ntimes = (int)Maxdiffsteps;
< 
<   init();
< 
<   /***
<    *    Open and read temperature history file
<    ***/
< 
<   if (Adiaflag == 2) {
<     sprintf(buff, "%stemperature_history.csv", WorkingDirectory);
<     thfile = filehandler("disrealnew", buff, "READ");
<     if (!thfile) {
<       freeallmem();
<       exit(1);
---
>     if (initialize_output_files()) {
>         freeallmem();
>         bailout("disrealnew","Could not open file");
>         exit(1);
244,256d234
<     fscanf(thfile, "%s", instring);
<     thtimelo = atof(instring);
<     fscanf(thfile, "%c", &commachar);
<     fscanf(thfile, "%s", instring);
<     thtimehi = atof(instring);
<     fscanf(thfile, "%c", &commachar);
<     fscanf(thfile, "%s", instring);
<     thtemplo = atof(instring);
<     fscanf(thfile, "%c", &commachar);
<     fscanf(thfile, "%s", instring);
<     thtemphi = atof(instring);
<     fscanf(thfile, "%c", &commachar);
<   }
258,261c236,247
<   /***
<    *    Set up names for output files, and
<    *    print headers where necessary
<    ***/
---
>     /***
>     *    Krate is the rate constant relative to 298.15 K
>     *    E_act must be given here in kJ/mole/K
>     *
>     *    1000.0 is a unit conversion factor from kJ to J
>     *    8.314 is the gas constant in SI units
>     *    273.15 is the additive constant to convert C to K
>     *    298.15 is the reference temperature for the system, to
>     *        which all other temperatures are referenced when
>     *        computing changes in rate constants due to thermal
>     *        activation.
>     ***/
263,267c249
<   if (initialize_output_files()) {
<     freeallmem();
<     bailout("disrealnew", "Could not open file");
<     exit(1);
<   }
---
>     act_nrg = 1000.0 * E_act / 8.314;
269,280c251,252
<   /***
<    *    Krate is the rate constant relative to 298.15 K
<    *    E_act must be given here in kJ/mole/K
<    *
<    *    1000.0 is a unit conversion factor from kJ to J
<    *    8.314 is the gas constant in SI units
<    *    273.15 is the additive constant to convert C to K
<    *    298.15 is the reference temperature for the system, to
<    *        which all other temperatures are referenced when
<    *        computing changes in rate constants due to thermal
<    *        activation.
<    ***/
---
>     recip_Tdiff = (1.0/(Temp_cur_b + 273.15)) - (1.0/298.15);
>     Krate = exp(-(act_nrg * recip_Tdiff));
282c254
<   act_nrg = 1000.0 * E_act / 8.314;
---
>     /* Calculate pozzolanic and slag reaction rate constants */
284,285c256,257
<   recip_Tdiff = (1.0 / (Temp_cur_b + 273.15)) - (1.0 / 298.15);
<   Krate = exp(-(act_nrg * recip_Tdiff));
---
>     act_nrg = 1000.0 * E_act_pozz / 8.314;
>     kpozz = exp(-(act_nrg * recip_Tdiff));
287c259,260
<   /* Calculate pozzolanic and slag reaction rate constants */
---
>     act_nrg = 1000.0 * E_act_slag / 8.314;
>     kslag = exp(-(act_nrg * recip_Tdiff));
289,290c262,266
<   act_nrg = 1000.0 * E_act_pozz / 8.314;
<   kpozz = exp(-(act_nrg * recip_Tdiff));
---
>     /***
>     *    Modify probability of pozzolanic reaction
>     *    based on ratio of pozzolanic reaction rate
>     *    to hydration rate
>     ***/
292,293c268,275
<   act_nrg = 1000.0 * E_act_slag / 8.314;
<   kslag = exp(-(act_nrg * recip_Tdiff));
---
>     /***
>     *    Modify silica fume probabilities first.  There are
>     *    two effects postulated:
>     *    1. Early age effect due to nucleating capability
>     *       of silica fume with high BET values
>     *    2. Later age pozzolanic reactivity due to
>     *       SiO2 content of the silica fume (Psfume)
>     ***/
295,299c277,278
<   /***
<    *    Modify probability of pozzolanic reaction
<    *    based on ratio of pozzolanic reaction rate
<    *    to hydration rate
<    ***/
---
>     /** Late age effect dictated by Psfume **/
>     /** Psfume is for converting DIFFCH to POZZCSH **/
301,308c280,288
<   /***
<    *    Modify silica fume probabilities first.  There are
<    *    two effects postulated:
<    *    1. Early age effect due to nucleating capability
<    *       of silica fume with high BET values
<    *    2. Later age pozzolanic reactivity due to
<    *       SiO2 content of the silica fume (Psfume)
<    ***/
---
>     Psfume = PSFUME * (kpozz / Krate);
>     psfact = (SF_SiO2_val)/(SF_SiO2_normal);
>     betfact = (SF_BET_val)/(SF_BET_normal);
>     Psfume *= (3.0 * psfact * psfact * betfact);
>     if (Psfume > 1.0) Psfume = 1.0;
>     LOI_factor = 25.0 * (SF_LOI_val / SF_LOI_normal);
>     if (LOI_factor < 1.0) LOI_factor = 1.0;
>    
>     if (Verbose) printf("\n01. Psfume = %f",Psfume);
310,311c290
<   /** Late age effect dictated by Psfume **/
<   /** Psfume is for converting DIFFCH to POZZCSH **/
---
>     Pamsil = PAMSIL * (kpozz / Krate);
313,321c292
<   Psfume = PSFUME * (kpozz / Krate);
<   psfact = (SF_SiO2_val) / (SF_SiO2_normal);
<   betfact = (SF_BET_val) / (SF_BET_normal);
<   Psfume *= (3.0 * psfact * psfact * betfact);
<   if (Psfume > 1.0)
<     Psfume = 1.0;
<   LOI_factor = 25.0 * (SF_LOI_val / SF_LOI_normal);
<   if (LOI_factor < 1.0)
<     LOI_factor = 1.0;
---
>     /* ASSUME same holds for dissolution of fly ash phases */
323,324c294,295
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "\n01. Psfume = %f", Psfume);
---
>     Disprob[ASG] = Disbase[ASG] * (kpozz / Krate);
>     Disprob[CAS2] = Disbase[CAS2] * (kpozz / Krate);
326c297
<   Pamsil = PAMSIL * (kpozz / Krate);
---
>     /* Modify probability of slag dissolution */
328c299
<   /* ASSUME same holds for dissolution of fly ash phases */
---
>     Disprob[SLAG] = Slagreact * Disbase[SLAG] * (kslag / Krate);
330,331c301
<   Disprob[ASG] = Disbase[ASG] * (kpozz / Krate);
<   Disprob[CAS2] = Disbase[CAS2] * (kpozz / Krate);
---
>     /* Set initial properties of CSH */
333c303,304
<   /* Modify probability of slag dissolution */
---
>     Molarvcsh[0] = Molarv[CSH];
>     Watercsh[0] = Waterc[CSH];
335c306,309
<   Disprob[SLAG] = Slagreact * Disbase[SLAG] * (kslag / Krate);
---
>     /* Modify probability that CSH grows at POROSITY because of seeding */
>     /*  First calculate volume of saturated porosity.  Units of Csh_seeds */
>     /*  is number per um3, so it is automatically a probability of a voxel */
>     /*  being a seed */
337c311,312
<   /* Set initial properties of CSH */
---
>     PCSHseednuc = Csh_seeds;
>     if (PCSHseednuc > 1.0) PCSHseednuc = 1.0;
339,340c314
<   Molarvcsh[0] = Molarv[CSH];
<   Watercsh[0] = Waterc[CSH];
---
>     printf("\nProbability of CSH growing on a seed in solution = %f",PCSHseednuc);
342,345c316
<   /* Modify probability that CSH grows at POROSITY because of seeding */
<   /*  First calculate volume of saturated porosity.  Units of Csh_seeds */
<   /*  is number per um3, so it is automatically a probability of a voxel */
<   /*  being a seed */
---
>     /* Add CSH one-pixel particles randomly throughout the pore solution */
347,349c318
<   PCSHseednuc = Csh_seeds;
<   if (PCSHseednuc > 1.0)
<     PCSHseednuc = 1.0;
---
>     addseeds(CSH,PCSHseednuc);
351,352c320,322
<   fprintf(Logfile, "\nProbability of CSH growing on a seed in solution = %f",
<           PCSHseednuc);
---
>     /***
>     *    Initial surface counts of cement
>     ***/
354c324
<   /* Add CSH one-pixel particles randomly throughout the pore solution */
---
>     measuresurf();
356c326,328
<   addseeds(CSH, PCSHseednuc);
---
>     /***
>     *    This is the MAIN loop over hydration cycles
>     ***/
358,360c330,335
<   /***
<    *    Initial surface counts of cement
<    ***/
---
>     Time_cur = 0.0;
>     NextMovieTime = Time_cur + MovieFrameFreq;
>     NextImageTime = Time_cur + OutTimefreq;
>     NextBurnTime = Time_cur + Burntimefreq;
>     NextSetTime = Time_cur + Settimefreq;
>     NextPhydTime = Time_cur + Phydtimefreq;
362c337,338
<   measuresurf();
---
>     customentry = 0;
>     previousUncorrectedTime = 0.0;
364,366c340
<   /***
<    *    This is the MAIN loop over hydration cycles
<    ***/
---
>     for (Icyc = 1; ((Icyc <= Ncyc) && (Alpha_cur < Alpha_max) && (Time_cur < End_time)); Icyc++) {
368,373c342
<   Time_cur = 0.0;
<   NextMovieTime = Time_cur + MovieFrameFreq;
<   NextImageTime = Time_cur + OutTimefreq;
<   NextBurnTime = Time_cur + Burntimefreq;
<   NextSetTime = Time_cur + Settimefreq;
<   NextPhydTime = Time_cur + Phydtimefreq;
---
>         /* Write progress to progress file */
375,376c344,348
<   customentry = 0;
<   previousUncorrectedTime = 0.0;
---
> /*
>         Fprog = filehandler("genmic",Progfilename,"WRITE");
>         fprintf(Fprog,"%d\t%d",Icyc,Ncyc);
>         fclose(Fprog);
> */
378,380c350,359
<   for (Icyc = 1;
<        ((Icyc <= Ncyc) && (Alpha_cur < Alpha_max) && (Time_cur < End_time));
<        Icyc++) {
---
>         if (Verbose) {
>             printf("\nCycle %d\n",Icyc);
>             printf("Binder Temp = %f",Temp_cur_b);
>             if (Mass_agg > 0.0) {
>                 printf("; Aggregate Temp = %f\n",Temp_cur_agg);
>             } else {
>                 Temp_cur_agg = Temp_cur_b;
>                 printf("\n");
>             }
>         }
382,390c361,363
<     if (Verbose_flag > 1) {
<       fprintf(Logfile, "\nCycle %d", Icyc);
<       fprintf(Logfile, "\nBinder Temp = %f", Temp_cur_b);
<       if (Mass_agg > 0.0) {
<         fprintf(Logfile, "; Aggregate Temp = %f", Temp_cur_agg);
<       } else {
<         Temp_cur_agg = Temp_cur_b;
<       }
<     }
---
>         /***
>         *    Handle deactivation of surfaces if necessary
>         ***/
392,394c365,367
<     /***
<      *    Handle deactivation of surfaces if necessary
<      ***/
---
>         if (Numdeact > 0) {
>             manage_deactivation_behavior();
>         }
396,398c369
<     if (Numdeact > 0) {
<       manage_deactivation_behavior();
<     }
---
>         if (Temp_cur_b <= 80.0) { /* T units in deg C */
400c371
<     if (Temp_cur_b <= 80.0) { /* T units in deg C */
---
>             tmod =  (Temp_cur_b - 20.0) / (80.0 - 20.0);
402c373
<       tmod = (Temp_cur_b - 20.0) / (80.0 - 20.0);
---
>         } else {
404c375
<     } else {
---
>             tmod = 1.0;
406,407c377
<       tmod = 1.0;
<     }
---
>         }
409,410c379,380
<     Molarvcsh[Icyc] = Molarv[CSH] + (Molarvcshcoeff_T * tmod);
<     Watercsh[Icyc] = Waterc[CSH] + (Watercshcoeff_T * tmod);
---
>         Molarvcsh[Icyc] = Molarv[CSH] + (Molarvcshcoeff_T * tmod);
>         Watercsh[Icyc] = Waterc[CSH] + (Watercshcoeff_T * tmod);
412,413c382
<     if (Icyc == Ncyc || Alpha_cur >= Alpha_max || Time_cur >= End_time)
<       cycflag = 1;
---
>         if (Icyc == Ncyc || Alpha_cur >= Alpha_max || Time_cur >= End_time) cycflag = 1;
415,418c384,387
<     /***
<      *    Dissolve necessary pixels and form
<      *    ants for diffusion
<      ***/
---
>         /***
>         *    Dissolve necessary pixels and form
>         *    ants for diffusion
>         ***/
420c389
<     dissolve(Icyc);
---
>         dissolve(Icyc);
422,426c391,395
<     /***
<      *  Calculate volume ratio of sulfates to C3A on first cycle only
<      *  This must be done after dissolve because only then are the initial
<      *  counts of each phase available
<      ***/
---
>         /***
>         *  Calculate volume ratio of sulfates to C3A on first cycle only
>         *  This must be done after dissolve because only then are the initial
>         *  counts of each phase available
>         ***/
428,447c397,412
<     if (Icyc == 1) {
<       SulftoC3A =
<           ((float)(Ncsbar + Heminit + Anhinit)) / ((float)(C3ainit + Oc3ainit));
<       if (SulftoC3A <= 0.8) {
<         smod = 0.0;
<       } else if (SulftoC3A <= 1.25) {
<         smod = (SulftoC3A - 0.8) / (1.25 - 0.8);
<       } else {
<         smod = 1.0;
<       }
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "\n\n\n******SulftoC3A = %f", SulftoC3A);
<         fprintf(Logfile, "\n******Just changed Molarvcsh from %f ",
<                 Molarv[CSH]);
<       }
<       Molarv[CSH] += (Molarvcshcoeff_sulf * smod);
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "to %f ***************\n\n", Molarv[CSH]);
<       }
<     }
---
>         if (Icyc == 1) {
>             SulftoC3A = ((float)(Ncsbar + Heminit + Anhinit))
>                             /((float)(C3ainit + Oc3ainit));
>             if (SulftoC3A <= 0.8) {
>                 smod = 0.0;
>             } else if (SulftoC3A <= 1.25) {
>                 smod = (SulftoC3A - 0.8) / (1.25 - 0.8);
>             } else {
>                 smod = 1.0;
>             }
>             printf("\n\n\n******SulftoC3A = %f",SulftoC3A);           
>             printf("\n\n\n******Just changed Molarvcsh from %f ",Molarv[CSH]);           
>             Molarv[CSH] += (Molarvcshcoeff_sulf * smod);
>             printf("to %f ***************\n\n\n",Molarv[CSH]);
>             fflush(stdout);
>         }
449,451c414,416
<     if (Verbose_flag > 1) {
<       fprintf(Logfile, "\nNumber dissolved this pass- %d ", Nmade);
<       fprintf(Logfile, "total diffusing- %d", Ngoing);
---
>         if (Verbose) {
>             printf("Number dissolved this pass- %d ",Nmade);
>             printf("total diffusing- %d \n",Ngoing);
453,457c418,422
<       if (Icyc == 1) {
<         fprintf(Logfile, "\nNcsbar is %d   Netbar is %d", Ncsbar, Netbar);
<       }
<       fflush(Logfile);
<     }
---
>             if (Icyc == 1) {
>                 printf("Ncsbar is %d   Netbar is %d \n",Ncsbar,Netbar);
>             }
>             fflush(stdout);
>         }
459,460c424,425
<     hydrate(cycflag, ntimes, pnucch, pscalech, pnuchg, pscalehg, pnucfh3,
<             pscalefh3, pnucgyp, pscalegyp);
---
>         hydrate(cycflag,ntimes,pnucch,pscalech,pnuchg,
>                     pscalehg,pnucfh3,pscalefh3,pnucgyp,pscalegyp);
462c427
<     /* Cement + aggregate +water + filler=1;  that's all there is */
---
>         /* Cement + aggregate +water + filler=1;  that's all there is */
464,465c429,430
<     mass_cement = 1.0 - (Mass_agg + Mass_fill + Mass_water + Mass_CH);
<     mass_cem_now = mass_cement;
---
>         mass_cement = 1.0 - (Mass_agg + Mass_fill + Mass_water + Mass_CH);
>         mass_cem_now = mass_cement;
467,469c432,434
<     /***
<      *    Handle adiabatic case first
<      ***/
---
>         /***
>         *    Handle adiabatic case first
>         ***/
471c436
<     if (Adiaflag == 1) {
---
>         if (Adiaflag == 1) {
473,476c438,441
<       /***
<        *    Determine heat capacity of current mixture,
<        *    accounting for imbibed water if necessary
<        ***/
---
>             /***
>             *    Determine heat capacity of current mixture,
>             *    accounting for imbibed water if necessary
>             ***/
478c443
<       if (Sealed == 1) {
---
>             if (Sealed == 1) {
480c445
<         /* Accounting for aggregate separately (15 Nov 2004) */
---
>                 /* Accounting for aggregate separately (15 Nov 2004) */
482,484c447,449
<         Cp_b = Cp_pozz * Mass_fill;
<         Cp_b += Cp_cement * mass_cement;
<         Cp_b += Cp_ch * Mass_CH;
---
>                 Cp_b = Cp_pozz * Mass_fill;
>                 Cp_b += Cp_cement * mass_cement;
>                 Cp_b += Cp_ch * Mass_CH;
486,489c451,453
<         Cp_b += (Cp_h2o * Mass_water) -
<                 (Alpha_cur * WN * mass_cement * (Cp_h2o - Cp_bh2o));
<         if (AggTempEffect == 0)
<           Cp_b += (Cp_agg * Mass_agg);
---
>                 Cp_b += (Cp_h2o * Mass_water)
>                     - (Alpha_cur * WN * mass_cement * (Cp_h2o - Cp_bh2o));
>                 if (AggTempEffect == 0) Cp_b += (Cp_agg * Mass_agg);
491c455
<         mass_cem_now = mass_cement;
---
>                 mass_cem_now = mass_cement;
493c457
<       } else {
---
>             } else {
495,504c459,468
<         /***
<          *    If not sealed, need to account for extra capillary
<          *    water drawn in.
<          *
<          *    Basis is WCHSH(0.06) g H2O per gram cement for
<          *    chemical shrinkage
<          *
<          *    Need to adjust mass basis to account for extra
<          *    imbibed H2O
<          ***/
---
>                 /***
>                 *    If not sealed, need to account for extra capillary
>                 *    water drawn in.
>                 *
>                 *    Basis is WCHSH(0.06) g H2O per gram cement for
>                 *    chemical shrinkage
>                 *
>                 *    Need to adjust mass basis to account for extra
>                 *    imbibed H2O
>                 ***/
506c470
<         mass_cur = 1.0 + (WCHSH * mass_cement * Alpha_cur);
---
>                 mass_cur = 1.0 + (WCHSH * mass_cement * Alpha_cur);
508c472
<         /* Accounting for aggregate separately (15 Nov 2004) */
---
>                 /* Accounting for aggregate separately (15 Nov 2004) */
510,512c474,476
<         Cp_b = Cp_pozz * Mass_fill / mass_cur;
<         Cp_b += (Cp_cement * mass_cement / mass_cur);
<         Cp_b += (Cp_ch * Mass_CH / mass_cur);
---
>                 Cp_b = Cp_pozz * Mass_fill / mass_cur;
>                 Cp_b += (Cp_cement * mass_cement / mass_cur);
>                 Cp_b += (Cp_ch * Mass_CH / mass_cur);
514,515c478,479
<         Cp_b += (Cp_h2o * Mass_water) -
<                 (Alpha_cur * WN * mass_cement * (Cp_h2o - Cp_bh2o));
---
>                 Cp_b += (Cp_h2o * Mass_water)
>                     - (Alpha_cur * WN * mass_cement * (Cp_h2o - Cp_bh2o));
517,519c481,482
<         Cp_b += (WCHSH * Cp_h2o * Alpha_cur * mass_cement);
<         if (AggTempEffect == 0)
<           Cp_b += ((Cp_agg * Mass_agg) / mass_cur);
---
>                 Cp_b += (WCHSH * Cp_h2o * Alpha_cur * mass_cement);
>                 if (AggTempEffect == 0) Cp_b += ((Cp_agg * Mass_agg)/mass_cur);
521,522c484,485
<         mass_cem_now = mass_cement / mass_cur;
<       }
---
>                 mass_cem_now = mass_cement / mass_cur;
>             }
524,535c487,498
<       /***
<        *    Determine rate constant based on Arrhenius expression
<        *
<        *    Recall that Temp_cur_b is in degrees Celsius
<        *
<        *    1000.0 converts kJ to J
<        *    8.314 is the gas constant in SI units
<        *    273.15 adds to T to convert from C to K
<        *    298.15 is the reference temperature (in K) to which
<        *        all other temperatures are compared when computing
<        *        changes in rate constants due to thermal activation
<        ***/
---
>             /***
>             *    Determine rate constant based on Arrhenius expression
>             *
>             *    Recall that Temp_cur_b is in degrees Celsius
>             *
>             *    1000.0 converts kJ to J
>             *    8.314 is the gas constant in SI units
>             *    273.15 adds to T to convert from C to K
>             *    298.15 is the reference temperature (in K) to which
>             *        all other temperatures are compared when computing
>             *        changes in rate constants due to thermal activation
>             ***/
537,539c500,502
<       act_nrg = 1000.0 * E_act / 8.314;
<       recip_Tdiff = (1.0 / (Temp_cur_b + 273.15)) - (1.0 / 298.15);
<       Krate = exp(-(act_nrg * recip_Tdiff));
---
>             act_nrg = 1000.0 * E_act / 8.314;
>             recip_Tdiff = (1.0/(Temp_cur_b + 273.15)) - (1.0/298.15);
>             Krate = exp(-(act_nrg * recip_Tdiff));
541c504
<       /* Calculate pozzolanic and slag reaction rate constant */
---
>             /* Calculate pozzolanic and slag reaction rate constant */
543,546c506,509
<       act_nrg = 1000.0 * E_act_pozz / 8.314;
<       kpozz = exp(-(act_nrg * recip_Tdiff));
<       act_nrg = 1000.0 * E_act_slag / 8.314;
<       kslag = exp(-(act_nrg * recip_Tdiff));
---
>             act_nrg = 1000.0 * E_act_pozz / 8.314;
>             kpozz = exp(-(act_nrg * recip_Tdiff));
>             act_nrg = 1000.0 * E_act_slag / 8.314;
>             kslag = exp(-(act_nrg * recip_Tdiff));
548,555c511,518
<       /***
<        *    Modify silica fume probabilities.  There are
<        *    two effects postulated:
<        *    1. Early age effect due to nucleating capability
<        *       of silica fume with high BET values
<        *    2. Later age pozzolanic reactivity due to
<        *       SiO2 content of the silica fume (Psfume)
<        ***/
---
>             /***
>             *    Modify silica fume probabilities.  There are
>             *    two effects postulated:
>             *    1. Early age effect due to nucleating capability
>             *       of silica fume with high BET values
>             *    2. Later age pozzolanic reactivity due to
>             *       SiO2 content of the silica fume (Psfume)
>             ***/
557,558c520,521
<       /** Late age effect dictated by Psfume **/
<       /** Psfume is for converting DIFFCH to POZZCSH **/
---
>             /** Late age effect dictated by Psfume **/
>             /** Psfume is for converting DIFFCH to POZZCSH **/
560,568c523,529
<       Psfume = PSFUME * (kpozz / Krate);
<       psfact = (SF_SiO2_val) / (SF_SiO2_normal);
<       betfact = (SF_BET_val) / (SF_BET_normal);
<       Psfume *= (3.0 * psfact * psfact * betfact);
<       if (Psfume > 1.0)
<         Psfume = 1.0;
<       LOI_factor = 25.0 * (SF_LOI_val / SF_LOI_normal);
<       if (LOI_factor < 1.0)
<         LOI_factor = 1.0;
---
>             Psfume = PSFUME * (kpozz / Krate);
>             psfact = (SF_SiO2_val)/(SF_SiO2_normal);
>             betfact = (SF_BET_val)/(SF_BET_normal);
>             Psfume *= (3.0 * psfact * psfact * betfact);
>             if (Psfume > 1.0) Psfume = 1.0;
>             LOI_factor = 25.0 * (SF_LOI_val / SF_LOI_normal);
>             if (LOI_factor < 1.0) LOI_factor = 1.0;
570,574c531,535
<       /***
<        *    Modify probability of pozzolanic and slag
<        *    reactions based on ratio of pozzolanic (slag)
<        *    reaction rate to the hydration rate
<        ***/
---
>             /***
>             *    Modify probability of pozzolanic and slag
>             *    reactions based on ratio of pozzolanic (slag)
>             *    reaction rate to the hydration rate
>             ***/
576,579c537,540
<       Pamsil = PAMSIL * (kpozz / Krate);
<       Disprob[ASG] = Disbase[ASG] * (kpozz / Krate);
<       Disprob[CAS2] = Disbase[CAS2] * (kpozz / Krate);
<       Disprob[SLAG] = Slagreact * Disbase[SLAG] * (kslag / Krate);
---
>             Pamsil = PAMSIL * (kpozz / Krate);
>             Disprob[ASG] = Disbase[ASG] * (kpozz / Krate);
>             Disprob[CAS2] = Disbase[CAS2] * (kpozz / Krate);
>             Disprob[SLAG] = Slagreact * Disbase[SLAG] * (kslag / Krate);
581,584c542,545
<       /***
<        *    Update temperature based on heat generated
<        *    and current Cp
<        ***/
---
>             /***
>             *    Update temperature based on heat generated
>             *    and current Cp
>             ***/
586c547
<       if (mass_cem_now > 0.01) {
---
>             if (mass_cem_now > 0.01) {
588,594c549,555
<         /***
<          *     If the temperature of the aggregate is different
<          *     from that of the binder, then we calculate the
<          *     temperature change of each separately due to
<          *     energy conservation principles, otherwise, we
<          *     handle temperature changes as previously
<          ***/
---
>                 /***
>                 *     If the temperature of the aggregate is different
>                 *     from that of the binder, then we calculate the
>                 *     temperature change of each separately due to
>                 *     energy conservation principles, otherwise, we
>                 *     handle temperature changes as previously
>                 ***/
596c557
<         calcT(mass_cem_now);
---
>                 calcT(mass_cem_now);
598c559
<       } else {
---
>              } else {
600,601c561,562
<         calcT(Mass_fill_pozz);
<       }
---
>                 calcT(Mass_fill_pozz);
>              }
603c564,565
<     } else if (Adiaflag == 2) {
---
>             
>         } else if (Adiaflag == 2) {
605,608c567,570
<       /***
<        *    Update system temperature based on current time
<        *    and requested temperature history
<        ***/
---
>             /***
>             *    Update system temperature based on current time 
>             *    and requested temperature history
>             ***/
610,624c572,586
<       while ((Time_cur > thtimehi) && (!feof(thfile))) {
<         fscanf(thfile, "%s", instring);
<         thtimelo = atof(instring);
<         fscanf(thfile, "%s", instring);
<         thtimehi = atof(instring);
<         fscanf(thfile, "%s", instring);
<         thtemplo = atof(instring);
<         fscanf(thfile, "%s", instring);
<         thtemphi = atof(instring);
<         if (Verbose_flag > 1) {
<           fprintf(Logfile, "\nNew temperature history values : ");
<           fprintf(Logfile, "\n%f %f ", thtimelo, thtimehi);
<           fprintf(Logfile, "%f %f", thtemplo, thtemphi);
<         }
<       }
---
>             while ((Time_cur > thtimehi) && (!feof(thfile))) {
>                 fscanf(thfile,"%s",instring);
>                 thtimelo = atof(instring);
>                 fscanf(thfile,"%s",instring);
>                 thtimehi = atof(instring);
>                 fscanf(thfile,"%s",instring);
>                 thtemplo = atof(instring);
>                 fscanf(thfile,"%s",instring);
>                 thtemphi = atof(instring);
>                 if (Verbose) {
>                     printf("New temperature history values : \n");
>                     printf("%f %f ",thtimelo,thtimehi);
>                     printf("%f %f\n",thtemplo,thtemphi);
>                 }
>             }
626,633c588,595
<       if ((thtimehi - thtimelo) > 0.0) {
<         Temp_cur_b = thtemplo + ((thtemphi - thtemplo) * (Time_cur - thtimelo) /
<                                  (thtimehi - thtimelo));
<         Temp_cur_agg = Temp_cur_b;
<       } else {
<         Temp_cur_b = thtemplo;
<         Temp_cur_agg = Temp_cur_b;
<       }
---
>             if ((thtimehi - thtimelo) > 0.0) {
>                 Temp_cur_b = thtemplo + ( (thtemphi - thtemplo)
>                         * (Time_cur - thtimelo) / (thtimehi - thtimelo) );
>                 Temp_cur_agg = Temp_cur_b;
>             } else {
>                 Temp_cur_b=thtemplo;
>                 Temp_cur_agg = Temp_cur_b;
>             }
635,642c597,604
<       /***
<        *    1000.0 converts kJ to J
<        *    8.314 is the gas constant in SI units
<        *    273.15 adds to T to convert from C to K
<        *    298.15 is the reference temperature (in K) to which
<        *        all other temperatures are compared when computing
<        *        changes in rate constants due to thermal activation
<        ***/
---
>             /***
>             *    1000.0 converts kJ to J
>             *    8.314 is the gas constant in SI units
>             *    273.15 adds to T to convert from C to K
>             *    298.15 is the reference temperature (in K) to which
>             *        all other temperatures are compared when computing
>             *        changes in rate constants due to thermal activation
>             ***/
644,646c606,608
<       act_nrg = 1000.0 * E_act / 8.314;
<       recip_Tdiff = (1.0 / (Temp_cur_b + 273.15)) - (1.0 / 298.15);
<       Krate = exp(-(act_nrg * recip_Tdiff));
---
>             act_nrg = 1000.0 * E_act / 8.314;
>             recip_Tdiff = (1.0/(Temp_cur_b + 273.15)) - (1.0/298.15);
>             Krate = exp(-(act_nrg * recip_Tdiff));
648c610
<       /* Calculate pozzolanic and slag reaction rate constant */
---
>             /* Calculate pozzolanic and slag reaction rate constant */
650,653c612,615
<       act_nrg = 1000.0 * E_act_pozz / 8.314;
<       kpozz = exp(-(act_nrg * recip_Tdiff));
<       act_nrg = 1000.0 * E_act_slag / 8.314;
<       kslag = exp(-(act_nrg * recip_Tdiff));
---
>             act_nrg = 1000.0 * E_act_pozz / 8.314;
>             kpozz = exp(-(act_nrg * recip_Tdiff));
>             act_nrg = 1000.0 * E_act_slag / 8.314;
>             kslag = exp(-(act_nrg * recip_Tdiff));
655,659c617,675
<       /***
<        *    Modify probability of pozzolanic and slag
<        *    reactions based on ratio of pozzolanic (slag)
<        *    reaction rate to the hydration rate
<        ***/
---
>             /***
>             *    Modify probability of pozzolanic and slag
>             *    reactions based on ratio of pozzolanic (slag)
>             *    reaction rate to the hydration rate
>             ***/
> 
>             /** Late age effect dictated by Psfume **/
>             /** Psfume is for converting DIFFCH to POZZCSH **/
> 
>             Psfume = PSFUME * (kpozz / Krate);
>             psfact = (SF_SiO2_val)/(SF_SiO2_normal);
>             betfact = (SF_BET_val)/(SF_BET_normal);
>             Psfume *= (3.0 * psfact * psfact * betfact);
>             if (Psfume > 1.0) Psfume = 1.0;
>             LOI_factor = 25.0 * (SF_LOI_val / SF_LOI_normal);
>             if (LOI_factor < 1.0) LOI_factor = 1.0;
> 
>             Pamsil = PAMSIL * (kpozz / Krate);
>             Disprob[ASG] = Disbase[ASG] * (kpozz / Krate);
>             Disprob[CAS2] = Disbase[CAS2] * (kpozz / Krate);
>             Disprob[SLAG] = Slagreact * Disbase[SLAG] * (kslag / Krate);
>         }
>     
>         /***
>         *    Modify time based on simple numerical integration,
>         *    simulating maturity approach with parabolic kinetics
>         *    (Knudsen model)
>         ***/
> 
>         if (Verbose) printf("\nIcyc = %d AND Cyccnt = %d\n",Icyc,Cyccnt);
>         if (Cyccnt > 1) {
>             switch (TimeCalibrationMethod) {
>                 case CALORIMETRIC:
>                     dval = Heat_new * Heat_cf;
>                     sprintf(typestring,"calorimetric");
>                     if (dval < DataValue[0]) {
>                         if (Verbose) printf("\ndval = %f, DataValue[0] = %f, DataValue[1] = %f\n",dval,DataValue[0],DataValue[1]);
>                         TimeHistory[Cyccnt] = DataTime[0];
>                     } else {
>                         findnewtime(dval,act_nrg,&previousUncorrectedTime,typestring);
>                     }
>                     break;
>                 case CHEMICALSHRINKAGE:
>                     dval = Chs_new;
>                     if (dval <= 0.0) dval = 0.00001;
>                     sprintf(typestring,"chemical shrinkage");
>                     if (dval < DataValue[0]) {
>                         if (Verbose) printf("\ndval = %f, DataValue[0] = %f, DataValue[1] = %f\n",dval,DataValue[0],DataValue[1]);
>                         TimeHistory[Cyccnt] = DataTime[0];
>                     } else {
>                         findnewtime(dval,act_nrg,&previousUncorrectedTime,typestring);
>                     }
>                     break;
>                 default:
>                     Time_step = (2.0 * (float)(Cyccnt - 1) - 1.0) * Beta/Krate;
>                     Time_cur += Time_step;
>                     TimeHistory[Cyccnt] = Time_cur;
>                     break;
>             }
661,662c677
<       /** Late age effect dictated by Psfume **/
<       /** Psfume is for converting DIFFCH to POZZCSH **/
---
>         }
664,672c679
<       Psfume = PSFUME * (kpozz / Krate);
<       psfact = (SF_SiO2_val) / (SF_SiO2_normal);
<       betfact = (SF_BET_val) / (SF_BET_normal);
<       Psfume *= (3.0 * psfact * psfact * betfact);
<       if (Psfume > 1.0)
<         Psfume = 1.0;
<       LOI_factor = 25.0 * (SF_LOI_val / SF_LOI_normal);
<       if (LOI_factor < 1.0)
<         LOI_factor = 1.0;
---
>         /* Initialize and calculate gel-space ratio */
674,678c681,687
<       Pamsil = PAMSIL * (kpozz / Krate);
<       Disprob[ASG] = Disbase[ASG] * (kpozz / Krate);
<       Disprob[CAS2] = Disbase[CAS2] * (kpozz / Krate);
<       Disprob[SLAG] = Slagreact * Disbase[SLAG] * (kslag / Krate);
<     }
---
>         Gsratio2 = 0.0;
>         Gsratio2 += (double)(Count[CH] + Count[CSH]);
>         Gsratio2 += (double)(Count[C3AH6] + Count[ETTR]);
>         Gsratio2 += (double)(Count[POZZCSH] + Count[SLAGCSH]);
>         Gsratio2 += (double)(Count[FH3] + Count[AFM] + Count[ETTRC4AF]);
>         Gsratio2 += (double)(Count[FRIEDEL] + Count[STRAT]);
>         Gsratio2 += (double)(Count[ABSGYP] + Count[AFMC]);
680,684c689
<     /***
<      *    Modify time based on simple numerical integration,
<      *    simulating maturity approach with parabolic kinetics
<      *    (Knudsen model)
<      ***/
---
>         space = (double)(Count[POROSITY] + Count[CRACKP] + Count[EMPTYP]);
686,700c691,695
<     if (Verbose_flag > 1)
<       fprintf(Logfile, "\nIcyc = %d AND Cyccnt = %d", Icyc, Cyccnt);
<     if (Cyccnt > 1) {
<       switch (TimeCalibrationMethod) {
<       case CALORIMETRIC:
<         dval = Heat_new * Heat_cf;
<         sprintf(typestring, "calorimetric");
<         if (dval < DataValue[0]) {
<           if (Verbose_flag > 1)
<             fprintf(Logfile,
<                     "\n\ndval = %f, DataValue[0] = %f, DataValue[1] = %f", dval,
<                     DataValue[0], DataValue[1]);
<           TimeHistory[Cyccnt] = DataTime[0];
<         } else {
<           findnewtime(dval, act_nrg, &previousUncorrectedTime, typestring);
---
>         Gsratio2 = (Gsratio2) / (Gsratio2 + space);
> 
>         gfloat = 0.0;
>         if (W_to_c != 0.0) {
>             gfloat = (double)((0.68 * Alpha_cur) / (0.32 * Alpha_cur + W_to_c));
702,715c697,702
<         break;
<       case CHEMICALSHRINKAGE:
<         dval = Chs_new;
<         if (dval <= 0.0)
<           dval = 0.00001;
<         sprintf(typestring, "chemical shrinkage");
<         if (dval < DataValue[0]) {
<           if (Verbose_flag > 1)
<             fprintf(Logfile,
<                     "\ndval = %f, DataValue[0] = %f, DataValue[1] = %f", dval,
<                     DataValue[0], DataValue[1]);
<           TimeHistory[Cyccnt] = DataTime[0];
<         } else {
<           findnewtime(dval, act_nrg, &previousUncorrectedTime, typestring);
---
> 
>         if (Verbose) printf("Entering pHpred");
>         pHpred();
>         if (Verbose) {
>             printf("Returned from call to pHpred");
>             fflush(stdout);
717,724d703
<         break;
<       default:
<         Time_step = (2.0 * (float)(Cyccnt - 1) - 1.0) * Beta / Krate;
<         Time_cur += Time_step;
<         TimeHistory[Cyccnt] = Time_cur;
<         break;
<       }
<     }
726c705,713
<     /* Initialize and calculate gel-space ratio */
---
>         /***
>         *    Check percolation of pore space
>         *
>         *    Note that first two variables passed correspond
>         *    to phases to check in combination.
>         *    Could easily add calls to
>         *    check for percolation of CH, CSH, etc.
>         *    (24 May 2004)
>         ***/
728,734c715,716
<     Gsratio2 = 0.0;
<     Gsratio2 += (double)(Count[CH] + Count[CSH]);
<     Gsratio2 += (double)(Count[C3AH6] + Count[ETTR]);
<     Gsratio2 += (double)(Count[POZZCSH] + Count[SLAGCSH]);
<     Gsratio2 += (double)(Count[FH3] + Count[AFM] + Count[ETTRC4AF]);
<     Gsratio2 += (double)(Count[FRIEDEL] + Count[STRAT]);
<     Gsratio2 += (double)(Count[ABSGYP] + Count[AFMC]);
---
>         if ((Time_cur >= NextBurnTime)
>             && ((Porefl1 + Porefl2 + Porefl3) != 0)) {
736c718
<     space = (double)(Count[POROSITY] + Count[CRACKP] + Count[EMPTYP]);
---
>             /* Burn across x */
738c720
<     Gsratio2 = (Gsratio2) / (Gsratio2 + space);
---
>             NextBurnTime = Time_cur + Burntimefreq;
740,743c722,765
<     gfloat = 0.0;
<     if (W_to_c != 0.0) {
<       gfloat = (double)((0.68 * Alpha_cur) / (0.32 * Alpha_cur + W_to_c));
<     }
---
>             if (Verbose) {
>                 printf("\nGoing to check percolation of porosity in X... ");
>                 fflush(stdout);
>             }
>             Porefl1 = burn3d(((int)POROSITY),((int)CRACKP),1,0,0);
>             if (Verbose) {
>                 printf("Done!\n");
>                 fflush(stdout);
>             }
>             if (Porefl1 == -1) {
>                 freeallmem();
>                 bailout("disrealnew","Problem in burn3d");
>                 exit(1);
>             }
>             /* Burn across y */
>             if (Verbose) {
>                 printf("\nGoing to check percolation of porosity in Y... ");
>                 fflush(stdout);
>             }
>             Porefl2 = burn3d(((int)POROSITY),((int)CRACKP),0,1,0);
>             if (Verbose) {
>                 printf("Done!\n");
>                 fflush(stdout);
>             }
>             if (Porefl2 == -1) {
>                 freeallmem();
>                 bailout("disrealnew","Problem in burn3d");
>                 exit(1);
>             }
>             /* Burn across z */
>             if (Verbose) {
>                 printf("\nGoing to check percolation of porosity in Z... ");
>                 fflush(stdout);
>             }
>             Porefl3 = burn3d(((int)POROSITY),((int)CRACKP),0,0,1);
>             if (Verbose) {
>                 printf("Done!\n");
>                 fflush(stdout);
>             }
>             if (Porefl3 == -1) {
>                 freeallmem();
>                 bailout("disrealnew","Problem in burn3d");
>                 exit(1);
>             }
745,751c767,770
<     if (Verbose_flag > 2)
<       fprintf(Logfile, "\nEntering pHpred");
<     pHpred();
<     if (Verbose_flag > 2) {
<       fprintf(Logfile, "\nReturned from call to pHpred");
<       fflush(Logfile);
<     }
---
>             /***
>             *    Switch to self-desiccating conditions
>             *    when porosity disconnects
>             ***/
753,761c772,799
<     /***
<      *    Check percolation of pore space
<      *
<      *    Note that first two variables passed correspond
<      *    to phases to check in combination.
<      *    Could easily add calls to
<      *    check for percolation of CH, CSH, etc.
<      *    (24 May 2004)
<      ***/
---
> /*
>             if (Crackwidth == 0 || Icyc < Crackcycle) {
>                 if (((Porefl1 + Porefl2 + Porefl3) == 0) && (!Sealed)) {
>                     Water_off = Water_left;
>                     Pore_off = Countkeep;
>                     Sealed = 1;
>                     if (Verbose) printf("Switching to self-desiccating at cycle %d \n",Cyccnt);
>                 }
>             } else {
>                  if ((Porefl1 == 0) && (Crackorient == 1) && (!Sealed)) {
>                      Water_off = Water_left;
>                      Pore_off = Countkeep;
>                      Sealed = 1;
>                      if (Verbose) printf("Switching to self-desiccating at cycle %d \n",Cyccnt);
>                  } else if ((Porefl2 == 0) && (Crackorient == 2) && (!Sealed)) {
>                      Water_off = Water_left;
>                      Pore_off = Countkeep;
>                      Sealed = 1;
>                      if (Verbose) printf("Switching to self-desiccating at cycle %d \n",Cyccnt);
>                  } else if ((Porefl3 == 0) && (Crackorient == 3) && (!Sealed)) {
>                      Water_off = Water_left;
>                      Pore_off = Countkeep;
>                      Sealed = 1;
>                      if (Verbose) printf("Switching to self-desiccating at cycle %d \n",Cyccnt);
>                  }
>             }
> */
>         }
763c801
<     if ((Time_cur >= NextBurnTime) && ((Porefl1 + Porefl2 + Porefl3) != 0)) {
---
>         /* Check percolation of solids (set point) */
765c803
<       /* Burn across x */
---
>         if ((Time_cur >= NextSetTime) && (!Setflag)) {
767c805
<       NextBurnTime = Time_cur + Burntimefreq;
---
>             NextSetTime = Time_cur + Settimefreq;
769,817c807,825
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "\nGoing to check percolation of porosity in X... ");
<         fflush(Logfile);
<       }
<       Porefl1 = burn3d(((int)POROSITY), ((int)CRACKP), 1, 0, 0);
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "Done!");
<         fflush(Logfile);
<       }
<       if (Porefl1 == -1) {
<         freeallmem();
<         bailout("disrealnew", "Problem in burn3d");
<         exit(1);
<       }
<       /* Burn across y */
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "\n\nGoing to check percolation of porosity in Y... ");
<         fflush(Logfile);
<       }
<       Porefl2 = burn3d(((int)POROSITY), ((int)CRACKP), 0, 1, 0);
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "Done!");
<         fflush(Logfile);
<       }
<       if (Porefl2 == -1) {
<         freeallmem();
<         bailout("disrealnew", "Problem in burn3d");
<         exit(1);
<       }
<       /* Burn across z */
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "\n\nGoing to check percolation of porosity in Z... ");
<         fflush(Logfile);
<       }
<       Porefl3 = burn3d(((int)POROSITY), ((int)CRACKP), 0, 0, 1);
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "Done!");
<         fflush(Logfile);
<       }
<       if (Porefl3 == -1) {
<         freeallmem();
<         bailout("disrealnew", "Problem in burn3d");
<         exit(1);
<       }
< 
<       /***
<        *    Switch to self-desiccating conditions
<        *    when porosity disconnects
<        ***/
---
>             if (Verbose) {
>                 printf("\nGoing to check percolation of solids in X... ");
>                 fflush(stdout);
>             }
>             Sf1 = burnset(1,0,0);    /* Burn across x */
>             if (Verbose) {
>                 printf("Done!\nGoing to check percolation of solids in Y... ");
>                 fflush(stdout);
>             }
>             Sf2 = burnset(0,1,0);    /* Burn across y */
>             if (Verbose) {
>                 printf("Done!\nGoing to check percolation of solids in Z... ");
>                 fflush(stdout);
>             }
>             Sf3 = burnset(0,0,1);    /* Burn across z */
>             if (Verbose) {
>                 printf("Done!");
>                 fflush(stdout);
>             }
819,846c827
<       /*
<                   if (Crackwidth == 0 || Icyc < Crackcycle) {
<                       if (((Porefl1 + Porefl2 + Porefl3) == 0) && (!Sealed)) {
<                           Water_off = Water_left;
<                           Pore_off = Countkeep;
<                           Sealed = 1;
<                           if (Verbose_flag == 2) fprintf(Logfile,"Switching to
<          self-desiccating at cycle %d \n",Cyccnt);
<                       }
<                   } else {
<                        if ((Porefl1 == 0) && (Crackorient == 1) && (!Sealed)) {
<                            Water_off = Water_left;
<                            Pore_off = Countkeep;
<                            Sealed = 1;
<                            if (Verbose_flag == 2) fprintf(Logfile,"Switching to
<          self-desiccating at cycle %d \n",Cyccnt); } else if ((Porefl2 == 0) &&
<          (Crackorient == 2)
<          && (!Sealed)) { Water_off = Water_left; Pore_off = Countkeep; Sealed =
<          1; if (Verbose_flag == 2) fprintf(Logfile,"Switching to
<          self-desiccating at cycle %d
<          \n",Cyccnt); } else if ((Porefl3 == 0) && (Crackorient == 3) &&
<          (!Sealed)) { Water_off = Water_left; Pore_off = Countkeep; Sealed = 1;
<                            if (Verbose_flag == 2) fprintf(Logfile,"Switching to
<          self-desiccating at cycle %d \n",Cyccnt);
<                        }
<                   }
<       */
<     }
---
>             Setflag = Sf1 * Sf2 * Sf3;
848c829
<     /* Check percolation of solids (set point) */
---
>         }
850c831
<     if ((Time_cur >= NextSetTime) && (!Setflag)) {
---
>         /* Check hydration of particles */
852c833,841
<       NextSetTime = Time_cur + Settimefreq;
---
>         
>         if (Time_cur >= NextPhydTime) {
>             NextPhydTime = Time_cur + Phydtimefreq;
>             if((parthyd()) == MEMERR) {
>                 freeallmem();
>                 bailout("disrealnew","Problem with parthyd");
>                 exit(1);
>             }
>         }
854,874c843
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "\n\nGoing to check percolation of solids in X... ");
<         fflush(Logfile);
<       }
<       Sf1 = burnset(1, 0, 0); /* Burn across x */
<       if (Verbose_flag > 2) {
<         fprintf(Logfile,
<                 "Done!\nGoing to check percolation of solids in Y... ");
<         fflush(Logfile);
<       }
<       Sf2 = burnset(0, 1, 0); /* Burn across y */
<       if (Verbose_flag > 2) {
<         fprintf(Logfile,
<                 "Done!\nGoing to check percolation of solids in Z... ");
<         fflush(Logfile);
<       }
<       Sf3 = burnset(0, 0, 1); /* Burn across z */
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "Done!");
<         fflush(Logfile);
<       }
---
>         /* Total up phase counts */
876,877c845,854
<       Setflag = Sf1 * Sf2 * Sf3;
<     }
---
>         if (Cyccnt > 1) {
>             for (k = 0; k < NPHASES; k++) Count[k] = 0;
>             for (k = 0; k < Zsyssize; k++) {
>                 for (j = 0; j < Ysyssize; j++) {
>                     for (i = 0; i < Xsyssize; i++) {
>                         Count[(int)(Mic[i][j][k])]++;
>                     }
>                 }
>             }
>         }
879c856,861
<     /* Check hydration of particles */
---
>         if (Crackwidth > 0 && (Time_cur >= Cracktime)) {
>             
>             /***
>             *    Crack the microstructure and change the
>             *    effective system size
>             ***/
881,888c863,877
<     if (Time_cur >= NextPhydTime) {
<       NextPhydTime = Time_cur + Phydtimefreq;
<       if ((parthyd()) == MEMERR) {
<         freeallmem();
<         bailout("disrealnew", "Problem with parthyd");
<         exit(1);
<       }
<     }
---
>             if (Verbose) {
>                 printf("\nPreparing to place a crack in the microstructure.");
>                 printf("\n\tCrack width = %d",Crackwidth);
>                 printf("\n\tX size currently is %d",Xsyssize);
>                 printf("\n\tY size currently is %d",Ysyssize);
>                 printf("\n\tZ size currently is %d",Zsyssize);
>                 fflush(stdout);
>             }
>             addcrack();
>             if (Verbose) {
>                 printf("\n\tAfter cracking, X size is %d",Xsyssize);
>                 printf("\n\tAfter cracking, Y size is %d",Ysyssize);
>                 printf("\n\tAfter cracking, Z size is %d",Zsyssize);
>                 fflush(stdout);
>             }
890c879,891
<     /* Total up phase counts */
---
>             for (k = 0; k < NPHASES; k++) Count[k] = 0;
>             for (k = 0; k < Zsyssize; k++) {
>                 for (j = 0; j < Ysyssize; j++) {
>                     for (i = 0; i < Xsyssize; i++) {
>                         Count[(int)(Mic[i][j][k])]++;
>                     }
>                 }
>             }
>                     
>             /***
>             *    Must update anything that depends on system size, except
>             *    for those things that are updated once each cycle 
>             ***/
892,902c893,897
<     if (Cyccnt > 1) {
<       for (k = 0; k < NPHASES; k++)
<         Count[k] = 0;
<       for (i = 0; i < Xsyssize; i++) {
<         for (j = 0; j < Ysyssize; j++) {
<           for (k = 0; k < Zsyssize; k++) {
<             Count[(int)(Mic[i][j][k])]++;
<           }
<         }
<       }
<     }
---
>             Syspix = Xsyssize * Ysyssize * Zsyssize;
>             if (Verbose) printf("\n\tSyspix changes from %d to %d",Syspix_orig,Syspix);
>             Sizemag = ((float)Syspix)/(pow(((double)(DEFAULTSYSTEMSIZE)),3.0));
>             if (Verbose) printf("\n\tSizemag changes from %f to %f",Sizemag_orig,Sizemag);
>             Isizemag = (int)(Sizemag + 0.5);
904c899,905
<     if (Crackwidth > 0 && (Time_cur >= Cracktime)) {
---
>             Heat_cf *= ((double)Syspix) / ((double)Syspix_orig);
>             Cshscale *= Sizemag/Sizemag_orig;
>             C3ah6_scale *= Sizemag/Sizemag_orig;
>             pscalech *= Sizemag/Sizemag_orig;
>             pscalegyp *= Sizemag/Sizemag_orig;
>             pscalehg *= Sizemag/Sizemag_orig;
>             pscalefh3 *= Sizemag/Sizemag_orig;
906,909c907,920
<       /***
<        *    Crack the microstructure and change the
<        *    effective system size
<        ***/
---
>             /***
>             *    Last thing to do is to determine the curing
>             *    condition of the crack (saturated or sealed), which
>             *    we set to whatever the user wanted at the beginning
>             *    of the run
>             ***/
>             /***
>             *    Commented this block out on 2 July 2004 because
>             *    now we have CRACKP and POROSITY.  We originally
>             *    wanted to keep the  crack from drying out due to
>             *    sealed conditions, but only POROSITY pixels now can
>             *    be consumed under sealed conditions.
>             ***/
>             /*
911,925c922,928
<       if (Verbose_flag > 1) {
<         fprintf(Logfile, "\nPreparing to place a crack in the microstructure.");
<         fprintf(Logfile, "\n\tCrack width = %d", Crackwidth);
<         fprintf(Logfile, "\n\tX size currently is %d", Xsyssize);
<         fprintf(Logfile, "\n\tY size currently is %d", Ysyssize);
<         fprintf(Logfile, "\n\tZ size currently is %d", Zsyssize);
<         fflush(Logfile);
<       }
<       addcrack();
<       if (Verbose_flag > 1) {
<         fprintf(Logfile, "\n\tAfter cracking, X size is %d", Xsyssize);
<         fprintf(Logfile, "\n\tAfter cracking, Y size is %d", Ysyssize);
<         fprintf(Logfile, "\n\tAfter cracking, Z size is %d", Zsyssize);
<         fflush(Logfile);
<       }
---
>             if ((Sealed) && (!Sealed_after_crack)) {
>                 if (Verbose) printf("\nSwitching to saturated conditions after cracking.\n");
>             }
>             Sealed = Sealed_after_crack;
>             */
>                         
>             /* Make sure we don't do this block again */
927,933c930
<       for (k = 0; k < NPHASES; k++)
<         Count[k] = 0;
<       for (i = 0; i < Xsyssize; i++) {
<         for (j = 0; j < Ysyssize; j++) {
<           for (k = 0; k < Zsyssize; k++) {
<             Count[(int)(Mic[i][j][k])]++;
<           }
---
>             Cracktime = End_time + 100.0;
935d931
<       }
937,940c933,939
<       /***
<        *    Must update anything that depends on system size, except
<        *    for those things that are updated once each cycle
<        ***/
---
>         /***
>         *     As currently set up, crack porosity (CRACKP) can
>         *     diffuse into regular saturated porosity (POROSITY).
>         *     Every 5 cycles after a crack is added, we call the
>         *     function resetcrackpores to redistribute these pixels
>         *     back to the crack
>         ***/
942,950c941,945
<       Syspix = Xsyssize * Ysyssize * Zsyssize;
<       if (Verbose_flag > 1)
<         fprintf(Logfile, "\n\tSyspix changes from %d to %d", Syspix_orig,
<                 Syspix);
<       Sizemag = ((float)Syspix) / (pow(((double)(DEFAULTSYSTEMSIZE)), 3.0));
<       if (Verbose_flag > 1)
<         fprintf(Logfile, "\n\tSizemag changes from %f to %f", Sizemag_orig,
<                 Sizemag);
<       Isizemag = (int)(Sizemag + 0.5);
---
>         /*
>         if ((Icyc > Crackcycle) && (((Icyc - Crackcycle)%5) == 0)) {
>             resetcrackpores();
>         }
>         */
952,958c947
<       Heat_cf *= ((double)Syspix) / ((double)Syspix_orig);
<       Cshscale *= Sizemag / Sizemag_orig;
<       C3ah6_scale *= Sizemag / Sizemag_orig;
<       pscalech *= Sizemag / Sizemag_orig;
<       pscalegyp *= Sizemag / Sizemag_orig;
<       pscalehg *= Sizemag / Sizemag_orig;
<       pscalefh3 *= Sizemag / Sizemag_orig;
---
>         /* Output movie microstructure if one is desired */
960,973c949,965
<       /***
<        *    Last thing to do is to determine the curing
<        *    condition of the crack (saturated or sealed), which
<        *    we set to whatever the user wanted at the beginning
<        *    of the run
<        ***/
<       /***
<        *    Commented this block out on 2 July 2004 because
<        *    now we have CRACKP and POROSITY.  We originally
<        *    wanted to keep the  crack from drying out due to
<        *    sealed conditions, but only POROSITY pixels now can
<        *    be consumed under sealed conditions.
<        ***/
<       /*
---
>         fflush(stdout);
>         if ((MovieFrameFreq > 0.0) && (Time_cur >= NextMovieTime)) {
>             printf("\nMaking movie frame");
>             fflush(stdout);
>             NextMovieTime = Time_cur + MovieFrameFreq;
>             /* Check to see if movie file has been created already */
>             Movfile = filehandler("disrealnew",Moviename,"READ_NOFAIL");
>             if (!Movfile) {
>                 printf("\nMovie file not found.  Creating it now...");
>                 fflush(stdout);
>                 Movfile = filehandler("disrealnew",Moviename,"WRITE");
>                 if (!Movfile) {
>                     freeallmem();
>                     exit(1);
>                 }
>                 printf("Success.");
>                 fflush(stdout);
975,980c967,982
<       if ((Sealed) && (!Sealed_after_crack)) {
<           if (Verbose_flag > 1) fprintf(Logfile,"\nSwitching to saturated
<       conditions after cracking.\n");
<       }
<       Sealed = Sealed_after_crack;
<       */
---
>                 fprintf(Movfile,"%s ",VERSIONSTRING);
>                 fprintf(Movfile,"%s\n",VERSIONNUMBER);
>                 if (Crackorient == 1 || Crackorient == 2) {
>                     fprintf(Movfile,"%s ",XSIZESTRING);
>                     fprintf(Movfile,"%d\n",Xsyssize);
>                     fprintf(Movfile,"%s ",YSIZESTRING);
>                     fprintf(Movfile,"%d\n",Ysyssize);
>                 }
>                 if (Crackorient == 3) {
>                     fprintf(Movfile,"%s ",XSIZESTRING);
>                     fprintf(Movfile,"%d\n",Xsyssize);
>                     fprintf(Movfile,"%s ",YSIZESTRING);
>                     fprintf(Movfile,"%d\n",Zsyssize);
>                 }
>                 fprintf(Movfile,"%s ",IMGRESSTRING);
>                 fprintf(Movfile,"%4.2f\n",Res);
982c984,993
<       /* Make sure we don't do this block again */
---
>             } else {
>                 printf("\nMovie file exists.  Appending to it...");
>                 fflush(stdout);
>                 fclose(Movfile);
>                 Movfile = filehandler("disrealnew",Moviename,"APPEND");
>                 if (!Movfile) {
>                     freeallmem();
>                     exit(1);
>                 }
>             }
984,985c995,998
<       Cracktime = End_time + 100.0;
<     }
---
>             /***
>             *    Currently can only make a hydration movie for
>             *    slice 50.  Make this user-defined later on
>             ***/
987,993c1000,1012
<     /***
<      *     As currently set up, crack porosity (CRACKP) can
<      *     diffuse into regular saturated porosity (POROSITY).
<      *     Every 5 cycles after a crack is added, we call the
<      *     function resetcrackpores to redistribute these pixels
<      *     back to the crack
<      ***/
---
>             if (Crackorient == 1 || Crackorient == 2) {
>                 for (iy = 0; iy < Ysyssize; iy++) {
>                     for (ix = 0; ix < Xsyssize; ix++) {
>                         fprintf(Movfile,"%d\n",(int)Mic[ix][iy][50]);
>                     }
>                 }
>             } else {
>                 for (iz = 0; iz < Zsyssize; iz++) {
>                     for (ix = 0; ix < Xsyssize; ix++) {
>                         fprintf(Movfile,"%d\n",(int)Mic[ix][50][iz]);
>                     }
>                 }
>             }
995,999c1014,1016
<     /*
<     if ((Icyc > Crackcycle) && (((Icyc - Crackcycle)%5) == 0)) {
<         resetcrackpores();
<     }
<     */
---
>             fclose(Movfile);
>             printf("\nMade movie frame successfully and closed movie file");
>             fflush(stdout);
1001,1015d1017
<     /* Output movie microstructure if one is desired */
< 
<     fflush(Logfile);
<     if ((MovieFrameFreq > 0.0) && (Time_cur >= NextMovieTime)) {
<       if (Verbose_flag > 1) {
<         fprintf(Logfile, "\nMaking movie frame");
<         fflush(Logfile);
<       }
<       NextMovieTime = Time_cur + MovieFrameFreq;
<       /* Check to see if movie file has been created already */
<       Movfile = filehandler("disrealnew", Moviename, "READ_NOFAIL");
<       if (!Movfile) {
<         if (Verbose_flag > 1) {
<           fprintf(Logfile, "\nMovie file not found.  Creating it now...");
<           fflush(Logfile);
1017,1026d1018
<         Movfile = filehandler("disrealnew", Moviename, "WRITE");
<         if (!Movfile) {
<           bailout("disrealnew", "Could not create movie file");
<           freeallmem();
<           exit(1);
<         }
<         if (Verbose_flag > 1) {
<           fprintf(Logfile, " Success.");
<           fflush(Logfile);
<         }
1028,1043c1020,1023
<         fprintf(Movfile, "%s ", VERSIONSTRING);
<         fprintf(Movfile, "%s", VERSIONNUMBER);
<         if (Crackorient == 1 || Crackorient == 2) {
<           fprintf(Movfile, "\n%s ", XSIZESTRING);
<           fprintf(Movfile, "%d", Xsyssize);
<           fprintf(Movfile, "\n%s ", YSIZESTRING);
<           fprintf(Movfile, "%d", Ysyssize);
<         }
<         if (Crackorient == 3) {
<           fprintf(Movfile, "\n%s ", XSIZESTRING);
<           fprintf(Movfile, "%d", Xsyssize);
<           fprintf(Movfile, "\n%s ", YSIZESTRING);
<           fprintf(Movfile, "%d", Zsyssize);
<         }
<         fprintf(Movfile, "\n%s ", IMGRESSTRING);
<         fprintf(Movfile, "%4.2f", Res);
---
>         /***
>         *    Output complete 3D microstructure once for every entry
>         *    in the outputalpha.dat file
>         ***/
1045,1054c1025,1026
<       } else {
<         fprintf(Logfile, "\nMovie file exists.  Appending to it...");
<         fflush(Logfile);
<         fclose(Movfile);
<         Movfile = filehandler("disrealnew", Moviename, "APPEND");
<         if (!Movfile) {
<           freeallmem();
<           exit(1);
<         }
<       }
---
>         if (((CustomImageTime != NULL) && (Time_cur >= CustomImageTime[customentry]))
>                 || ((Alpha_cur > 0.0) && (Time_cur >= NextImageTime))) {
1056,1059c1028,1029
<       /***
<        *    Currently can only make a hydration movie for
<        *    slice 50.  Make this user-defined later on
<        ***/
---
>             if (Verbose) printf("Writing microstructure image");
>             customentry++;
1061,1073c1031,1037
<       if (Crackorient == 1 || Crackorient == 2) {
<         for (iy = 0; iy < Ysyssize; iy++) {
<           for (ix = 0; ix < Xsyssize; ix++) {
<             fprintf(Movfile, "\n%d", (int)Mic[ix][iy][50]);
<           }
<         }
<       } else {
<         for (iz = 0; iz < Zsyssize; iz++) {
<           for (ix = 0; ix < Xsyssize; ix++) {
<             fprintf(Movfile, "\n%d", (int)Mic[ix][50][iz]);
<           }
<         }
<       }
---
>             NextImageTime = Time_cur + OutTimefreq;
>             sprintf(strsuffa,"%.2fh.%d.%1d",Time_cur,(int)Temp_0,Csh2flag);
>             sprintf(strsuffb,"%1d%1d",Adiaflag,Sealed);
>             strcpy(strsuff,strsuffa);
>             strcat(strsuff,strsuffb);
>             sprintf(Micname,"%s%s.img.",Outputdir,Fileroot);
>             strcat(Micname,strsuff);
1075,1081c1039,1045
<       fclose(Movfile);
<       if (Verbose_flag > 1) {
<         fprintf(Logfile,
<                 "\nMade movie frame successfully and closed movie file");
<         fflush(Logfile);
<       }
<     }
---
>             Micfile = filehandler("disrealnew",Micname,"WRITE");
>             if (!Micfile) {
>                 sprintf(buff,"Could not open file %s",Micname);
>                 bailout("disrealnew",buff);
>                 freeallmem();
>                 exit(1);
>             }
1083,1086c1047,1055
<     /***
<      *    Output complete 3D microstructure once for every entry
<      *    in the outputalpha.dat file
<      ***/
---
>             Imageindexfile = filehandler("disrealnew",Imageindexname,"APPEND");
>             if (!Imageindexfile) {
>                 sprintf(buff,"Could not open file %s",Imageindexname);
>                 bailout("disrealnew",buff);
>                 freeallmem();
>                 exit(1);
>             }
>             fprintf(Imageindexfile,"%f\t%s\n",Time_cur,Micname);
>             fclose(Imageindexfile);
1088,1090c1057,1062
<     if (((CustomImageTime != NULL) &&
<          (Time_cur >= CustomImageTime[customentry])) ||
<         ((Alpha_cur > 0.0) && (Time_cur >= NextImageTime))) {
---
>             if (write_imgheader(Micfile,Xsyssize,Ysyssize,Zsyssize,Res)) {
>                 fclose(Micfile);
>                 freeallmem();
>                 bailout("disrealnew","Error writing image header");
>                 exit(1);
>             }
1092,1094c1064,1066
<       if (Verbose_flag > 1)
<         fprintf(Logfile, "\nWriting microstructure image");
<       customentry++;
---
>             for (iz = 0; iz < Zsyssize; iz++) {
>                 for (iy = 0; iy < Ysyssize; iy++) {
>                     for (ix = 0; ix < Xsyssize; ix++) {
1096,1110c1068,1107
<       NextImageTime = Time_cur + OutTimefreq;
<       sprintf(strsuffa, "%.2fh.%d.%1d", Time_cur, (int)Temp_0, Csh2flag);
<       sprintf(strsuffb, "%1d%1d", Adiaflag, Sealed);
<       strcpy(strsuff, strsuffa);
<       strcat(strsuff, strsuffb);
<       sprintf(Micname, "%s%s.img.", WorkingDirectory, Fileroot);
<       strcat(Micname, strsuff);
< 
<       Micfile = filehandler("disrealnew", Micname, "WRITE");
<       if (!Micfile) {
<         sprintf(buff, "Could not open file %s", Micname);
<         bailout("disrealnew", buff);
<         freeallmem();
<         exit(1);
<       }
---
>                         pixtmp = (int)Mic[ix][iy][iz];
>                         
>                         switch (pixtmp) {
>                             case DIFFCSH:
>                                 /* pixtmp = CSH; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFANH:
>                                 /* pixtmp = ANHYDRITE; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFHEM:
>                                 /* pixtmp = HEMIHYD; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFGYP:
>                                 /* pixtmp = GYPSUM; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFCACL2:
>                                 /* pixtmp = CACL2; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFCACO3:
>                                 /* pixtmp = CACO3; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFCAS2:
>                                 /* pixtmp = CAS2; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFAS:
>                                 /* pixtmp = ASG; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFETTR:
>                                 /* pixtmp = ETTR; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFC3A:
1112,1115c1109,1209
<       Imageindexfile = filehandler("disrealnew", Imageindexname, "APPEND");
<       if (!Imageindexfile) {
<         sprintf(buff, "Could not open file %s", Imageindexname);
<         bailout("disrealnew", buff);
---
>                                 /***
>                                 *    Any precipitation of diffusing C3A
>                                 *    is assumed to form cubic C3A instead
>                                 *    of orthorhombic C3A
>                                 ***/
> 
>                                 /* pixtmp = C3A; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFC4A:
> 
>                                 /***
>                                 *    Any diffusing C4AF has already
>                                 *    converted to FH3 and CH, so you can
>                                 *    not really represent it as C4AF anymore.
>                                 *    Best you can do is represent it as
>                                 *    C3A
>                                 ***/
> 
>                                 /* pixtmp = C3A; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFFH3:
>                                 /* pixtmp = FH3; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             case DIFFCH:
>                                 /* pixtmp = CH; */
>                                 pixtmp = POROSITY;
>                                 break;
>                             default:
>                                 break;
>                         }
> 
>                         fprintf(Micfile,"%d\n",pixtmp);
> 
>                     }    /* End of loop in z */
>                 }        /* End of loop in y */
>             }            /* End of loop in x */
> 
>             fclose(Micfile);
> 
>             /* With microstructure now written, calculate pore size distribution */
>             printf("\nCalculating pore size distribution now...");
>             if (calcporedist3d(Micname)) {
>                 printf("\nThere was a problem calculating the pore size distribution.\n");
>             }
>             printf("Done calculating pore size distribution.\n");
>         }
> 
>         /* Attempt to open master data file */
> 
>         Datafile = filehandler("disrealnew",Datafilename,"APPEND");
>         if (!Datafile) {
>             freeallmem();
>             exit(1);
>         }
>         fprintf(Datafile,"%d,%.4f,%.4f,%.4f,",Cyccnt-1,Time_cur,Alpha_cur,Alpha_fa_cur);
>         fprintf(Datafile,"%.4f,%.4f,%.4f,",(Heat_new * Heat_cf),Temp_cur_b,Gsratio2);
>         fprintf(Datafile,"%.4f,%.4f,%.5f,%.4f,",Wn_o,Wn_i,Chs_new,PH_cur);
>         fprintf(Datafile,"%.4f,%.4f,%.4f,%.4f,",Conductivity,Concnaplus,Conckplus,Conccaplus);
>         fprintf(Datafile,"%.4f,%.4f,%.4f,%.4f,",Concsulfate,ActivityK,ActivityCa,ActivityOH);
>         fprintf(Datafile,"%.4f,%.4f,",ActivitySO4,((float)Count[POROSITY]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,%.4f,",Con_fracp[0],Con_fracp[1],Con_fracp[2]);
>         fprintf(Datafile,"%.4f,",(Con_fracp[0]+Con_fracp[1]+Con_fracp[2])/3.0);
>         fprintf(Datafile,"%.4f,%.4f,%.4f,",Con_fracs[0],Con_fracs[1],Con_fracs[2]);
>         fprintf(Datafile,"%.4f,",(Con_fracs[0]+Con_fracs[1]+Con_fracs[2])/3.0);
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[C3S]/(float)Syspix),((float)Count[C2S]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[C3A]/(float)Syspix),((float)Count[OC3A]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[C4AF]/(float)Syspix),((float)Count[K2SO4]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[NA2SO4]/(float)Syspix),((float)Count[GYPSUM]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[HEMIHYD]/(float)Syspix),((float)Count[ANHYDRITE]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[CACO3]/(float)Syspix),((float)Count[FREELIME]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[SFUME]/(float)Syspix),((float)Count[INERT]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[SLAG]/(float)Syspix),((float)Count[ASG]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[CAS2]/(float)Syspix),((float)Count[AMSIL]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[CH]/(float)Syspix),((float)Count[CSH]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[POZZCSH]/(float)Syspix),((float)Count[SLAGCSH]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[C3AH6]/(float)Syspix),((float)(Count[ETTR]+Count[ETTRC4AF])/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[AFM]/(float)Syspix),((float)Count[FH3]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[CACL2]/(float)Syspix),((float)Count[FRIEDEL]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[STRAT]/(float)Syspix),((float)Count[GYPSUMS]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f,",((float)Count[ABSGYP]/(float)Syspix),((float)Count[AFMC]/(float)Syspix));
>         fprintf(Datafile,"%.4f,%.4f\n",((float)Count[INERTAGG]/(float)Syspix),((float)Count[EMPTYP]/(float)Syspix));
>         fclose(Datafile);
> 
>     }    /*    End of loop over all hydration cycles */
> 
>     /***
>     *    Hydration cycles are finished.  Clean up from here.
>     ***/
> 
>     /* Last call to dissolve to terminate hydration */
> 
>     valin = 0;
>     dissolve(valin);
> 
>     /* Output final microstructure */
> 
>     outfile = filehandler("disrealnew",Fileoname,"WRITE");
>     if (!outfile) {
1118,1120c1212
<       }
<       fprintf(Imageindexfile, "\n%f\t%s", Time_cur, Micname);
<       fclose(Imageindexfile);
---
>     }
1122,1123c1214,1217
<       if (write_imgheader(Micfile, Xsyssize, Ysyssize, Zsyssize, Res)) {
<         fclose(Micfile);
---
>     Imageindexfile = filehandler("disrealnew",Imageindexname,"APPEND");
>     if (!Imageindexfile) {
>         sprintf(buff,"Could not open file %s",Imageindexname);
>         bailout("disrealnew",buff);
1125d1218
<         bailout("disrealnew", "Error writing image header");
1127c1220,1222
<       }
---
>     }
>     fprintf(Imageindexfile,"%f\t%s\n",Time_cur,Fileoname);
>     fclose(Imageindexfile);
1129,1136c1224,1229
<       /**
<        * 2025 August 05
<        * New convention is to read and write image data in C-order (z
<        * varies the fastest, then y, then x)
<        **/
<       for (ix = 0; ix < Xsyssize; ix++) {
<         for (iy = 0; iy < Ysyssize; iy++) {
<           for (iz = 0; iz < Zsyssize; iz++) {
---
>     if (write_imgheader(outfile,Xsyssize,Ysyssize,Zsyssize,Res)) {
>         fclose(outfile);
>         freeallmem();
>         bailout("disrealnew","Error writing image header");
>         exit(1);
>     }
1138c1231,1238
<             pixtmp = (int)Mic[ix][iy][iz];
---
>     for (iz = 0; iz < Zsyssize; iz++) {
>         for(iy = 0; iy < Ysyssize; iy++) {
>             for (ix = 0; ix < Xsyssize; ix++) {
>                 fprintf(outfile,"%d\n",(int)Mic[ix][iy][iz]);
>             }
>         }
>     }
>     fclose(outfile);
1140,1177c1240,1242
<             switch (pixtmp) {
<             case DIFFCSH:
<               /* pixtmp = CSH; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFANH:
<               /* pixtmp = ANHYDRITE; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFHEM:
<               /* pixtmp = HEMIHYD; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFGYP:
<               /* pixtmp = GYPSUM; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFCACL2:
<               /* pixtmp = CACL2; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFCACO3:
<               /* pixtmp = CACO3; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFCAS2:
<               /* pixtmp = CAS2; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFAS:
<               /* pixtmp = ASG; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFETTR:
<               /* pixtmp = ETTR; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFC3A:
---
>     if (calcporedist3d(Fileoname)) {
>         printf("\nThere was a problem calculating the pore size distribution.\n");
>     }
1179,1183c1244,1249
<               /***
<                *    Any precipitation of diffusing C3A
<                *    is assumed to form cubic C3A instead
<                *    of orthorhombic C3A
<                ***/
---
>     /***
>     *    Check percolation of pore space
>     *    Note that first two variables passed correspond to
>     *    combined phases to check.  Could easily add calls
>     *    to check for percolation of CH, CSH, etc.
>     ***/
1185,1188c1251,1253
<               /* pixtmp = C3A; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFC4A:
---
>     if ((Burntimefreq > 0.0)
>         && (Burntimefreq <= End_time)
>         && ((Porefl1 + Porefl2 + Porefl3) != 0)) {
1190,1196c1255,1278
<               /***
<                *    Any diffusing C4AF has already
<                *    converted to FH3 and CH, so you can
<                *    not really represent it as C4AF anymore.
<                *    Best you can do is represent it as
<                *    C3A
<                ***/
---
>         /* Burn across x */
>         Porefl1 = burn3d(((int)POROSITY),((int)CRACKP),1,0,0);
>         if (Porefl1 == MEMERR) {
>             freeallmem();
>             bailout("disrealnew","Problem in burn3d");
>             exit(1);
>         }
>         /* Burn across y */
>         Porefl2 = burn3d(((int)POROSITY),((int)CRACKP),0,1,0);
>         if (Porefl2 == MEMERR) {
>             freeallmem();
>             bailout("disrealnew","Problem in burn3d");
>             exit(1);
>         }
>         /* Burn across z */
>         Porefl3 = burn3d(((int)POROSITY),((int)CRACKP),0,0,1);
>         if (Porefl3 == MEMERR) {
>             freeallmem();
>             bailout("disrealnew","Problem in burn3d");
>             exit(1);
>         }
>     }
> 
>     /* Check percolation of solids (set point) */
1198,1211c1280
<               /* pixtmp = C3A; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFFH3:
<               /* pixtmp = FH3; */
<               pixtmp = POROSITY;
<               break;
<             case DIFFCH:
<               /* pixtmp = CH; */
<               pixtmp = POROSITY;
<               break;
<             default:
<               break;
<             }
---
>     if ((Settimefreq > 0.0) && (Settimefreq <= End_time) && (!Setflag)) {
1213c1282,1284
<             fprintf(Micfile, "\n%d", pixtmp);
---
>         Sf1 = burnset(1,0,0); /* Burn across x */
>         Sf2 = burnset(0,1,0); /* Burn across y */
>         Sf3 = burnset(0,0,1); /* Burn across z */
1215,1217c1286,1289
<           } /* End of loop in z */
<         } /* End of loop in y */
<       } /* End of loop in x */
---
>         Setflag = Sf1 * Sf2 * Sf3;
>         if (Verbose) printf("\nSetflag = %d",Setflag);
>     }
>     
1219c1291,1295
<       fclose(Micfile);
---
>     /* Output last lines of heat and chemical shrinkage files */
> 
>     if (Cyccnt > 1) {
>         Time_step = ((2.0 * ((float)Cyccnt)) - 1.0) * Beta / Krate;
>         Time_cur += Time_step;
1222,1224c1298,1321
<     /* With microstructure now written, calculate pore size distribution */
<     if (Verbose_flag > 2) {
<       fprintf(Logfile, "\nCalculating pore size distribution now...");
---
>     /* Initialize and calculate gel-space ratio */
> 
>     Gsratio2 = 0.0;
>     Gsratio2 += (double)(Count[CH] + Count[CSH]);
>     Gsratio2 += (double)(Count[C3AH6] + Count[ETTR]);
>     Gsratio2 += (double)(Count[POZZCSH] + Count[SLAGCSH]);
>     Gsratio2 += (double)(Count[FH3] + Count[AFM] + Count[ETTRC4AF]);
>     Gsratio2 += (double)(Count[FRIEDEL] + Count[STRAT]);
>     Gsratio2 += (double)(Count[ABSGYP] + Count[AFMC]);
> 
>     space = (double)(Count[POROSITY] + Count[CRACKP] + Count[EMPTYP]);
>     Gsratio2 = (Gsratio2) / (Gsratio2 + space);
> 
>     gfloat = (double)((0.68 * Alpha_cur) / (0.32 * Alpha_cur + W_to_c));
>     gfloat = (double)(Count[EMPTYP] + Count[POROSITY] + Count[CRACKP] - Water_left);
>     gfloat *= (Heat_cf / 1000.0);
> 
>     Cyccnt++;
> 
>     /* Final call to pHpred */
> 
>     if (Verbose) {
>         printf("\nMaking final call to pHpred...");
>         fflush(stdout);
1226,1234c1323
<     if (calcporedist3d(Micname)) {
<       if (Verbose_flag > 1) {
<         fprintf(Logfile, "\nWARNING: There was a problem calculating the "
<                          "pore size distribution.");
<       }
<       if (Verbose_flag > 2) {
<         fprintf(Logfile, "\nDone calculating pore size distribution.");
<       }
<     }
---
>     pHpred();
1238c1327
<     Datafile = filehandler("disrealnew", Datafilename, "APPEND");
---
>     Datafile = filehandler("disrealnew",Datafilename,"APPEND");
1240,1241c1329,1330
<       freeallmem();
<       exit(1);
---
>         freeallmem();
>         exit(1);
1243,1295c1332,1358
<     fprintf(Datafile, "\n%d,%.4f,%.4f,%.4f,", Cyccnt - 1, Time_cur, Alpha_cur,
<             Alpha_fa_cur);
<     fprintf(Datafile, "%.4f,%.4f,%.4f,", (Heat_new * Heat_cf), Temp_cur_b,
<             Gsratio2);
<     fprintf(Datafile, "%.4f,%.4f,%.5f,%.4f,", Wn_o, Wn_i, Chs_new, PH_cur);
<     fprintf(Datafile, "%.4f,%.4f,%.4f,%.4f,", Conductivity, Concnaplus,
<             Conckplus, Conccaplus);
<     fprintf(Datafile, "%.4f,%.4f,%.4f,%.4f,", Concsulfate, ActivityK,
<             ActivityCa, ActivityOH);
<     fprintf(Datafile, "%.4f,%.4f,", ActivitySO4,
<             ((float)Count[POROSITY] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,%.4f,", Con_fracp[0], Con_fracp[1],
<             Con_fracp[2]);
<     fprintf(Datafile, "%.4f,",
<             (Con_fracp[0] + Con_fracp[1] + Con_fracp[2]) / 3.0);
<     fprintf(Datafile, "%.4f,%.4f,%.4f,", Con_fracs[0], Con_fracs[1],
<             Con_fracs[2]);
<     fprintf(Datafile, "%.4f,",
<             (Con_fracs[0] + Con_fracs[1] + Con_fracs[2]) / 3.0);
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[C3S] / (float)Syspix),
<             ((float)Count[C2S] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[C3A] / (float)Syspix),
<             ((float)Count[OC3A] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[C4AF] / (float)Syspix),
<             ((float)Count[K2SO4] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[NA2SO4] / (float)Syspix),
<             ((float)Count[GYPSUM] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[HEMIHYD] / (float)Syspix),
<             ((float)Count[ANHYDRITE] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[CACO3] / (float)Syspix),
<             ((float)Count[FREELIME] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[SFUME] / (float)Syspix),
<             ((float)Count[INERT] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[SLAG] / (float)Syspix),
<             ((float)Count[ASG] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[CAS2] / (float)Syspix),
<             ((float)Count[AMSIL] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[CH] / (float)Syspix),
<             ((float)Count[CSH] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[POZZCSH] / (float)Syspix),
<             ((float)Count[SLAGCSH] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[C3AH6] / (float)Syspix),
<             ((float)(Count[ETTR] + Count[ETTRC4AF]) / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[AFM] / (float)Syspix),
<             ((float)Count[FH3] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[CACL2] / (float)Syspix),
<             ((float)Count[FRIEDEL] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[STRAT] / (float)Syspix),
<             ((float)Count[GYPSUMS] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f,", ((float)Count[ABSGYP] / (float)Syspix),
<             ((float)Count[AFMC] / (float)Syspix));
<     fprintf(Datafile, "%.4f,%.4f", ((float)Count[INERTAGG] / (float)Syspix),
<             ((float)Count[EMPTYP] / (float)Syspix));
---
>     fprintf(Datafile,"%d,%.4f,%.4f,%.4f,",Cyccnt-1,Time_cur,Alpha_cur,Alpha_fa_cur);
>     fprintf(Datafile,"%.4f,%.4f,%.4f,",(Heat_new * Heat_cf),Temp_cur_b,Gsratio2);
>     fprintf(Datafile,"%.4f,%.4f,%.5f,%.4f,",Wn_o,Wn_i,Chs_new,PH_cur);
>     fprintf(Datafile,"%.4f,%.4f,%.4f,%.4f,",Conductivity,Concnaplus,Conckplus,Conccaplus);
>     fprintf(Datafile,"%.4f,%.4f,%.4f,%.4f,",Concsulfate,ActivityK,ActivityCa,ActivityOH);
>     fprintf(Datafile,"%.4f,%.4f,",ActivitySO4,((float)Count[POROSITY]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,%.4f,",Con_fracp[0],Con_fracp[1],Con_fracp[2]);
>     fprintf(Datafile,"%.4f,",(Con_fracp[0]+Con_fracp[1]+Con_fracp[2])/3.0);
>     fprintf(Datafile,"%.4f,%.4f,%.4f,",Con_fracs[0],Con_fracs[1],Con_fracs[2]);
>     fprintf(Datafile,"%.4f,",(Con_fracs[0]+Con_fracs[1]+Con_fracs[2])/3.0);
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[C3S]/(float)Syspix),((float)Count[C2S]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[C3A]/(float)Syspix),((float)Count[OC3A]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[C4AF]/(float)Syspix),((float)Count[K2SO4]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[NA2SO4]/(float)Syspix),((float)Count[GYPSUM]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[HEMIHYD]/(float)Syspix),((float)Count[ANHYDRITE]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[CACO3]/(float)Syspix),((float)Count[FREELIME]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[SFUME]/(float)Syspix),((float)Count[INERT]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[SLAG]/(float)Syspix),((float)Count[ASG]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[CAS2]/(float)Syspix),((float)Count[AMSIL]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[CH]/(float)Syspix),((float)Count[CSH]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[POZZCSH]/(float)Syspix),((float)Count[SLAGCSH]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[C3AH6]/(float)Syspix),((float)(Count[ETTR]+Count[ETTRC4AF])/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[AFM]/(float)Syspix),((float)Count[FH3]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[CACL2]/(float)Syspix),((float)Count[FRIEDEL]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[STRAT]/(float)Syspix),((float)Count[GYPSUMS]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f,",((float)Count[ABSGYP]/(float)Syspix),((float)Count[AFMC]/(float)Syspix));
>     fprintf(Datafile,"%.4f,%.4f\n",((float)Count[INERTAGG]/(float)Syspix),((float)Count[EMPTYP]/(float)Syspix));
1298,1301c1361,1364
<     /* Always create a JSON with progress every ten cycles */
<     if (Icyc % 10 == 0) {
<       Datafile = filehandler("disrealnew", ProgressFileName, "WRITE");
<       if (!Datafile) {
---
>     /* Attempt to open time history file */
> 
>     Datafile = filehandler("disrealnew","TimeHistory.dat","WRITE");
>     if (!Datafile) {
1304,1317d1366
<       }
<       fprintf(Datafile, "json {");
<       fprintf(Datafile, "\"cycle\": %d, \"time_hours\": %.2f,", Icyc, Time_cur);
<       fprintf(Datafile,
<               " \"degree_of_hydration\": %.2f, \"timestamp\": ", Alpha_cur);
< 
<       if ((clock_gettime(CLOCK_REALTIME, &tv))) {
<         fprintf(stderr, "\nERROR: Error clock_gettime");
<       }
< 
<       rfc8601 = rfc8601_timespec(&tv);
<       fprintf(Datafile, "\"%s\"}", rfc8601);
<       fclose(Datafile);
<       free(rfc8601);
1319,1324c1368,1369
< 
<     /* Print progress data to stderr if not in quiet or silent mode */
<     if (Verbose_flag > 1) {
<       fprintf(stderr, "\nPROGRESS: Cycle=%d/%d Time=%f DOH=%f Temp=%f pH=%f",
<               Icyc, Ncyc, Time_cur, Alpha_cur, Temp_cur_b, PH_cur);
<       fflush(stderr);
---
>     for (i = 0; i < Cyccnt; i++) {
>         fprintf(Datafile,"%d %f\n",i,TimeHistory[i]);
1326,1341c1371,1372
< 
<   } /*    End of loop over all hydration cycles */
< 
<   /***
<    *    Hydration cycles are finished.  Clean up from here.
<    ***/
< 
<   /* Last call to dissolve to terminate hydration */
< 
<   valin = 0;
<   dissolve(valin);
< 
<   /* Output final microstructure */
< 
<   outfile = filehandler("disrealnew", Fileoname, "WRITE");
<   if (!outfile) {
---
>     fclose(Datafile);
>     
1343,1344c1374,1375
<     exit(1);
<   }
---
>     return(0);
> }
1346,1354c1377,1390
<   Imageindexfile = filehandler("disrealnew", Imageindexname, "APPEND");
<   if (!Imageindexfile) {
<     sprintf(buff, "Could not open file %s", Imageindexname);
<     bailout("disrealnew", buff);
<     freeallmem();
<     exit(1);
<   }
<   fprintf(Imageindexfile, "\n%f\t%s", Time_cur, Fileoname);
<   fclose(Imageindexfile);
---
> /***
> *    checkargs
> *
> *     Check command-line arguments used to invoke disrealnew
> *
> *     Arguments:    int argc, char *argv[]
> *     Returns:    nothing
> *
> *    Calls:        no routines
> *    Called by:    main program
> ***/
> void checkargs(int argc, char *argv[])
> {
>     register unsigned int i;
1356,1361c1392
<   if (write_imgheader(outfile, Xsyssize, Ysyssize, Zsyssize, Res)) {
<     fclose(outfile);
<     freeallmem();
<     bailout("disrealnew", "Error writing image header");
<     exit(1);
<   }
---
>     /* Is verbose output requested? */
1363,1367c1394,1396
<   for (ix = 0; ix < Xsyssize; ix++) {
<     for (iy = 0; iy < Ysyssize; iy++) {
<       for (iz = 0; iz < Zsyssize; iz++) {
<         fprintf(outfile, "\n%d", (int)Mic[ix][iy][iz]);
<       }
---
>     Verbose = 0;
>     for (i = 1; i < argc; i++) {
>         if ((!strcmp(argv[i],"-v")) || (!strcmp(argv[i],"--verbose"))) Verbose = 1;
1369,1370c1398
<   }
<   fclose(outfile);
---
> }
1372,1387c1400,1427
<   if (calcporedist3d(Fileoname)) {
<     if (Verbose_flag > 1) {
<       fprintf(Logfile,
<               "\nThere was a problem calculating the pore size distribution.");
<     }
<   }
< 
<   /***
<    *    Check percolation of pore space
<    *    Note that first two variables passed correspond to
<    *    combined phases to check.  Could easily add calls
<    *    to check for percolation of CH, CSH, etc.
<    ***/
< 
<   if ((Burntimefreq > 0.0) && (Burntimefreq <= End_time) &&
<       ((Porefl1 + Porefl2 + Porefl3) != 0)) {
---
> /***
> *    get_input
> *
> *     Gather input data and parameters for running simulation
> *
> *     Arguments:    none
> *     Returns:    0 if okay, nonzero otherwise
> *
> *    Calls:        no routines
> *    Called by:    main program
> ***/
> int get_input(float *pnucch, float *pscalech, float *pnuchg,
>                 float *pscalehg, float *pnucfh3, float *pscalefh3,
>                 float *pnucgyp, float *pscalegyp, int *nmovstep)
> {
>     int i,j,k,status = 0;
>     int onepixfloc = 0;
>     int nlen,phtodo,valin,ovalin,dphase,deactphase;
>     int ix,iy,iz,x,y;
>     int newx,newy,newz;
>     int nadd;
>     char ch,imgfile[MAXSTRING],pimgfile[MAXSTRING];
>     char buff[MAXSTRING],prmname[MAXSTRING],custcycfile[MAXSTRING];
>     char name[MAXSTRING],answer[MAXSTRING],calfilename[MAXSTRING];
>     char buff1[MAXSTRING],buff2[MAXSTRING],instring[MAXSTRING];
>     float dfrac,dends,dterm,bias,pc3a,b_estimate;
>     float newver,newres;
>     FILE *fimgfile,*fpimgfile,*fprmfile,*fcofile,*fcalfile;
1389,1394c1429,1438
<     /* Burn across x */
<     Porefl1 = burn3d(((int)POROSITY), ((int)CRACKP), 1, 0, 0);
<     if (Porefl1 == MEMERR) {
<       freeallmem();
<       bailout("disrealnew", "Problem in burn3d");
<       exit(1);
---
>     /***
>     *    Allocate memory for dissolution probability arrays
>     *    and some other variables that are phase-specific.
>     ***/
> 
>     if (Verbose) printf("\tAllocating Disprob ...");
>     Disprob = fvector(NSPHASES + 1);
>     if (!Disprob) {
>         bailout("disrealnew","Could not allocate memory for Disprob");
>         return(1);
1396,1401c1440,1444
<     /* Burn across y */
<     Porefl2 = burn3d(((int)POROSITY), ((int)CRACKP), 0, 1, 0);
<     if (Porefl2 == MEMERR) {
<       freeallmem();
<       bailout("disrealnew", "Problem in burn3d");
<       exit(1);
---
>     if (Verbose) printf(" done\n\tAllocating Disbase ...");
>     Disbase = fvector(NSPHASES + 1);
>     if (!Disbase) {
>         bailout("disrealnew","Could not allocate memory for Disbase");
>         return(1);
1403,1408c1446,1450
<     /* Burn across z */
<     Porefl3 = burn3d(((int)POROSITY), ((int)CRACKP), 0, 0, 1);
<     if (Porefl3 == MEMERR) {
<       freeallmem();
<       bailout("disrealnew", "Problem in burn3d");
<       exit(1);
---
>     if (Verbose) printf(" done\n\tAllocating Discoeff ...");
>     Discoeff = fvector(NSPHASES + 1);
>     if (!Discoeff) {
>         bailout("disrealnew","Could not allocate memory for Discoeff");
>         return(1);
1410c1452,1469
<   }
---
>     if (Verbose) printf(" done\n\tAllocating Soluble ...");
>     Soluble = ivector(NSPHASES + 1);
>     if (!Soluble) {
>         bailout("disrealnew","Could not allocate memory for Soluble");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Creates ...");
>     Creates = ivector(NSPHASES + 1);
>     if (!Creates) {
>         bailout("disrealnew","Could not allocate memory for Creates");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Onepixelbias ...");
>     Onepixelbias = fvector(NSPHASES + 1);
>     if (!Onepixelbias) {
>         bailout("disrealnew","Could not allocate memory for Onepixelbias");
>         return(1);
>     }
1412c1471,1474
<   /* Check percolation of solids (set point) */
---
>     /***
>     *    Allocate memory for the activation/deactivation start
>     *    and stop flags for each phase in the system.
>     ***/
1414c1476,1523
<   if ((Settimefreq > 0.0) && (Settimefreq <= End_time) && (!Setflag)) {
---
>     if (Verbose) printf("  done\n\tAllocating Startflag ...");
>     Startflag = ivector(NSPHASES + 1);
>     if (!Startflag) {
>         bailout("disrealnew","Could not allocate memory for Startflag");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Stopflag ...");
>     Stopflag = ivector(NSPHASES + 1);
>     if (!Stopflag) {
>         bailout("disrealnew","Could not allocate memory for Stopflag");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Deactphaselist ...");
>     Deactphaselist = ivector(NSPHASES + 1);
>     if (!Deactphaselist) {
>         bailout("disrealnew","Could not allocate memory for Deactphaselist");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Deactfrac ...");
>     Deactfrac = fvector(NSPHASES + 1);
>     if (!Deactfrac) {
>         bailout("disrealnew","Could not allocate memory for Deactfrac");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Reactfrac ...");
>     Reactfrac = fvector(NSPHASES + 1);
>     if (!Reactfrac) {
>         bailout("disrealnew","Could not allocate memory for Reactfrac");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Deactinit ...");
>     Deactinit = fvector(NSPHASES + 1);
>     if (!Deactinit) {
>         bailout("disrealnew","Could not allocate memory for Deactinit");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Deactends ...");
>     Deactends = fvector(NSPHASES + 1);
>     if (!Deactends) {
>         bailout("disrealnew","Could not allocate memory for Deactends");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Deactterm ...");
>     Deactterm = fvector(NSPHASES + 1);
>     if (!Deactterm) {
>         bailout("disrealnew","Could not allocate memory for Deactterm");
>         return(1);
>     }
1416,1418c1525,1528
<     Sf1 = burnset(1, 0, 0); /* Burn across x */
<     Sf2 = burnset(0, 1, 0); /* Burn across y */
<     Sf3 = burnset(0, 0, 1); /* Burn across z */
---
>     /***
>     *    Allocate memory for the arrays that store the influence
>     *    of pH on solubility of each phase in the system.
>     ***/
1420,1422c1530,1534
<     Setflag = Sf1 * Sf2 * Sf3;
<     if (Verbose_flag > 2) {
<       fprintf(Logfile, "\nSetflag = %d", Setflag);
---
>     if (Verbose) printf("  done\n\tAllocating PHsulfcoeff ...");
>     PHsulfcoeff = fvector(NSPHASES + 1);
>     if (!Deactterm) {
>         bailout("disrealnew","Could not allocate memory for Deactterm");
>         return(1);
1424c1536,1541
<   }
---
>     if (Verbose) printf(" done\n\tAllocating PHfactor ...");
>     PHfactor = fvector(NSPHASES + 1);
>     if (!Deactterm) {
>         bailout("disrealnew","Could not allocate memory for Deactterm");
>         return(1);
>     }
1426c1543,1547
<   /* Output last lines of heat and chemical shrinkage files */
---
>     /***
>     *    Get name of hydration parameter file.  This contains
>     *    all of the baseline parameters for dissolution probabilities,
>     *    nucleation probabilities, etc.
>     ***/
1428,1431c1549,1552
<   if (Cyccnt > 1) {
<     Time_step = ((2.0 * ((float)Cyccnt)) - 1.0) * Beta / Krate;
<     Time_cur += Time_step;
<   }
---
>     printf("Enter name of file containing hydration parameters\n");
>     read_string(prmname,sizeof(prmname));
>     printf("%s\n",prmname);
>     fflush(stdout);
1433c1554,1557
<   /* Initialize and calculate gel-space ratio */
---
>     fprmfile = filehandler("disrealnew",prmname,"READ");
>     if (!fprmfile) {
>         return(1);
>     }
1435,1543c1559,1972
<   Gsratio2 = 0.0;
<   Gsratio2 += (double)(Count[CH] + Count[CSH]);
<   Gsratio2 += (double)(Count[C3AH6] + Count[ETTR]);
<   Gsratio2 += (double)(Count[POZZCSH] + Count[SLAGCSH]);
<   Gsratio2 += (double)(Count[FH3] + Count[AFM] + Count[ETTRC4AF]);
<   Gsratio2 += (double)(Count[FRIEDEL] + Count[STRAT]);
<   Gsratio2 += (double)(Count[ABSGYP] + Count[AFMC]);
< 
<   space = (double)(Count[POROSITY] + Count[CRACKP] + Count[EMPTYP]);
<   Gsratio2 = (Gsratio2) / (Gsratio2 + space);
< 
<   gfloat = (double)((0.68 * Alpha_cur) / (0.32 * Alpha_cur + W_to_c));
<   gfloat =
<       (double)(Count[EMPTYP] + Count[POROSITY] + Count[CRACKP] - Water_left);
<   gfloat *= (Heat_cf / 1000.0);
< 
<   Cyccnt++;
< 
<   /* Final call to pHpred */
< 
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "\nMaking final call to pHpred...");
<     fflush(Logfile);
<   }
<   pHpred();
< 
<   /* Attempt to open master data file */
< 
<   Datafile = filehandler("disrealnew", Datafilename, "APPEND");
<   if (!Datafile) {
<     freeallmem();
<     exit(1);
<   }
<   fprintf(Datafile, "\n%d,%.4f,%.4f,%.4f,", Cyccnt - 1, Time_cur, Alpha_cur,
<           Alpha_fa_cur);
<   fprintf(Datafile, "%.4f,%.4f,%.4f,", (Heat_new * Heat_cf), Temp_cur_b,
<           Gsratio2);
<   fprintf(Datafile, "%.4f,%.4f,%.5f,%.4f,", Wn_o, Wn_i, Chs_new, PH_cur);
<   fprintf(Datafile, "%.4f,%.4f,%.4f,%.4f,", Conductivity, Concnaplus, Conckplus,
<           Conccaplus);
<   fprintf(Datafile, "%.4f,%.4f,%.4f,%.4f,", Concsulfate, ActivityK, ActivityCa,
<           ActivityOH);
<   fprintf(Datafile, "%.4f,%.4f,", ActivitySO4,
<           ((float)Count[POROSITY] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,%.4f,", Con_fracp[0], Con_fracp[1],
<           Con_fracp[2]);
<   fprintf(Datafile, "%.4f,",
<           (Con_fracp[0] + Con_fracp[1] + Con_fracp[2]) / 3.0);
<   fprintf(Datafile, "%.4f,%.4f,%.4f,", Con_fracs[0], Con_fracs[1],
<           Con_fracs[2]);
<   fprintf(Datafile, "%.4f,",
<           (Con_fracs[0] + Con_fracs[1] + Con_fracs[2]) / 3.0);
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[C3S] / (float)Syspix),
<           ((float)Count[C2S] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[C3A] / (float)Syspix),
<           ((float)Count[OC3A] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[C4AF] / (float)Syspix),
<           ((float)Count[K2SO4] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[NA2SO4] / (float)Syspix),
<           ((float)Count[GYPSUM] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[HEMIHYD] / (float)Syspix),
<           ((float)Count[ANHYDRITE] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[CACO3] / (float)Syspix),
<           ((float)Count[FREELIME] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[SFUME] / (float)Syspix),
<           ((float)Count[INERT] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[SLAG] / (float)Syspix),
<           ((float)Count[ASG] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[CAS2] / (float)Syspix),
<           ((float)Count[AMSIL] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[CH] / (float)Syspix),
<           ((float)Count[CSH] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[POZZCSH] / (float)Syspix),
<           ((float)Count[SLAGCSH] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[C3AH6] / (float)Syspix),
<           ((float)(Count[ETTR] + Count[ETTRC4AF]) / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[AFM] / (float)Syspix),
<           ((float)Count[FH3] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[CACL2] / (float)Syspix),
<           ((float)Count[FRIEDEL] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[STRAT] / (float)Syspix),
<           ((float)Count[GYPSUMS] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f,", ((float)Count[ABSGYP] / (float)Syspix),
<           ((float)Count[AFMC] / (float)Syspix));
<   fprintf(Datafile, "%.4f,%.4f", ((float)Count[INERTAGG] / (float)Syspix),
<           ((float)Count[EMPTYP] / (float)Syspix));
<   fclose(Datafile);
< 
<   /* Attempt to open time history file */
< 
<   Datafile = filehandler("disrealnew", "time_history.csv", "WRITE");
<   if (!Datafile) {
<     freeallmem();
<     exit(1);
<   }
<   i = 0;
<   fprintf(Datafile, "%d,%f", i, TimeHistory[i]);
<   for (i = 1; i < Cyccnt; i++) {
<     fprintf(Datafile, "\n%d,%f", i, TimeHistory[i]);
<   }
<   fclose(Datafile);
< 
<   /* Write finish time to the log file */
<   /* Get the local time using the current time */
<   end = clock();
<   current_time = time(NULL);
<   time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
< 
<   local_time = localtime(&current_time);
---
>     fscanf(fprmfile,"%s %s",name,instring);
>     Cubesize = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,Cubesize);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     CUBEMIN = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,CUBEMIN);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     PSFUME = atof(instring);
>     if (Verbose) printf("%s %f\n",name,PSFUME);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     SF_SiO2_val = atof(instring);
>     if (Verbose) printf("%s %f\n",name,SF_SiO2_val);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     SF_BET_val = atof(instring);
>     if (Verbose) printf("%s %f\n",name,SF_BET_val);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     SF_LOI_val = atof(instring);
>     if (Verbose) printf("%s %f\n",name,SF_LOI_val);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     SF_SiO2_normal = atof(instring);
>     if (Verbose) printf("%s %f\n",name,SF_SiO2_normal);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     SF_BET_normal = atof(instring);
>     if (Verbose) printf("%s %f\n",name,SF_BET_normal);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     SF_LOI_normal = atof(instring);
>     if (Verbose) printf("%s %f\n",name,SF_LOI_normal);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     PAMSIL = atof(instring);
>     if (Verbose) printf("%s %f\n",name,PAMSIL);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     MAXTRIES = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,MAXTRIES);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     DISBIAS = atof(instring);
>     if (Verbose) printf("%s %f\n",name,DISBIAS);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     Disbias = DISBIAS;
>     fscanf(fprmfile,"%s %s",name,instring);
>     DISMIN = atof(instring);
>     if (Verbose) printf("%s %f\n",name,DISMIN);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     Dismin = DISMIN;
>     fscanf(fprmfile,"%s %s",name,instring);
>     DISMIN2 = atof(instring);
>     if (Verbose) printf("%s %f\n",name,DISMIN2);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     Dismin2 = DISMIN2;
>     fscanf(fprmfile,"%s %s",name,instring);
>     DISMINSLAG = atof(instring);
>     if (Verbose) printf("%s %f\n",name,DISMINSLAG);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     Disminslag = DISMINSLAG;
>     fscanf(fprmfile,"%s %s",name,instring);
>     DISMINASG = atof(instring);
>     if (Verbose) printf("%s %f\n",name,DISMINASG);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     Disminasg = DISMINASG;
>     fscanf(fprmfile,"%s %s",name,instring);
>     DISMINCAS2 = atof(instring);
>     if (Verbose) printf("%s %f\n",name,DISMINCAS2);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     Dismincas2 = DISMINCAS2;
>     fscanf(fprmfile,"%s %s",name,instring);
>     DISMIN_C3A_0 = atof(instring);
>     if (Verbose) printf("%s %f\n",name,DISMIN_C3A_0);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     Dismin_c3a = DISMIN_C3A_0;
>     fscanf(fprmfile,"%s %s",name,instring);
>     DISMIN_C4AF_0 = atof(instring);
>     if (Verbose) printf("%s %f\n",name,DISMIN_C4AF_0);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     Dismin_c4af = DISMIN_C4AF_0;
>     fscanf(fprmfile,"%s %s",name,instring);
>     DK2SO4MAX = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,DK2SO4MAX);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     DNA2SO4MAX = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,DNA2SO4MAX);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     DETTRMAX = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,DETTRMAX);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     DGYPMAX = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,DGYPMAX);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     DCACO3MAX = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,DCACO3MAX);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     DCACL2MAX = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,DCACL2MAX);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     DCAS2MAX = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,DCAS2MAX);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     DASMAX = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,DASMAX);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     CHCRIT = atof(instring);
>     if (Verbose) printf("%s %f\n",name,CHCRIT);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     *pnucch = atof(instring);
>     if (Verbose) printf("%s %f\n",name,*pnucch);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     *pscalech = atof(instring);
>     if (Verbose) printf("%s %f\n",name,*pscalech);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     *pnucgyp = atof(instring);
>     if (Verbose) printf("%s %f\n",name,*pnucgyp);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     *pscalegyp = atof(instring);
>     if (Verbose) printf("%s %f\n",name,*pscalegyp);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     *pnuchg = atof(instring);
>     if (Verbose) printf("%s %f\n",name,*pnuchg);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     *pscalehg = atof(instring);
>     if (Verbose) printf("%s %f\n",name,*pscalehg);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     *pnucfh3 = atof(instring);
>     if (Verbose) printf("%s %f\n",name,*pnucfh3);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     *pscalefh3 = atof(instring);
>     if (Verbose) printf("%s %f\n",name,*pscalefh3);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     C3AH6CRIT = atof(instring);
>     if (Verbose) printf("%s %f\n",name,C3AH6CRIT);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     CSHSCALE = atof(instring);
>     if (Verbose) printf("%s %f\n",name,CSHSCALE);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     C3AH6_SCALE = atof(instring);
>     if (Verbose) printf("%s %f\n",name,C3AH6_SCALE);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     C3AH6GROW = atof(instring);
>     if (Verbose) printf("%s %f\n",name,C3AH6GROW);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     CHGROW = atof(instring);
>     if (Verbose) printf("%s %f\n",name,CHGROW);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     CHGROWAGG = atof(instring);
>     if (Verbose) printf("%s %f\n",name,CHGROWAGG);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     ETTRGROW = atof(instring);
>     if (Verbose) printf("%s %f\n",name,ETTRGROW);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     C3AETTR = atof(instring);
>     if (Verbose) printf("%s %f\n",name,C3AETTR);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     C3AGYP = atof(instring);
>     if (Verbose) printf("%s %f\n",name,C3AGYP);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     SOLIDC3AGYP = atof(instring);
>     if (Verbose) printf("%s %f\n",name,SOLIDC3AGYP);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     SOLIDC4AFGYP = atof(instring);
>     if (Verbose) printf("%s %f\n",name,SOLIDC4AFGYP);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     AGRATE = atof(instring);
>     if (Verbose) printf("%s %f\n",name,AGRATE);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     PCSH2CSH = atof(instring);
>     if (Verbose) printf("%s %f\n",name,PCSH2CSH);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     A0_CHSOL = atof(instring);
>     if (Verbose) printf("%s %f\n",name,A0_CHSOL);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     A1_CHSOL = atof(instring);
>     if (Verbose) printf("%s %f\n",name,A1_CHSOL);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     WCSCALE = atof(instring);
>     if (Verbose) printf("%s %f\n",name,WCSCALE);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     DISTLOCCSH = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,DISTLOCCSH);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     NEIGHBORS = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,NEIGHBORS);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     WN = atof(instring);
>     if (Verbose) printf("%s %f\n",name,WN);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     WCHSH = atof(instring);
>     if (Verbose) printf("%s %f\n",name,WCHSH);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     MAXDIFFSTEPS = atoi(instring);
>     if (Verbose) printf("%s %d\n",name,MAXDIFFSTEPS);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
>     fscanf(fprmfile,"%s %s",name,instring);
>     PDIFFCSH = atof(instring);
>     if (Verbose) printf("%s %f\n",name,PDIFFCSH);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
1545,1548c1974,1977
<   /* Display the local time */
<   fprintf(Logfile, "\nEnd time: %s", asctime(local_time));
<   fprintf(Logfile, "\nElapsed time: %.3f", time_spent);
<   fprintf(Logfile, "\n\n=== END DISREALNEW SIMULATION ===");
---
>     /***
>     *    Number of sulfates absorbed per 100 CSH units
>     *    Currently not used by program
>     ***/
1550,1573c1979,2166
<   /* Write simulation results to stdout in JSON format */
<   if (Verbose_flag > 0) {
<     fprintf(stdout, "\n{");
<     fprintf(stdout, "\n\t\"status\": \"completed\",");
<     fprintf(stdout, "\n\t\"final_doh\": %.3f,", Alpha_cur);
<     fprintf(stdout, "\n\t\"final_temp\": %.2f,", Temp_cur_b);
<     fprintf(stdout, "\n\t\"final_ph\": %.2f,", PH_cur);
<     fprintf(stdout, "\n\t\"output_files\": [");
<     fprintf(stdout, "\n\t\t\"%s\",", Datafilename);
<     /* All microstructure file names here in a loop */
<     fprintf(stdout, "\n\t\t\"%s\",", Fileoname);
<     fprintf(stdout, "\n\t\t\"%s\",", Imageindexname);
<     Movfile = filehandler("disrealnew", Moviename, "READ_NOFAIL");
<     if (Movfile) {
<       fprintf(stdout, "\n\t\t\"%s\",", Moviename);
<     }
<     fprintf(stdout, "\n\t\t\"%sphases_final.csv\",", WorkingDirectory);
<     /* Keep listing the files created */
<     fprintf(stdout, "\n\t\t\"%stemperature_history.csv\"", WorkingDirectory);
<     fprintf(stdout, "\n\t\t\"%sTimeHistory.csv\"", WorkingDirectory);
<     fprintf(stdout, "\n\t],");
<     fprintf(stdout, "\n\t\"execution_time\":%.3f", time_spent);
<     fprintf(stdout, "\n}");
<   }
---
>     fscanf(fprmfile,"%s %s",name,instring);
>     Gypabsprob = atof(instring);
>     if (Verbose) printf("%s %f\n",name,Gypabsprob);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
> 
>     /***
>     *    Gel porosity of CSH, POZZCSH, and SLAGCSH
>     *    Used in pHpred function
>     ***/
> 
>     fscanf(fprmfile,"%s %s",name,instring);
>     CSH_Porosity = atof(instring);
>     if (Verbose) printf("%s %f\n",name,CSH_Porosity);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
> 
>     fscanf(fprmfile,"%s %s",name,instring);
>     POZZCSH_Porosity = atof(instring);
>     if (Verbose) printf("%s %f\n",name,POZZCSH_Porosity);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
> 
>     fscanf(fprmfile,"%s %s",name,instring);
>     SLAGCSH_Porosity = atof(instring);
>     if (Verbose) printf("%s %f\n",name,SLAGCSH_Porosity);
>     if (feof(fprmfile)) {
>         printf("Premature end of parameter file!!\n");
>         return(1);
>     }
> 
>     /***
>     *    Read X and Y values for a second-order fit
>     *    of the dependence of solubility/reactivity on pH.
>     *
>     *    History of default values for specific phases:
>     *
>     *    FitpH[SFUME][x][0] changed from 12.7 to 12.71 on 27 April 2003
>     *    FitpH[SFUME][x][1] changed from 13.085 to 13.095 on 27 April 2003
>     *    FitpH[SFUME][x][2] changed from 13.185 to 13.195 on 27 April 2003
>     *
>     *     FitpH[AMSIL] is equal to FitpH[SFUME] by default
>     *
>     *    FitpH[AS][x][0] changed from 12.7 to 12.71 on 27 April 2003
>     *    FitpH[AS][x][1] changed from 13.085 to 13.095 on 27 April 2003
>     *    FitpH[AS][x][2] changed from 13.185 to 13.195 on 27 April 2003
>     *
>     *    FitpH[CAS2][x][0] changed from 12.7 to 12.71 on 27 April 2003
>     *    FitpH[CAS2][x][1] changed from 13.085 to 13.100 on 27 April 2003
>     *    FitpH[CAS2][x][2] changed from 13.185 to 13.200 on 27 April 2003
>     ***/
> 
>     x = 0;
>     y = 1;
> 
>     for (k = POROSITY; k <= NSPHASES; k++) {
>         if (Verbose) {
>             switch (k) {
>                 case POROSITY:
>                     strcpy(buff,"POROSITY");
>                     break;
>                 case C3S:
>                     strcpy(buff,"C3S");
>                     break;
>                 case C2S:
>                     strcpy(buff,"C2S");
>                     break;
>                 case C3A:
>                     strcpy(buff,"C3A");
>                     break;
>                 case C4AF:
>                     strcpy(buff,"C4AF");
>                     break;
>                 case NA2SO4:
>                     strcpy(buff,"NA2SO4");
>                     break;
>                 case K2SO4:
>                     strcpy(buff,"K2SO4");
>                     break;
>                 case GYPSUM:
>                     strcpy(buff,"GYP");
>                     break;
>                 case HEMIHYD:
>                     strcpy(buff,"HEM");
>                     break;
>                 case ANHYDRITE:
>                     strcpy(buff,"ANH");
>                     break;
>                 case SFUME:
>                     strcpy(buff,"SFUME");
>                     break;
>                 case AMSIL:
>                     strcpy(buff,"AMSIL");
>                     break;
>                 case INERT:
>                     strcpy(buff,"INERT");
>                     break;
>                 case INERTAGG:
>                     strcpy(buff,"AGG");
>                     break;
>                 case ASG:
>                     strcpy(buff,"ASG");
>                     break;
>                 case CAS2:
>                     strcpy(buff,"CAS2");
>                     break;
>                 case SLAG:
>                     strcpy(buff,"SLAG");
>                     break;
>                 case CH:
>                     strcpy(buff,"CH");
>                     break;
>                 case CSH:
>                     strcpy(buff,"CSH");
>                     break;
>                 case ETTR:
>                     strcpy(buff,"ETTR");
>                     break;
>                 case ETTRC4AF:
>                     strcpy(buff,"ETTRC4AF");
>                     break;
>                 case AFM:
>                     strcpy(buff,"AFM");
>                     break;
>                 case C3AH6:
>                     strcpy(buff,"C3AH6");
>                     break;
>                 case FH3:
>                     strcpy(buff,"FH3");
>                     break;
>                 case CACO3:
>                     strcpy(buff,"CACO3");
>                     break;
>                 case FREELIME:
>                     strcpy(buff,"FREELIME");
>                     break;
>                 case OC3A:
>                     strcpy(buff,"OC3A");
>                     break;
>                 case BRUCITE:
>                     strcpy(buff,"BRUCITE");
>                     break;
>                 case MS:
>                     strcpy(buff,"MS");
>                     break;
>                 case STRAT:
>                     strcpy(buff,"STRAT");
>                     break;
>                 case FRIEDEL:
>                     strcpy(buff,"FRIEDEL");
>                     break;
>                 case AFMC:
>                     strcpy(buff,"AFMC");
>                     break;
>                 case CACL2:
>                     strcpy(buff,"CACL2");
>                     break;
>                 case FAC3A:
>                     strcpy(buff,"FAC3A");
>                     break;
>                 case FLYASH:
>                     strcpy(buff,"FLYASH");
>                     break;
>                 case POZZCSH:
>                     strcpy(buff,"POZZCSH");
>                     break;
>                 case SLAGCSH:
>                     strcpy(buff,"SLAGCSH");
>                     break;
>                 case GYPSUMS:
>                     strcpy(buff,"GYPS");
>                     break;
>                 case ABSGYP:
>                     strcpy(buff,"ABSGYP");
>                     break;
>                 default:
>                     strcpy(buff,"UNKNOWN");
>                     break;
>             }
>         }
>     
>         /* Set PHfactor to 1.0 initially */
1575,1577c2168
<   freeallmem();
<   return (0);
< }
---
>         PHfactor[k] = 1.0;
1579,1593c2170,2229
< /***
<  *    checkargs
<  *
<  *     Check command-line arguments used to invoke disrealnew
<  *
<  *     Arguments:    int argc, char *argv[]
<  *     Returns:    nothing
<  *
<  *    Calls:        no routines
<  *    Called by:    main program
<  ***/
< int checkargs(int argc, char **argv) {
<   int wellformed = 0; /* 0 = false, 1 = true */
<   char *jsonname, *wdirname, *pfilename;
<   char buff[MAXSTRING];
---
>         fscanf(fprmfile,"%s %s",name,instring);
>         Discoeff[k] = atof(instring);
>         if (Verbose) {
>             printf("\n%s:\n",buff);
>             printf("\t%s %f\n",name,Discoeff[k]);
>         }
>         if (feof(fprmfile)) {
>             printf("Premature end of parameter file!!\n");
>             return(1);
>         }
>         for (i = x; i <= y; i++) {
>             for (j = 0; j < 3; j++) {
>                 fscanf(fprmfile,"%s %s",name,instring);
>                 FitpH[k][i][j] = atof(instring);
>                 if (Verbose) printf("\t%s %f\n",name,FitpH[k][i][j]);
>                 if (feof(fprmfile)) {
>                     printf("Premature end of parameter file!!\n");
>                     return(1);
>                 }
>             }
>         }
>         fscanf(fprmfile,"%s %s",name,instring);
>         PHsulfcoeff[k] = atof(instring);
>         if (Verbose) printf("\t%s %f\n",name,PHsulfcoeff[k]);
>         if (feof(fprmfile)) {
>             printf("Premature end of parameter file!!\n");
>             return(1);
>         }
>         if (k == CSH) {
>             fscanf(fprmfile,"%s %s",name,instring);
>             Molarvcshcoeff_T = atof(instring);
>             if (Verbose) printf("\t%s %f\n",name,Molarvcshcoeff_T);
>             if (feof(fprmfile)) {
>                 printf("Premature end of parameter file!!\n");
>                 return(1);
>             }
>             fscanf(fprmfile,"%s %s",name,instring);
>             Watercshcoeff_T = atof(instring);
>             if (Verbose) printf("\t%s %f\n",name,Watercshcoeff_T);
>             if (feof(fprmfile)) {
>                 printf("Premature end of parameter file!!\n");
>                 return(1);
>             }
>             fscanf(fprmfile,"%s %s",name,instring);
>             Molarvcshcoeff_pH = atof(instring);
>             if (Verbose) printf("\t%s %f\n",name,Molarvcshcoeff_pH);
>             if (feof(fprmfile)) {
>                 printf("Premature end of parameter file!!\n");
>                 return(1);
>             }
>             fscanf(fprmfile,"%s %s",name,instring);
>             Watercshcoeff_pH = atof(instring);
>             if (Verbose) printf("\t%s %f\n",name,Watercshcoeff_pH);
>             if (feof(fprmfile)) {
>                 printf("Premature end of parameter file!!\n");
>                 return(1);
>             }
>             Molarvcshcoeff_sulf = -10.0;
>         }
>     }
1595,1597c2231
<   strcpy(ParameterFileName, "");
<   strcpy(WorkingDirectory, "");
<   strcpy(ProgressFileName, "");
---
>     fclose(fprmfile);
1599,1601c2233,2240
<   if (argc < 3) {
<     wellformed = 0;
<   }
---
>     /***
>     *    Done reading parameters from parameter file.  These are
>     *    the parameters that previously were hard-wired at compile
>     *    time.
>     *
>     *    Next, read the user-input variables for the hydration
>     *    simulation in question
>     ***/
1603,1604c2242,2247
<   // Many of the variables here are defined in the getopts.h system header
<   // file Can define more options here if we want
---
>     printf("Enter random number seed \n");
>     read_string(instring,sizeof(instring));
>     Iseed = atoi(instring);
>     if (Iseed > 0) Iseed = (-1 * Iseed);
>     printf("%d\n",Iseed);
>     Seed = (&Iseed);
1606,1607c2249
<   /* Default verbosity */
<   Verbose_flag = 2;
---
>     if (Verbose) printf("Dissolution bias is set at %f \n",DISBIAS);
1609,1619c2251,2254
<   static struct option long_opts[] = {
<       /* These options set a flag */
<       {"verbose", no_argument, &Verbose_flag, 3},
<       {"quiet", no_argument, &Verbose_flag, 1},
<       {"silent", no_argument, &Verbose_flag, 0},
<       /* These options don't set a flag */
<       {"json", required_argument, 0, 'j'},
<       {"workdir", required_argument, 0, 'w'},
<       {"parameters", required_argument, 0, 'p'},
<       {"help", no_argument, 0, 'h'},
<       {NULL, 0, 0, 0}};
---
>     /***
>     *    Open file and read in original cement
>     *    particle microstructure
>     ***/
1621,1622c2256,2272
<   int opt_char;
<   int option_index;
---
>     printf("Enter name of directory containing initial microstructure files\n");
>     printf("Be sure to include final file separator:  ");
>     read_string(Micdir,sizeof(Micdir));
>         Filesep = Micdir[strlen(Micdir)-1];
>         if ((Filesep != '/') && (Filesep != '\\')) {
>             printf("\nNo final file separator found.  Using /");
>             Filesep = '/';
>         }
>     printf("%s\n",Micdir);
>     printf("Enter name of file from which the initial ");
>     printf("microstructure will be read\n");
>     read_string(name,sizeof(name));
>     printf("%s\n",name);
>     nlen = strcspn(name,".");
>     strncpy(Fileroot,name,nlen);
>         sprintf(imgfile,"%s%s",Micdir,name);
>     if (Verbose) printf("nlen is %d and Fileroot is now %s \n",nlen,Fileroot);
1624,1656c2274,2311
<   while ((opt_char = getopt_long(argc, argv, "j:w:p:h", long_opts,
<                                  &option_index)) != -1) {
<     switch (opt_char) {
<     case (0):
<       if (long_opts[option_index].flag != 0) {
<         break;
<       }
<     /* -j or --json */
<     case (int)('j'):
<       wellformed = 1;
<       jsonname = optarg;
<       strcpy(ProgressFileName, jsonname);
<       break;
<     // -w or --workdir
<     case (int)('w'):
<       wdirname = optarg;
<       strcpy(WorkingDirectory, wdirname);
<       break;
<     // -p or --parameters
<     case (int)('p'):
<       pfilename = optarg;
<       strcpy(ParameterFileName, pfilename);
<       break;
<     // -h or --help
<     case (int)('h'):
<       wellformed = 0;
<       break;
<     case (int)('?'):
<       wellformed = 0;
<       break;
<     default:
<       wellformed = 0;
<       break;
---
>     printf("\nEnter name of particle image file:  ");
>     read_string(name,sizeof(name));
>     printf("%s\n",name);
>         sprintf(pimgfile,"%s%s",Micdir,name);
> 
>     printf("\nEnter name of directory to store OUTPUT files\n");
>     printf("Be sure to include final file separator:  ");
>     read_string(Outputdir,sizeof(Outputdir));
>     printf("%s\n",Outputdir);
> 
>     /***
>     *    Assign various physical properties of phases
>     ***/
> 
>     assign_properties();
> 
>     printf("Enter fraction of C3A that is to be orthorhombic ");
>     printf("instead of cubic: ");
>     read_string(instring,sizeof(instring));
>         Oc3afrac = atof(instring);
>     printf("%f\n",Oc3afrac);
> 
>     printf("Enter number of seeds for CSH nucleation per um3 of mix water: ");
>     read_string(instring,sizeof(instring));
>         Csh_seeds = atof(instring);
>     printf("%f\n",Csh_seeds);
> 
>     printf("Enter aging time in days: ");
>         read_string(instring,sizeof(instring));
>         End_time = atof(instring);
>     printf("\n%f \n",End_time);
>         End_time *= 24.0;  /* Convert days to hours */
> 
>     printf("Place a crack (y or n)? [n] ");
>     read_string(answer,sizeof(answer));
>     printf("%s\n",answer);
>     if (strlen(answer) < 1) {
>         strcpy(answer,"n");
1658d2312
<   }
1660,1664c2314,2331
<   if (wellformed != 1 || strlen(ProgressFileName) == 0 ||
<       strlen(ParameterFileName) == 0 || strlen(WorkingDirectory) == 0) {
<     printHelp();
<     return (1);
<   }
---
>     if (toupper(answer[0]) == 'Y') {
>         printf("\nEnter total crack width (in pixels): ");
>         read_string(instring,sizeof(instring));
>         Crackwidth = atoi(instring);
>         printf("%d",Crackwidth);
>         printf("\nEnter time at which to crack (in h): ");
>         read_string(instring,sizeof(instring));
>         Cracktime = atof(instring);
>         printf("%f",Cracktime);
>         printf("\nEnter orientation of crack as follows:");
>         printf("\n\t 1 = parallel to yz plane");
>         printf("\n\t 2 = parallel to xz plane");
>         printf("\n\t 3 = parallel to xy plane");
>         printf("\nOrientation: ");
>         read_string(instring,sizeof(instring));
>         Crackorient = atoi(instring);
>         if (Crackorient > 3) Crackorient = 3;
>         printf("%d\n",Crackorient);
1666,1670c2333,2337
<   sprintf(LogFileName, "%sdisrealnew.log", WorkingDirectory);
<   strcpy(buff, ParameterFileName);
<   sprintf(ParameterFileName, "%s%s", WorkingDirectory, buff);
<   strcpy(buff, ProgressFileName);
<   sprintf(ProgressFileName, "%s%s", WorkingDirectory, buff);
---
>     } else {
>         Crackwidth = 0;
>         Cracktime = -1.0;
>         Crackorient = 1;
>     }
1672,1673c2339,2344
<   return (0);
< }
---
>     printf("Customize times for outputting microstructure (y or n)? [n] ");
>     read_string(answer,sizeof(answer));
>     printf("%s\n",answer);
>     if (strlen(answer) < 1) {
>         strcpy(answer,"n");
>     }
1675,1704c2346,2357
< /***
<  *    printHelp
<  *
<  *     Prints a usage message for the program
<  *
<  *     Arguments:    none
<  *     Returns:    0 if okay, nonzero otherwise
<  *
<  *    Calls:        no routines
<  *    Called by:    checkargs
<  ***/
< void printHelp(void) {
<   fprintf(stderr,
<           "\n\nUsage: disrealnew [-h,--help] [-q,--quiet | -s,--silent]\n");
<   fprintf(stderr, "      -j,--json progress.json -w,--workdir "
<                   "working_directory -p,--parameters parameter_file\n\n");
<   fprintf(stderr, "    progress.json is the name of the progress file for UI "
<                   "processing (required)\n");
<   fprintf(stderr, "    working_directory is the path to the folder that will "
<                   "hold all simulation results (required)\n");
<   fprintf(stderr, "    parameter_file is the name of the file that holds all "
<                   "the hydration model parameters (required) \n\n");
<   fprintf(stderr, "Normal mode: Print progress updates to stderr and end point "
<                   "results to stdout\n");
<   fprintf(stderr, "Quiet mode: Print only end point results to stdout, no "
<                   "progress updates to stderr\n");
<   fprintf(stderr, "Silent mode: Suppress all output except critical errors "
<                   "to stderr\n\n");
<   return;
< }
---
>     if (toupper(answer[0]) == 'Y') {
>         Tcustomoutputentries = 0;
>          sprintf(custcycfile,"%scustomoutput.dat",Outputdir);
>          fcofile = filehandler("disrealnew",custcycfile,"READ");
>          if (!fcofile) {
>              freeallmem();
>              exit(1);
>          }
>         while (!feof(fcofile)) {
>             fscanf(fcofile,"%s",buff);
>             if (!feof(fcofile)) Tcustomoutputentries++;
>         }
1706,1733c2359,2363
< /***
<  *    get_input
<  *
<  *     Gather input data and parameters for running simulation
<  *
<  *     Arguments:    none
<  *     Returns:    0 if okay, nonzero otherwise
<  *
<  *    Calls:        no routines
<  *    Called by:    main program
<  ***/
< int get_input(float *pnucch, float *pscalech, float *pnuchg, float *pscalehg,
<               float *pnucfh3, float *pscalefh3, float *pnucgyp,
<               float *pscalegyp, int *nmovstep) {
<   int i, j, k, status = 0;
<   int onepixfloc = 0;
<   int nlen, phtodo, valin, ovalin, dphase, deactphase;
<   int ix, iy, iz, x, y;
<   int newx, newy, newz;
<   int nadd;
<   char ch, imgfile[MAXSTRING], pimgfile[MAXSTRING];
<   char buff[MAXSTRING], custcycfile[MAXSTRING];
<   char name[MAXSTRING], answer[MAXSTRING], calfilename[MAXSTRING];
<   char buff1[MAXSTRING], buff2[MAXSTRING];
<   char *instring;
<   float dfrac, dends, dterm, bias, pc3a, b_estimate;
<   float newver, newres;
<   FILE *fimgfile, *fpimgfile, *fprmfile, *fcofile, *fcalfile;
---
>         CustomImageTime = fvector(Tcustomoutputentries);
>         if (!CustomImageTime) {
>             freeallmem();
>             exit(1);
>         }
1735,1738c2365,2375
<   /***
<    *    Allocate memory for dissolution probability arrays
<    *    and some other variables that are phase-specific.
<    ***/
---
>         fclose(fcofile);
>          fcofile = filehandler("disrealnew",custcycfile,"READ");
>          if (!fcofile) {
>              freeallmem();
>              exit(1);
>          }
>         for (i = 0; i < Tcustomoutputentries; i++) {
>             fscanf(fcofile,"%s",buff);
>             CustomImageTime[i] = atof(buff);
>         }
>         fclose(fcofile);
1740,1781c2377,2383
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\tAllocating Disprob ...");
<   Disprob = fvector(NSPHASES + 1);
<   if (!Disprob) {
<     bailout("disrealnew", "Could not allocate memory for Disprob");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Disbase ...");
<   Disbase = fvector(NSPHASES + 1);
<   if (!Disbase) {
<     bailout("disrealnew", "Could not allocate memory for Disbase");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Discoeff ...");
<   Discoeff = fvector(NSPHASES + 1);
<   if (!Discoeff) {
<     bailout("disrealnew", "Could not allocate memory for Discoeff");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Soluble ...");
<   Soluble = ivector(NSPHASES + 1);
<   if (!Soluble) {
<     bailout("disrealnew", "Could not allocate memory for Soluble");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Creates ...");
<   Creates = ivector(NSPHASES + 1);
<   if (!Creates) {
<     bailout("disrealnew", "Could not allocate memory for Creates");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Onepixelbias ...");
<   Onepixelbias = fvector(NSPHASES + 1);
<   if (!Onepixelbias) {
<     bailout("disrealnew", "Could not allocate memory for Onepixelbias");
<     return (1);
<   }
---
>     } else {
>         CustomImageTime = NULL;
>         printf("Output hydrating microstructure every ____ hours: ");
>         read_string(instring,sizeof(instring));
>         OutTimefreq = atof(instring);
>         printf("\n%f\n",OutTimefreq);
>     }
1783,1786d2384
<   /***
<    *    Allocate memory for the activation/deactivation start
<    *    and stop flags for each phase in the system.
<    ***/
1788,1843c2386,2400
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "  done\n\tAllocating Startflag ...");
<   Startflag = ivector(NSPHASES + 1);
<   if (!Startflag) {
<     bailout("disrealnew", "Could not allocate memory for Startflag");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Stopflag ...");
<   Stopflag = ivector(NSPHASES + 1);
<   if (!Stopflag) {
<     bailout("disrealnew", "Could not allocate memory for Stopflag");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Deactphaselist ...");
<   Deactphaselist = ivector(NSPHASES + 1);
<   if (!Deactphaselist) {
<     bailout("disrealnew", "Could not allocate memory for Deactphaselist");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Deactfrac ...");
<   Deactfrac = fvector(NSPHASES + 1);
<   if (!Deactfrac) {
<     bailout("disrealnew", "Could not allocate memory for Deactfrac");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Reactfrac ...");
<   Reactfrac = fvector(NSPHASES + 1);
<   if (!Reactfrac) {
<     bailout("disrealnew", "Could not allocate memory for Reactfrac");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Deactinit ...");
<   Deactinit = fvector(NSPHASES + 1);
<   if (!Deactinit) {
<     bailout("disrealnew", "Could not allocate memory for Deactinit");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Deactends ...");
<   Deactends = fvector(NSPHASES + 1);
<   if (!Deactends) {
<     bailout("disrealnew", "Could not allocate memory for Deactends");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Deactterm ...");
<   Deactterm = fvector(NSPHASES + 1);
<   if (!Deactterm) {
<     bailout("disrealnew", "Could not allocate memory for Deactterm");
<     return (1);
<   }
---
>     /****
>     *    NOTE:  MUST READ
>     *            (1) SOFTWARE VERSION OF INPUT FILE (Version)
>     *            (1) SYSTEM SIZE (Xsyssize,Ysyssize,Zsyssize)
>     *            (2) SYSTEM RESOLUTION (Res)
>     *
>     *    Then set global variables Syspix, Sizemag, Isizemag
>     *    rather than hardwiring them as preprocessor
>     *    defines
>     ****/
>     
>     fimgfile = filehandler("disrealnew",imgfile,"READ");
>     if (!fimgfile) {
>         return(1);
>     }
1845,1848c2402,2407
<   /***
<    *    Allocate memory for the arrays that store the influence
<    *    of pH on solubility of each phase in the system.
<    ***/
---
>     if (read_imgheader(fimgfile,&Version,&Xsyssize_orig,&Ysyssize_orig,&Zsyssize_orig,&Res)) {
>         fclose(fimgfile);
>         freeallmem();
>         bailout("disrealnew","Error reading image header");
>         exit(1);
>     }
1850,1863c2409,2417
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "  done\n\tAllocating PHsulfcoeff ...");
<   PHsulfcoeff = fvector(NSPHASES + 1);
<   if (!Deactterm) {
<     bailout("disrealnew", "Could not allocate memory for Deactterm");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating PHfactor ...");
<   PHfactor = fvector(NSPHASES + 1);
<   if (!Deactterm) {
<     bailout("disrealnew", "Could not allocate memory for Deactterm");
<     return (1);
<   }
---
>     if (Verbose) {
>         printf("\nDone reading image header...\n");
>         printf("\tVersion = %f\n",Version);
>         printf("\tX size = %d\n",Xsyssize_orig);
>         printf("\tY size = %d\n",Ysyssize_orig);
>         printf("\tZ size = %d\n",Ysyssize_orig);
>         printf("\tResolution = %f\n",Res);
>         fflush(stdout);
>     }
1865,1869c2419,2421
<   /***
<    *    Get name of hydration parameter file.  This contains
<    *    all of the baseline parameters for dissolution probabilities,
<    *    nucleation probabilities, etc.
<    ***/
---
>     Xsyssize = Xsyssize_orig;
>     Ysyssize = Ysyssize_orig;
>     Zsyssize = Zsyssize_orig;
1871,1874c2423,2429
<   fprmfile = filehandler("disrealnew", ParameterFileName, "READ");
<   if (!fprmfile) {
<     return (1);
<   }
---
>     Syspix = Xsyssize * Ysyssize * Zsyssize;
>     Syspix_orig = Syspix;
>     Sizemag = ((float)Syspix)/(pow(((double)(DEFAULTSYSTEMSIZE)),3.0));
>     if (Verbose) printf("\nSizemag = %f",Sizemag);
>     Sizemag_orig = Sizemag;
>     Isizemag = (int)(Sizemag + 0.5);
>     Isizemag_orig = Isizemag;
1876,2453c2431,2433
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   Cubesize = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, Cubesize);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   CUBEMIN = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, CUBEMIN);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   PSFUME = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, PSFUME);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   SF_SiO2_val = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, SF_SiO2_val);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   SF_BET_val = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, SF_BET_val);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   SF_LOI_val = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, SF_LOI_val);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   SF_SiO2_normal = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, SF_SiO2_normal);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   SF_BET_normal = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, SF_BET_normal);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   PAMSIL = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, PAMSIL);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   MAXTRIES = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, MAXTRIES);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DISBIAS = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, DISBIAS);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   Disbias = DISBIAS;
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DISMIN = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, DISMIN);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   Dismin = DISMIN;
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DISMIN2 = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, DISMIN2);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   Dismin2 = DISMIN2;
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DISMINSLAG = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, DISMINSLAG);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   Disminslag = DISMINSLAG;
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DISMINASG = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, DISMINASG);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   Disminasg = DISMINASG;
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DISMINCAS2 = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, DISMINCAS2);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   Dismincas2 = DISMINCAS2;
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DISMIN_C3A_0 = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, DISMIN_C3A_0);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   Dismin_c3a = DISMIN_C3A_0;
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DISMIN_C4AF_0 = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, DISMIN_C4AF_0);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   Dismin_c4af = DISMIN_C4AF_0;
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DK2SO4MAX = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, DK2SO4MAX);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DNA2SO4MAX = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, DNA2SO4MAX);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DETTRMAX = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, DETTRMAX);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DGYPMAX = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, DGYPMAX);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DCACO3MAX = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, DCACO3MAX);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DCACL2MAX = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, DCACL2MAX);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DCAS2MAX = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, DCAS2MAX);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DASMAX = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, DASMAX);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   CHCRIT = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, CHCRIT);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   *pnucch = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, *pnucch);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   *pscalech = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, *pscalech);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   *pnucgyp = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, *pnucgyp);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   *pscalegyp = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, *pscalegyp);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   *pnuchg = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, *pnuchg);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   *pscalehg = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, *pscalehg);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   *pnucfh3 = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, *pnucfh3);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   *pscalefh3 = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, *pscalefh3);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   C3AH6CRIT = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, C3AH6CRIT);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   CSHSCALE = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, CSHSCALE);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   C3AH6_SCALE = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, C3AH6_SCALE);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   C3AH6GROW = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, C3AH6GROW);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   CHGROW = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, CHGROW);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   CHGROWAGG = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, CHGROWAGG);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   ETTRGROW = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, ETTRGROW);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   C3AETTR = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, C3AETTR);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   C3AGYP = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, C3AGYP);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   SOLIDC3AGYP = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, SOLIDC3AGYP);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   SOLIDC4AFGYP = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, SOLIDC4AFGYP);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   AGRATE = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, AGRATE);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   PCSH2CSH = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, PCSH2CSH);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   A0_CHSOL = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, A0_CHSOL);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   A1_CHSOL = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, A1_CHSOL);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   WCSCALE = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, WCSCALE);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   DISTLOCCSH = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, DISTLOCCSH);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   NEIGHBORS = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, NEIGHBORS);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   WN = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, WN);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   WCHSH = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, WCHSH);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   MAXDIFFSTEPS = atoi(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %d\n", name, MAXDIFFSTEPS);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   PDIFFCSH = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, PDIFFCSH);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
---
>     if (Crackorient == 1) Xsyssize += Crackwidth;
>     if (Crackorient == 2) Ysyssize += Crackwidth;
>     if (Crackorient == 3) Zsyssize += Crackwidth;
2455,2458c2435,2438
<   /***
<    *    Number of sulfates absorbed per 100 CSH units
<    *    Currently not used by program
<    ***/
---
>     /***
>     *    Must now allocate the memory for all the 3D arrays
>     *    (See disrealnew.h for their declaration)
>     ***/
2460,2469c2440,2448
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   Gypabsprob = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, Gypabsprob);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
---
>     if (Verbose) printf("\tAllocating Mic with dimensions %d %d %d...",Xsyssize,Ysyssize,Zsyssize);
>     Mic = cbox(Xsyssize,Ysyssize,Zsyssize);
>     if (!Mic) {
>         freeallmem();
>         fclose(fimgfile);
>         bailout("disrealnew","Could not allocate memory for Mic array");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Micorig ...");
2471,2474c2450,2457
<   /***
<    *    Gel porosity of CSH, POZZCSH, and SLAGCSH
<    *    Used in pHpred function
<    ***/
---
>     Micorig = cbox(Xsyssize,Ysyssize,Zsyssize);
>     if (!Micorig) {
>         freeallmem();
>         fclose(fimgfile);
>         bailout("disrealnew","Could not allocate memory for Micorig array");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Micpart ...");
2476,2496c2459,2466
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   CSH_Porosity = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, CSH_Porosity);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
< 
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   POZZCSH_Porosity = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, POZZCSH_Porosity);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
---
>     Micpart = sibox(Xsyssize,Ysyssize,Zsyssize);
>     if (!Micpart) {
>         freeallmem();
>         fclose(fimgfile);
>         bailout("disrealnew","Could not allocate memory for Micpart array");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Cshage ...");
2498,2507c2468,2475
<   fread_string(fprmfile, buff1);
<   instring = strtok(buff1, ",");
<   instring = strtok(NULL, ",");
<   SLAGCSH_Porosity = atof(instring);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "%s %f\n", name, SLAGCSH_Porosity);
<   if (feof(fprmfile)) {
<     fprintf(Logfile, "Premature end of parameter file!!\n");
<     return (1);
<   }
---
>     Cshage = sibox(Xsyssize,Ysyssize,Zsyssize);
>     if (!Cshage) {
>         freeallmem();
>         fclose(fimgfile);
>         bailout("disrealnew","Could not allocate memory for Cshage array");
>         return(1);
>     }
>     if (Verbose) printf(" done\n\tAllocating Deactivated ...");
2509,2528c2477,2484
<   /***
<    *    Read X and Y values for a second-order fit
<    *    of the dependence of solubility/reactivity on pH.
<    *
<    *    History of default values for specific phases:
<    *
<    *    FitpH[SFUME][x][0] changed from 12.7 to 12.71 on 27 April 2003
<    *    FitpH[SFUME][x][1] changed from 13.085 to 13.095 on 27 April 2003
<    *    FitpH[SFUME][x][2] changed from 13.185 to 13.195 on 27 April 2003
<    *
<    *     FitpH[AMSIL] is equal to FitpH[SFUME] by default
<    *
<    *    FitpH[AS][x][0] changed from 12.7 to 12.71 on 27 April 2003
<    *    FitpH[AS][x][1] changed from 13.085 to 13.095 on 27 April 2003
<    *    FitpH[AS][x][2] changed from 13.185 to 13.195 on 27 April 2003
<    *
<    *    FitpH[CAS2][x][0] changed from 12.7 to 12.71 on 27 April 2003
<    *    FitpH[CAS2][x][1] changed from 13.085 to 13.100 on 27 April 2003
<    *    FitpH[CAS2][x][2] changed from 13.185 to 13.200 on 27 April 2003
<    ***/
---
>     Deactivated = sibox(Xsyssize,Ysyssize,Zsyssize);
>     if (!Deactivated) {
>         fclose(fimgfile);
>         freeallmem();
>         bailout("disrealnew","Could not allocate memory for Deactivated array");
>         return(1);
>     }
>     if (Verbose) printf(" done\n");
2530,2531c2486,2487
<   x = 0;
<   y = 1;
---
>     Cshscale = CSHSCALE * Sizemag;
>     C3ah6_scale = C3AH6_SCALE * Sizemag;
2533,2656c2489,2552
<   for (k = POROSITY; k <= NSPHASES; k++) {
<     if (Verbose_flag > 1) {
<       switch (k) {
<       case POROSITY:
<         strcpy(buff, "POROSITY");
<         break;
<       case C3S:
<         strcpy(buff, "C3S");
<         break;
<       case C2S:
<         strcpy(buff, "C2S");
<         break;
<       case C3A:
<         strcpy(buff, "C3A");
<         break;
<       case C4AF:
<         strcpy(buff, "C4AF");
<         break;
<       case NA2SO4:
<         strcpy(buff, "NA2SO4");
<         break;
<       case K2SO4:
<         strcpy(buff, "K2SO4");
<         break;
<       case GYPSUM:
<         strcpy(buff, "GYP");
<         break;
<       case HEMIHYD:
<         strcpy(buff, "HEM");
<         break;
<       case ANHYDRITE:
<         strcpy(buff, "ANH");
<         break;
<       case SFUME:
<         strcpy(buff, "SFUME");
<         break;
<       case AMSIL:
<         strcpy(buff, "AMSIL");
<         break;
<       case INERT:
<         strcpy(buff, "INERT");
<         break;
<       case INERTAGG:
<         strcpy(buff, "AGG");
<         break;
<       case ASG:
<         strcpy(buff, "ASG");
<         break;
<       case CAS2:
<         strcpy(buff, "CAS2");
<         break;
<       case SLAG:
<         strcpy(buff, "SLAG");
<         break;
<       case CH:
<         strcpy(buff, "CH");
<         break;
<       case CSH:
<         strcpy(buff, "CSH");
<         break;
<       case ETTR:
<         strcpy(buff, "ETTR");
<         break;
<       case ETTRC4AF:
<         strcpy(buff, "ETTRC4AF");
<         break;
<       case AFM:
<         strcpy(buff, "AFM");
<         break;
<       case C3AH6:
<         strcpy(buff, "C3AH6");
<         break;
<       case FH3:
<         strcpy(buff, "FH3");
<         break;
<       case CACO3:
<         strcpy(buff, "CACO3");
<         break;
<       case FREELIME:
<         strcpy(buff, "FREELIME");
<         break;
<       case OC3A:
<         strcpy(buff, "OC3A");
<         break;
<       case BRUCITE:
<         strcpy(buff, "BRUCITE");
<         break;
<       case MS:
<         strcpy(buff, "MS");
<         break;
<       case STRAT:
<         strcpy(buff, "STRAT");
<         break;
<       case FRIEDEL:
<         strcpy(buff, "FRIEDEL");
<         break;
<       case AFMC:
<         strcpy(buff, "AFMC");
<         break;
<       case CACL2:
<         strcpy(buff, "CACL2");
<         break;
<       case FAC3A:
<         strcpy(buff, "FAC3A");
<         break;
<       case FLYASH:
<         strcpy(buff, "FLYASH");
<         break;
<       case POZZCSH:
<         strcpy(buff, "POZZCSH");
<         break;
<       case SLAGCSH:
<         strcpy(buff, "SLAGCSH");
<         break;
<       case GYPSUMS:
<         strcpy(buff, "GYPS");
<         break;
<       case ABSGYP:
<         strcpy(buff, "ABSGYP");
<         break;
<       default:
<         strcpy(buff, "UNKNOWN");
<         break;
<       }
---
>     /***
>     *    Adjust the maximum number of diffusion steps
>     *    per cycle based on system resolution.  That is,
>     *    if each step is 0.5 microns instead of 1.0 microns
>     *    and we want the same RMS distance to be achieved
>     *    in a cycle, then we need (1/0.5)^2 the steps we
>     *    had originally
>     ***/
> 
>     Maxdiffsteps = MAXDIFFSTEPS / (Res * Res);
> 
>     /****************************************/
> 
>     /***
>     *    Reset Xsyssize, Ysyssize, and Zsyssize back to 
>     *    the original system size until the microstructure
>     *    actually cracks
>     ***/    
> 
>     Xsyssize = Xsyssize_orig;
>     Ysyssize = Ysyssize_orig;
>     Zsyssize = Zsyssize_orig;
> 
>     if (Verbose) printf("\nPreparing to read image file ...");
>     for (iz = 0; iz < Zsyssize; iz++) {
>         for (iy = 0; iy < Ysyssize; iy++) {
>             for (ix = 0; ix < Xsyssize; ix++) {
> 
>                 Cshage[ix][iy][iz] = 0;
>                 Deactivated[ix][iy][iz] = 1;
>                 fscanf(fimgfile,"%s",instring);
>                 ovalin = atoi(instring);
>                 valin = convert_id(ovalin,Version);
> 
>                 /***
>                 * Check if C3A needs to be converted to orthorhombic
>                 ***/
> 
>                 if (valin == C3A) {
>                     pc3a = ran1(Seed);
>                     if (pc3a < Oc3afrac) {
>                         valin = OC3A;
>                     }
>                 }
>                 Mic[ix][iy][iz] = valin;
> 
>                 Micorig[ix][iy][iz] = Mic[ix][iy][iz];
> 
>             }    /* End of loop in iz */
>         }        /* End of loop in iy */
>     }            /* End of loop in ix */
> 
>     fclose(fimgfile);
>     if (Verbose) printf(" done\n");
> 
> 
>     /* Now read in particle IDs from file */
> 
>     fpimgfile = filehandler("disrealnew",pimgfile,"READ");
>     if (!fpimgfile) {
>         printf("\nCould not open fpimgfile: %s. Exiting ...",pimgfile);
>         fflush(stdout);
>         freeallmem();
>         exit(1);
2659c2555,2559
<     /* Set PHfactor to 1.0 initially */
---
>     /***
>     *    As before, must either read in the first
>     *    two lines of size and resolution
>     *    information ...
>     ***/
2661c2561,2568
<     PHfactor[k] = 1.0;
---
>     if (read_imgheader(fpimgfile,&newver,&newx,&newy,&newz,&newres)) {
>         printf("\nTrouble reading header of fpimgfile: %s. Exiting ...",pimgfile);
>         fflush(stdout);
>         fclose(fpimgfile);
>         freeallmem();
>         bailout("disrealnew","Error reading image header");
>         exit(1);
>     }
2663,2669c2570,2579
<     fread_string(fprmfile, buff1);
<     instring = strtok(buff1, ",");
<     instring = strtok(NULL, ",");
<     Discoeff[k] = atof(instring);
<     if (Verbose_flag > 1) {
<       fprintf(Logfile, "\n%s:\n", buff);
<       fprintf(Logfile, "\t%s %f\n", name, Discoeff[k]);
---
>     for (iz = 0; iz < Zsyssize; iz++) {
>         for (iy = 0; iy < Ysyssize; iy++) {
>             for (ix = 0; ix < Xsyssize; ix++) {
> 
>                 fscanf(fpimgfile,"%s",instring);
>                 valin = atoi(instring);
>                 Micpart[ix][iy][iz] = valin;
> 
>             }
>         }
2671,2673c2581,2587
<     if (feof(fprmfile)) {
<       fprintf(Logfile, "Premature end of parameter file!!\n");
<       return (1);
---
>     
>     fclose(fpimgfile);
> 
>     if (Version != newver) {
>         printf("WARNING: Some files were created with differing\n");
>         printf("\tVCCTL software versions.  This may create a");
>         printf("\tconflict.");
2675,2687c2589,2594
<     for (i = x; i <= y; i++) {
<       for (j = 0; j < 3; j++) {
<         fread_string(fprmfile, buff1);
<         instring = strtok(buff1, ",");
<         instring = strtok(NULL, ",");
<         FitpH[k][i][j] = atof(instring);
<         if (Verbose_flag > 1)
<           fprintf(Logfile, "\t%s %f\n", name, FitpH[k][i][j]);
<         if (feof(fprmfile)) {
<           fprintf(Logfile, "Premature end of parameter file!!\n");
<           return (1);
<         }
<       }
---
>     if (Xsyssize != newx) {
>          printf("Xsyssize = %d, New x size = %d",Xsyssize,newx);
>         fflush(stdout);
>         freeallmem();
>         bailout("disrealnew","Incompatible size declarations");
>         exit(1);
2689,2697c2596,2603
<     fread_string(fprmfile, buff1);
<     instring = strtok(buff1, ",");
<     instring = strtok(NULL, ",");
<     PHsulfcoeff[k] = atof(instring);
<     if (Verbose_flag > 1)
<       fprintf(Logfile, "\t%s %f\n", name, PHsulfcoeff[k]);
<     if (feof(fprmfile)) {
<       fprintf(Logfile, "Premature end of parameter file!!\n");
<       return (1);
---
> 
>     if (Ysyssize != newy) {
>          printf("Ysyssize = %d, New y size = %d",Ysyssize,newy);
>         fflush(stdout);
>         freeallmem();
>          printf("Ysyssize = %d, New y size = %d",Ysyssize,newy);
>         bailout("disrealnew","Incompatible size declarations");
>         exit(1);
2699,2740c2605,2611
<     if (k == CSH) {
<       fread_string(fprmfile, buff1);
<       instring = strtok(buff1, ",");
<       instring = strtok(NULL, ",");
<       Molarvcshcoeff_T = atof(instring);
<       if (Verbose_flag > 1)
<         fprintf(Logfile, "\t%s %f\n", name, Molarvcshcoeff_T);
<       if (feof(fprmfile)) {
<         fprintf(Logfile, "Premature end of parameter file!!\n");
<         return (1);
<       }
<       fread_string(fprmfile, buff1);
<       instring = strtok(buff1, ",");
<       instring = strtok(NULL, ",");
<       Watercshcoeff_T = atof(instring);
<       if (Verbose_flag > 1)
<         fprintf(Logfile, "\t%s %f\n", name, Watercshcoeff_T);
<       if (feof(fprmfile)) {
<         fprintf(Logfile, "Premature end of parameter file!!\n");
<         return (1);
<       }
<       fread_string(fprmfile, buff1);
<       instring = strtok(buff1, ",");
<       instring = strtok(NULL, ",");
<       Molarvcshcoeff_pH = atof(instring);
<       if (Verbose_flag > 1)
<         fprintf(Logfile, "\t%s %f\n", name, Molarvcshcoeff_pH);
<       if (feof(fprmfile)) {
<         fprintf(Logfile, "Premature end of parameter file!!\n");
<         return (1);
<       }
<       fread_string(fprmfile, buff1);
<       instring = strtok(buff1, ",");
<       instring = strtok(NULL, ",");
<       Watercshcoeff_pH = atof(instring);
<       if (Verbose_flag > 1)
<         fprintf(Logfile, "\t%s %f\n", name, Watercshcoeff_pH);
<       if (feof(fprmfile)) {
<         fprintf(Logfile, "Premature end of parameter file!!\n");
<         return (1);
<       }
<       Molarvcshcoeff_sulf = -10.0;
---
> 
>     if (Zsyssize != newz) {
>          printf("Zsyssize = %d, New y size = %d",Ysyssize,newy);
>         fflush(stdout);
>         freeallmem();
>         bailout("disrealnew","Incompatible size declarations");
>         exit(1);
2742d2612
<   }
2744c2614,2622
<   fclose(fprmfile);
---
>     /***
>     *    Allow user to iteratively add one-pixel
>     *    particles of various phases.
>     *
>     *    VCCTL software adds the one-pixel particles at the
>     *    microstructure creation stage rather than here, but
>     *    we keep this structure in place for possible manual
>     *    addition of one-pixel particles by the user.
>     ***/
2746,2753c2624,2628
<   /***
<    *    Done reading parameters from parameter file.  These are
<    *    the parameters that previously were hard-wired at compile
<    *    time.
<    *
<    *    Next, read the user-input variables for the hydration
<    *    simulation in question
<    ***/
---
>     printf("Enter number of one pixel particles to add (-1 to quit) \n");
>     fflush(stdout);
>     read_string(instring,sizeof(instring));
>     nadd = atoi(instring);
>     printf("%d\n",nadd);
2755,2761c2630
<   fprintf(Logfile, "Enter random number seed \n");
<   read_string(instring, sizeof(instring));
<   Iseed = atoi(instring);
<   if (Iseed > 0)
<     Iseed = (-1 * Iseed);
<   fprintf(Logfile, "%d\n", Iseed);
<   Seed = (&Iseed);
---
>     while (nadd >= 0) {
2763,2764c2632,2638
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "Dissolution bias is set at %f \n", DISBIAS);
---
>         onepixfloc = 0;  /* No flocculation of one-pixel particles */
>         /*
>         printf("Should these particles flocculate ");
>         printf("to surfaces? No (0) or Yes (1): ");
>         read_string(instring,sizeof(instring));
>         onepixfloc = atoi(instring);
>         */
2766,2769c2640,2643
<   /***
<    *    Open file and read in original cement
<    *    particle microstructure
<    ***/
---
>         printf("Enter dissolution bias for these one pixel particles\n");
>         read_string(instring,sizeof(instring));
>         bias = atof(instring);
>         printf("%f\n",bias);
2771,2789c2645,2677
<   fprintf(Logfile,
<           "Enter name of directory containing initial microstructure files\n");
<   fprintf(Logfile, "Be sure to include final file separator:  ");
<   read_string(Micdir, sizeof(Micdir));
<   Filesep = Micdir[strlen(Micdir) - 1];
<   if ((Filesep != '/') && (Filesep != '\\')) {
<     fprintf(Logfile, "\nNo final file separator found.  Using /");
<     Filesep = '/';
<   }
<   fprintf(Logfile, "%s\n", Micdir);
<   fprintf(Logfile, "Enter name of file from which the initial ");
<   fprintf(Logfile, "microstructure will be read\n");
<   read_string(name, sizeof(name));
<   fprintf(Logfile, "%s\n", name);
<   nlen = strcspn(name, ".");
<   strncpy(Fileroot, name, nlen);
<   sprintf(imgfile, "%s%s", Micdir, name);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "nlen is %d and Fileroot is now %s \n", nlen, Fileroot);
---
>         printf("Enter phase to add \n");
>         if (Verbose) {
>             printf("\tC3S %d\n",C3S);
>             printf("\tC2S %d\n",C2S);
>             printf("\tC3A %d\n",C3A);
>             printf("\tC4AF %d\n",C4AF);
>             printf("\tGYPSUM %d\n",GYPSUM);
>             printf("\tHEMIHYD %d\n",HEMIHYD);
>             printf("\tANHYDRITE %d\n",ANHYDRITE);
>             printf("\tSILICA FUME %d\n",SFUME);
>             printf("\tINERT %d\n",INERT);
>             printf("\tSLAG %d\n",SLAG);
>             printf("\tASG %d\n",ASG);
>             printf("\tCAS2 %d\n",CAS2);
>             printf("\tAMORPHOUS SILICA %d\n",AMSIL);
>             printf("\tCH %d\n",CH);
>             printf("\tCSH %d\n",CSH);
>             printf("\tC3AH6 %d\n",C3AH6);
>             printf("\tEttringite %d\n",ETTR);
>             printf("\tStable Ettringite from C4AF %d\n",ETTRC4AF);
>             printf("\tAFM %d\n",AFM);
>             printf("\tFH3 %d\n",FH3);
>             printf("\tPOZZCSH %d\n",POZZCSH);
>             printf("\tSLAGCSH %d\n",SLAGCSH);
>             printf("\tCACL2 %d\n",CACL2);
>             printf("\tFriedels salt %d\n",FRIEDEL);
>             printf("\tStratlingite %d\n",STRAT);
>             printf("\tCalcium carbonate %d\n",CACO3);
>             printf("\tAFmc %d\n",AFMC);
>             printf("\tBrucite %d\n",BRUCITE);
>             printf("\tMS %d\n",MS);
>             printf("\tFree Lime %d\n",FREELIME);
>         }
2791,2794c2679,2681
<   fprintf(Logfile, "\nEnter name of particle image file:  ");
<   read_string(name, sizeof(name));
<   fprintf(Logfile, "%s\n", name);
<   sprintf(pimgfile, "%s%s", Micdir, name);
---
>         read_string(instring,sizeof(instring));
>         phtodo = atoi(instring);
>         printf("%d \n",phtodo);
2796,2798c2683,2687
<   /***
<    *    Assign various physical properties of phases
<    ***/
---
>         if ((phtodo < 0) || (phtodo > NSPHASES)) {
>             freeallmem();
>             bailout("disrealnew","Bad ID for one-pixel particle");
>             exit(1);
>         }
2800c2689
<   assign_properties();
---
>         Onepixelbias[phtodo] = bias;
2802,2806c2691
<   fprintf(Logfile, "Enter fraction of C3A that is to be orthorhombic ");
<   fprintf(Logfile, "instead of cubic: ");
<   read_string(instring, sizeof(instring));
<   Oc3afrac = atof(instring);
<   fprintf(Logfile, "%f\n", Oc3afrac);
---
>         if (nadd > 0) addrand(phtodo,nadd,onepixfloc);
2808,2812c2693,2698
<   fprintf(Logfile,
<           "Enter number of seeds for CSH nucleation per um3 of mix water: ");
<   read_string(instring, sizeof(instring));
<   Csh_seeds = atof(instring);
<   fprintf(Logfile, "%f\n", Csh_seeds);
---
>         printf("Enter number of one pixel particles ");
>         printf("to add (-1 to quit) \n");
>         read_string(instring,sizeof(instring));
>         nadd = atoi(instring);
>         printf("%d\n",nadd);
>     }
2814,2818c2700
<   fprintf(Logfile, "Enter aging time in days: ");
<   read_string(instring, sizeof(instring));
<   End_time = atof(instring);
<   fprintf(Logfile, "\n%f \n", End_time);
<   End_time *= 24.0; /* Convert days to hours */
---
>     fflush(stdout);
2820,2825c2702,2704
<   fprintf(Logfile, "Place a crack (y or n)? [n] ");
<   read_string(answer, sizeof(answer));
<   fprintf(Logfile, "%s\n", answer);
<   if (strlen(answer) < 1) {
<     strcpy(answer, "n");
<   }
---
>     /***
>     *    Parameters for adiabatic temperature rise calculation
>     ***/
2827,2845c2706,2711
<   if (toupper(answer[0]) == 'Y') {
<     fprintf(Logfile, "\nEnter total crack width (in pixels): ");
<     read_string(instring, sizeof(instring));
<     Crackwidth = atoi(instring);
<     fprintf(Logfile, "%d", Crackwidth);
<     fprintf(Logfile, "\nEnter time at which to crack (in h): ");
<     read_string(instring, sizeof(instring));
<     Cracktime = atof(instring);
<     fprintf(Logfile, "%f", Cracktime);
<     fprintf(Logfile, "\nEnter orientation of crack as follows:");
<     fprintf(Logfile, "\n\t 1 = parallel to yz plane");
<     fprintf(Logfile, "\n\t 2 = parallel to xz plane");
<     fprintf(Logfile, "\n\t 3 = parallel to xy plane");
<     fprintf(Logfile, "\nOrientation: ");
<     read_string(instring, sizeof(instring));
<     Crackorient = atoi(instring);
<     if (Crackorient > 3)
<       Crackorient = 3;
<     fprintf(Logfile, "%d\n", Crackorient);
---
>     printf("Enter the initial temperature of binder ");
>     printf("in degrees Celsius \n");
>     read_string(instring,sizeof(instring));
>     Temp_0 = atof(instring);
>     printf("%f \n",Temp_0);
>     Temp_cur_b = Temp_0;
2847,2851c2713,2720
<   } else {
<     Crackwidth = 0;
<     Cracktime = -1.0;
<     Crackorient = 1;
<   }
---
>     printf("Hydration under 0) isothermal, 1) adiabatic ");
>     printf("or 2) programmed temperature history conditions \n");
>     read_string(instring,sizeof(instring));
>     Adiaflag = atoi(instring);
>     printf("%d \n",Adiaflag);
>     AggTempEffect = 1;
>     if ((Adiaflag == 0) || (Mass_agg * Cp_agg <= 0.0)
>             || (fabs(Temp_0_agg - Temp_0) < 0.5) || (U_coeff_agg <= 0.0)) AggTempEffect = 0;
2853,2859c2722,2726
<   fprintf(Logfile,
<           "Customize times for outputting microstructure (y or n)? [n] ");
<   read_string(answer, sizeof(answer));
<   fprintf(Logfile, "%s\n", answer);
<   if (strlen(answer) < 1) {
<     strcpy(answer, "n");
<   }
---
>     printf("Enter the ambient temperature ");
>     printf("in degrees Celsius \n");
>     read_string(instring,sizeof(instring));
>     T_ambient = atof(instring);
>     printf("%f \n",T_ambient);
2861,2873c2728,2732
<   if (toupper(answer[0]) == 'Y') {
<     Tcustomoutputentries = 0;
<     sprintf(custcycfile, "%scustomoutput.dat", WorkingDirectory);
<     fcofile = filehandler("disrealnew", custcycfile, "READ");
<     if (!fcofile) {
<       freeallmem();
<       exit(1);
<     }
<     while (!feof(fcofile)) {
<       fscanf(fcofile, "%s", buff);
<       if (!feof(fcofile))
<         Tcustomoutputentries++;
<     }
---
>     printf("Enter the overall heat transfer coefficient ");
>     printf("in J/g/C/s \n");
>     read_string(instring,sizeof(instring));
>     U_coeff = atof(instring);
>     printf("%f \n",U_coeff);
2875,2879c2734,2738
<     CustomImageTime = fvector(Tcustomoutputentries);
<     if (!CustomImageTime) {
<       freeallmem();
<       exit(1);
<     }
---
>     printf("Enter apparent activation energy for hydration ");
>     printf("in kJ/mole \n");
>     read_string(instring,sizeof(instring));
>     E_act = atof(instring);
>     printf("%f \n",E_act);
2881,2891c2740,2744
<     fclose(fcofile);
<     fcofile = filehandler("disrealnew", custcycfile, "READ");
<     if (!fcofile) {
<       freeallmem();
<       exit(1);
<     }
<     for (i = 0; i < Tcustomoutputentries; i++) {
<       fscanf(fcofile, "%s", buff);
<       CustomImageTime[i] = atof(buff);
<     }
<     fclose(fcofile);
---
>     printf("Enter apparent activation energy for pozzolanic ");
>     printf("reactions in kJ/mole \n");
>     read_string(instring,sizeof(instring));
>     E_act_pozz = atof(instring);
>     printf("%f \n",E_act_pozz);
2893,2899c2746,2750
<   } else {
<     CustomImageTime = NULL;
<     fprintf(Logfile, "Output hydrating microstructure every ____ hours: ");
<     read_string(instring, sizeof(instring));
<     OutTimefreq = atof(instring);
<     fprintf(Logfile, "\n%f\n", OutTimefreq);
<   }
---
>     printf("Enter apparent activation energy for slag ");
>     printf("reactions in kJ/mole \n");
>     read_string(instring,sizeof(instring));
>     E_act_slag = atof(instring);
>     printf("%f \n",E_act_slag);
2901,3049c2752,2767
<   /****
<    *    NOTE:  MUST READ
<    *            (1) SOFTWARE VERSION OF INPUT FILE (Version)
<    *            (1) SYSTEM SIZE (Xsyssize,Ysyssize,Zsyssize)
<    *            (2) SYSTEM RESOLUTION (Res)
<    *
<    *    Then set global variables Syspix, Sizemag, Isizemag
<    *    rather than hardwiring them as preprocessor
<    *    defines
<    ****/
< 
<   fimgfile = filehandler("disrealnew", imgfile, "READ");
<   if (!fimgfile) {
<     return (1);
<   }
< 
<   if (read_imgheader(fimgfile, &Version, &Xsyssize_orig, &Ysyssize_orig,
<                      &Zsyssize_orig, &Res)) {
<     fclose(fimgfile);
<     freeallmem();
<     bailout("disrealnew", "Error reading image header");
<     exit(1);
<   }
< 
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "\nDone reading image header...\n");
<     fprintf(Logfile, "\tVersion = %f\n", Version);
<     fprintf(Logfile, "\tX size = %d\n", Xsyssize_orig);
<     fprintf(Logfile, "\tY size = %d\n", Ysyssize_orig);
<     fprintf(Logfile, "\tZ size = %d\n", Ysyssize_orig);
<     fprintf(Logfile, "\tResolution = %f\n", Res);
<     fflush(Logfile);
<   }
< 
<   Xsyssize = Xsyssize_orig;
<   Ysyssize = Ysyssize_orig;
<   Zsyssize = Zsyssize_orig;
< 
<   Syspix = Xsyssize * Ysyssize * Zsyssize;
<   Syspix_orig = Syspix;
<   Sizemag = ((float)Syspix) / (pow(((double)(DEFAULTSYSTEMSIZE)), 3.0));
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "\nSizemag = %f", Sizemag);
<   Sizemag_orig = Sizemag;
<   Isizemag = (int)(Sizemag + 0.5);
<   Isizemag_orig = Isizemag;
< 
<   if (Crackorient == 1)
<     Xsyssize += Crackwidth;
<   if (Crackorient == 2)
<     Ysyssize += Crackwidth;
<   if (Crackorient == 3)
<     Zsyssize += Crackwidth;
< 
<   /***
<    *    Must now allocate the memory for all the 3D arrays
<    *    (See disrealnew.h for their declaration)
<    ***/
< 
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\tAllocating Mic with dimensions %d %d %d...", Xsyssize,
<             Ysyssize, Zsyssize);
<   Mic = cbox(Xsyssize, Ysyssize, Zsyssize);
<   if (!Mic) {
<     freeallmem();
<     fclose(fimgfile);
<     bailout("disrealnew", "Could not allocate memory for Mic array");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Micorig ...");
< 
<   Micorig = cbox(Xsyssize, Ysyssize, Zsyssize);
<   if (!Micorig) {
<     freeallmem();
<     fclose(fimgfile);
<     bailout("disrealnew", "Could not allocate memory for Micorig array");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Micpart ...");
< 
<   Micpart = sibox(Xsyssize, Ysyssize, Zsyssize);
<   if (!Micpart) {
<     freeallmem();
<     fclose(fimgfile);
<     bailout("disrealnew", "Could not allocate memory for Micpart array");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Cshage ...");
< 
<   Cshage = sibox(Xsyssize, Ysyssize, Zsyssize);
<   if (!Cshage) {
<     freeallmem();
<     fclose(fimgfile);
<     bailout("disrealnew", "Could not allocate memory for Cshage array");
<     return (1);
<   }
<   if (Verbose_flag > 2)
<     fprintf(Logfile, " done\n\tAllocating Deactivated ...");
< 
<   Deactivated = sibox(Xsyssize, Ysyssize, Zsyssize);
<   if (!Deactivated) {
<     fclose(fimgfile);
<     freeallmem();
<     bailout("disrealnew", "Could not allocate memory for Deactivated array");
<     return (1);
<   }
<   if (Verbose_flag > 1)
<     fprintf(Logfile, " done\n");
< 
<   Cshscale = CSHSCALE * Sizemag;
<   C3ah6_scale = C3AH6_SCALE * Sizemag;
< 
<   /***
<    *    Adjust the maximum number of diffusion steps
<    *    per cycle based on system resolution.  That is,
<    *    if each step is 0.5 microns instead of 1.0 microns
<    *    and we want the same RMS distance to be achieved
<    *    in a cycle, then we need (1/0.5)^2 the steps we
<    *    had originally
<    ***/
< 
<   Maxdiffsteps = MAXDIFFSTEPS / (Res * Res);
< 
<   /****************************************/
< 
<   /***
<    *    Reset Xsyssize, Ysyssize, and Zsyssize back to
<    *    the original system size until the microstructure
<    *    actually cracks
<    ***/
< 
<   Xsyssize = Xsyssize_orig;
<   Ysyssize = Ysyssize_orig;
<   Zsyssize = Zsyssize_orig;
< 
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "\nPreparing to read image file ...");
<   for (ix = 0; ix < Xsyssize; ix++) {
<     for (iy = 0; iy < Ysyssize; iy++) {
<       for (iz = 0; iz < Zsyssize; iz++) {
< 
<         Cshage[ix][iy][iz] = 0;
<         Deactivated[ix][iy][iz] = 1;
<         fscanf(fimgfile, "%s", instring);
<         ovalin = atoi(instring);
<         valin = convert_id(ovalin, Version);
---
>     printf("Calibrate time using beta factor (0), ");
>     printf("early-age calorimetry data (1), or ");
>     printf("early-age chemical shrinkage data (2): ");
>     read_string(instring,sizeof(instring));
>     TimeCalibrationMethod = atoi(instring);
>     if (TimeCalibrationMethod == BETAFACTOR) {
>         printf("\nEnter kinetic factor to convert cycles ");
>         printf("to time at 25 C \n");
>         read_string(instring,sizeof(instring));
>         Beta = atof(instring);
>         printf("%f \n",Beta);
>     } else {
>         printf("\nEnter file name for early-age data: ");
>         read_string(name,sizeof(name));
>         printf("\n%s \n",name);
>         sprintf(calfilename,"%s",name);
3052c2770,2773
<          * Check if C3A needs to be converted to orthorhombic
---
>          *  At this point, the isothermal calorimetry file
>          *  must have data taken
>          *  AT 25 degrees C.  We will correct the time scale using the
>          *  user-supplied activation energy for hydration
3055,3059c2776,2782
<         if (valin == C3A) {
<           pc3a = ran1(Seed);
<           if (pc3a < Oc3afrac) {
<             valin = OC3A;
<           }
---
>         fcalfile=filehandler("disrealnew",calfilename,"READ");
>         if (!fcalfile) {
>             freeallmem();
>             sprintf(buff,"Could not open time calibration ");
>             sprintf(buff,"file %s",calfilename);
>             bailout("disrealnew",buff);
>             return(1);
3061d2783
<         Mic[ix][iy][iz] = valin;
3063c2785,2791
<         Micorig[ix][iy][iz] = Mic[ix][iy][iz];
---
>         /***
>          * The calorimetry file must be two-column ASCII text file.
>          * First column must be time in hours, second column must
>          * be CUMULATIVE heat in J per gram of CEMENT initially.
>          * There must be a header line, but it does not matter
>          * what is on it.
>          ***/
3065,3067c2793,2796
<       } /* End of loop in iz */
<     } /* End of loop in iy */
<   } /* End of loop in ix */
---
>         NDataLines = 0;
>         do {
>             ch = getc(fcalfile);
>         } while (ch != '\n' && !feof(fcalfile));
3069,3071c2798,2801
<   fclose(fimgfile);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, " done\n");
---
>         while (!feof(fcalfile)) {
>             fscanf(fcalfile,"%s %s",buff1,buff2);
>             if (!feof(fcalfile)) NDataLines++;
>         }
3073c2803,2809
<   /* Now read in particle IDs from file */
---
>         if (NDataLines == 0) {
>             freeallmem();
>             sprintf(buff,"Calibration file ended ");
>             sprintf(buff,"prematurely: %s",calfilename);
>             bailout("disrealnew",buff);
>             return(1);
>         }
3075,3081c2811,2814
<   fpimgfile = filehandler("disrealnew", pimgfile, "READ");
<   if (!fpimgfile) {
<     fprintf(Logfile, "\nCould not open fpimgfile: %s. Exiting ...", pimgfile);
<     fflush(Logfile);
<     freeallmem();
<     exit(1);
<   }
---
>         /***
>          * Allocate memory for storing calibration data in DataTime
>          * and DataValue vectors.
>          ***/
3083,3087c2816,2823
<   /***
<    *    As before, must either read in the first
<    *    two lines of size and resolution
<    *    information ...
<    ***/
---
>         DataTime = fvector(NDataLines);
>         if (!DataTime) {
>             freeallmem();
>             fclose(fcalfile);
>             bailout("disrealnew",
>                     "Could not allocate memory for DataTime array");
>             return(1);
>         }
3089,3097c2825,2832
<   if (read_imgheader(fpimgfile, &newver, &newx, &newy, &newz, &newres)) {
<     fprintf(Logfile, "\nTrouble reading header of fpimgfile: %s. Exiting ...",
<             pimgfile);
<     fflush(Logfile);
<     fclose(fpimgfile);
<     freeallmem();
<     bailout("disrealnew", "Error reading image header");
<     exit(1);
<   }
---
>         DataValue = fvector(NDataLines);
>         if (!DataValue) {
>             freeallmem();
>             fclose(fcalfile);
>             bailout("disrealnew",
>                     "Could not allocate memory for DataValue array");
>             return(1);
>         }
3099,3101c2834,2836
<   for (ix = 0; ix < Xsyssize; ix++) {
<     for (iy = 0; iy < Ysyssize; iy++) {
<       for (iz = 0; iz < Zsyssize; iz++) {
---
>         /***
>          * Now go back and read the data into the DataTime and DataValue vectors
>          ***/
3103,3106c2838,2870
<         fscanf(fpimgfile, "%s", instring);
<         valin = atoi(instring);
<         Micpart[ix][iy][iz] = valin;
<       }
---
>         rewind(fcalfile);
>         do {
>             ch = getc(fcalfile);
>         } while (ch != '\n' && !feof(fcalfile));
> 
>         i = 0;
>         if (Verbose) printf("\nNDataLines = %d",NDataLines);
>         while ((i < NDataLines) && !feof(fcalfile)) {
>             fscanf(fcalfile,"%s %s",buff1,buff2);
>             if (i == 0) {
>                 DataTime[i] = atof(buff1);
>                 DataValue[i] = atof(buff2);
>                 if (Verbose) {
>                     printf("\nDataTime[%d] = %f, ",i,DataTime[i]);
>                     printf("DataValue[%d] = %f\n",i,DataValue[i]);
>                 }
>                 i++;
>             } else {
>                 DataTime[i] = atof(buff1);
>                 DataValue[i] = atof(buff2);
>                 if ((DataTime[i] > DataTime[i-1])
>                      && (DataValue[i] >= DataValue[i-1])) i++;
>             }
>         }
> 
>         NDataLines = i;
> 
>         fclose(fcalfile);
>         printf("Enter temperature at which calibration data ");
>         printf("were obtained (in deg C): ");
>         read_string(buff,sizeof(buff));
>         printf("%s \n",buff);
>         DataMeasuredAtTemperature = atof(buff);
3108d2871
<   }
3110c2873
<   fclose(fpimgfile);
---
>     /* Have enough information to calculate upper bound on number of cycles */
3112,3123c2875,2882
<   if (Version != newver) {
<     fprintf(Logfile, "WARNING: Some files were created with differing\n");
<     fprintf(Logfile, "\tVCCTL software versions.  This may create a");
<     fprintf(Logfile, "\tconflict.");
<   }
<   if (Xsyssize != newx) {
<     fprintf(Logfile, "Xsyssize = %d, New x size = %d", Xsyssize, newx);
<     fflush(Logfile);
<     freeallmem();
<     bailout("disrealnew", "Incompatible size declarations");
<     exit(1);
<   }
---
>     if (TimeCalibrationMethod == BETAFACTOR) {
>         b_estimate = Beta * exp((1000.0 * E_act/8.314)*((1.0/(Temp_0 + 273.15)) - (1.0/298.15)));
>         Ncyc = (int)((2.0 * sqrt(End_time/b_estimate)) + 0.5);
>     } else {
>         /* No way to estimate Ncyc rationally, so set it to a very large value and be
>          * prepared to allocate more memory as needed */
>         Ncyc = 10000;
>     }
3125,3132c2884,2890
<   if (Ysyssize != newy) {
<     fprintf(Logfile, "Ysyssize = %d, New y size = %d", Ysyssize, newy);
<     fflush(Logfile);
<     freeallmem();
<     fprintf(Logfile, "Ysyssize = %d, New y size = %d", Ysyssize, newy);
<     bailout("disrealnew", "Incompatible size declarations");
<     exit(1);
<   }
---
>     if (Crackwidth == 0) Cracktime = End_time + 100.0;
>     if (CustomImageTime != NULL) {
>         OutTimefreq = End_time + 1.0;
>         printf("\nSetting DOH frequency for outputting ");
>         printf("microstructure = %f\n",OutTimefreq);
>         fflush(stdout);
>     }
3134,3140c2892,2896
<   if (Zsyssize != newz) {
<     fprintf(Logfile, "Zsyssize = %d, New y size = %d", Ysyssize, newy);
<     fflush(Logfile);
<     freeallmem();
<     bailout("disrealnew", "Incompatible size declarations");
<     exit(1);
<   }
---
>     /***
>     *    Allocate memory for Time_cur, Molarvcsh, and Watercsh, which
>     *    hold the time-dependent values of the molar volumes
>     *    and water content of CSH
>     ***/
3142,3150c2898,2905
<   /***
<    *    Allow user to iteratively add one-pixel
<    *    particles of various phases.
<    *
<    *    VCCTL software adds the one-pixel particles at the
<    *    microstructure creation stage rather than here, but
<    *    we keep this structure in place for possible manual
<    *    addition of one-pixel particles by the user.
<    ***/
---
>     TimeHistory = fvector(Ncyc);
>     if (!TimeHistory) {
>         freeallmem();
>         bailout("disrealnew",
>                 "Could not allocate memory for TimeHistory array");
>         exit(1);
>     }
>     TimeHistory[0] = 0.0;
3152,3157c2907,2913
<   fprintf(Logfile,
<           "Enter number of one pixel particles to add (-1 to quit) \n");
<   fflush(Logfile);
<   read_string(instring, sizeof(instring));
<   nadd = atoi(instring);
<   fprintf(Logfile, "%d\n", nadd);
---
>     Molarvcsh = fvector(Ncyc);
>     if (!Molarvcsh) {
>         freeallmem();
>         bailout("disrealnew",
>                 "Could not allocate memory for Molarvcsh array");
>         exit(1);
>     }
3159c2915,2921
<   while (nadd >= 0) {
---
>     Watercsh = fvector(Ncyc);
>     if (!Watercsh) {
>         freeallmem();
>         bailout("disrealnew",
>                 "Could not allocate memory for Watercsh array");
>         exit(1);
>     }
3161,3164c2923,2924
<     onepixfloc = 0; /* No flocculation of one-pixel particles */
<     /*
<     fprintf(Logfile,"Should these particles flocculate ");
<     fprintf(Logfile,"to surfaces? No (0) or Yes (1): ");
---
>     printf("Enter maximum degree of hydration to achieve ");
>     printf("before terminating \n");
3166,3167c2926,2927
<     onepixfloc = atoi(instring);
<     */
---
>     Alpha_max = atof(instring);
>     printf("%f \n",Alpha_max);
3169,3172c2929,2933
<     fprintf(Logfile, "Enter dissolution bias for these one pixel particles\n");
<     read_string(instring, sizeof(instring));
<     bias = atof(instring);
<     fprintf(Logfile, "%f\n", bias);
---
>     printf("Do you wish hydration under 0) saturated ");
>     printf("or 1) sealed conditions \n");
>     read_string(instring,sizeof(instring));
>     Sealed = atoi(instring);
>     printf("%d \n",Sealed);
3174,3205c2935,2940
<     fprintf(Logfile, "Enter phase to add \n");
<     if (Verbose_flag > 1) {
<       fprintf(Logfile, "\tC3S %d\n", C3S);
<       fprintf(Logfile, "\tC2S %d\n", C2S);
<       fprintf(Logfile, "\tC3A %d\n", C3A);
<       fprintf(Logfile, "\tC4AF %d\n", C4AF);
<       fprintf(Logfile, "\tGYPSUM %d\n", GYPSUM);
<       fprintf(Logfile, "\tHEMIHYD %d\n", HEMIHYD);
<       fprintf(Logfile, "\tANHYDRITE %d\n", ANHYDRITE);
<       fprintf(Logfile, "\tSILICA FUME %d\n", SFUME);
<       fprintf(Logfile, "\tINERT %d\n", INERT);
<       fprintf(Logfile, "\tSLAG %d\n", SLAG);
<       fprintf(Logfile, "\tASG %d\n", ASG);
<       fprintf(Logfile, "\tCAS2 %d\n", CAS2);
<       fprintf(Logfile, "\tAMORPHOUS SILICA %d\n", AMSIL);
<       fprintf(Logfile, "\tCH %d\n", CH);
<       fprintf(Logfile, "\tCSH %d\n", CSH);
<       fprintf(Logfile, "\tC3AH6 %d\n", C3AH6);
<       fprintf(Logfile, "\tEttringite %d\n", ETTR);
<       fprintf(Logfile, "\tStable Ettringite from C4AF %d\n", ETTRC4AF);
<       fprintf(Logfile, "\tAFM %d\n", AFM);
<       fprintf(Logfile, "\tFH3 %d\n", FH3);
<       fprintf(Logfile, "\tPOZZCSH %d\n", POZZCSH);
<       fprintf(Logfile, "\tSLAGCSH %d\n", SLAGCSH);
<       fprintf(Logfile, "\tCACL2 %d\n", CACL2);
<       fprintf(Logfile, "\tFriedels salt %d\n", FRIEDEL);
<       fprintf(Logfile, "\tStratlingite %d\n", STRAT);
<       fprintf(Logfile, "\tCalcium carbonate %d\n", CACO3);
<       fprintf(Logfile, "\tAFmc %d\n", AFMC);
<       fprintf(Logfile, "\tBrucite %d\n", BRUCITE);
<       fprintf(Logfile, "\tMS %d\n", MS);
<       fprintf(Logfile, "\tFree Lime %d\n", FREELIME);
---
>     Sealed_after_crack = Sealed;
> 
>     *pscalech *= Sizemag;
>     if (Verbose) {
>         printf("Nuc. prob. and scale factor for CH nucleation \n");
>         printf("%f %f \n",*pnucch,*pscalech);
3208,3210c2943,2947
<     read_string(instring, sizeof(instring));
<     phtodo = atoi(instring);
<     fprintf(Logfile, "%d \n", phtodo);
---
>     *pscalegyp *= Sizemag;
>     if (Verbose) {
>         printf("Nuc. prob. and scale factor for gypsum nucleation \n");
>         printf("%f %f \n",*pnucgyp,*pscalegyp);
>     }
3212,3215c2949,2952
<     if ((phtodo < 0) || (phtodo > NSPHASES)) {
<       freeallmem();
<       bailout("disrealnew", "Bad ID for one-pixel particle");
<       exit(1);
---
>     *pscalehg *= Sizemag;
>     if (Verbose) {
>         printf("Nuc. prob. and scale factor for C3AH6 nucleation \n");
>         printf("%f %f \n",*pnuchg,*pscalehg);
3218c2955,2959
<     Onepixelbias[phtodo] = bias;
---
>     *pscalefh3 *= Sizemag;
>     if (Verbose) {
>         printf("Nuc. prob. and scale factor for FH3 nucleation \n");
>         printf("%f %f \n",*pnucfh3,*pscalefh3);
>     }
3220,3221c2961,2965
<     if (nadd > 0)
<       addrand(phtodo, nadd, onepixfloc);
---
>     printf("Enter time frequency for checking pore ");
>     printf("space percolation (in h): ");
>     read_string(instring,sizeof(instring));
>     Burntimefreq = atof(instring);
>     printf("\n%f\n",Burntimefreq);
3223,3228c2967,2971
<     fprintf(Logfile, "Enter number of one pixel particles ");
<     fprintf(Logfile, "to add (-1 to quit) \n");
<     read_string(instring, sizeof(instring));
<     nadd = atoi(instring);
<     fprintf(Logfile, "%d\n", nadd);
<   }
---
>     printf("Enter time frequency for checking percolation ");
>     printf("of solids (set) (in h): ");
>     read_string(instring,sizeof(instring));
>     Settimefreq = atof(instring);
>     printf("\n%f\n",Settimefreq);
3230c2973,2977
<   fflush(Logfile);
---
>     printf("Enter time frequency for checking hydration ");
>     printf("of particles (in h): ");
>     read_string(instring,sizeof(instring));
>     Phydtimefreq = atof(instring);
>     printf("\n%f\n",Phydtimefreq);
3232,3234c2979,2982
<   /***
<    *    Parameters for adiabatic temperature rise calculation
<    ***/
---
>     printf("Enter mass fraction of aggregate in concrete \n");
>     read_string(buff,sizeof(buff));
>     printf("%s \n",buff);
>     Mass_agg = (double)(atof(buff));
3236,3241c2984,2988
<   fprintf(Logfile, "Enter the initial temperature of binder ");
<   fprintf(Logfile, "in degrees Celsius \n");
<   read_string(instring, sizeof(instring));
<   Temp_0 = atof(instring);
<   fprintf(Logfile, "%f \n", Temp_0);
<   Temp_cur_b = Temp_0;
---
>     printf("Enter initial temperature of aggregate in concrete \n");
>     read_string(instring,sizeof(instring));
>     Temp_0_agg = atof(instring);
>     printf("%f \n",Temp_0_agg);
>     Temp_cur_agg = Temp_0_agg;
3243,3251c2990,2993
<   fprintf(Logfile, "Hydration under 0) isothermal, 1) adiabatic ");
<   fprintf(Logfile, "or 2) programmed temperature history conditions \n");
<   read_string(instring, sizeof(instring));
<   Adiaflag = atoi(instring);
<   fprintf(Logfile, "%d \n", Adiaflag);
<   AggTempEffect = 1;
<   if ((Adiaflag == 0) || (Mass_agg * Cp_agg <= 0.0) ||
<       (fabs(Temp_0_agg - Temp_0) < 0.5) || (U_coeff_agg <= 0.0))
<     AggTempEffect = 0;
---
>     printf("Enter heat transfer coefficient between aggregate and binder \n");
>     read_string(instring,sizeof(instring));
>     U_coeff_agg = atof(instring);
>     printf("%f \n",U_coeff_agg);
3253,3257c2995,2998
<   fprintf(Logfile, "Enter the ambient temperature ");
<   fprintf(Logfile, "in degrees Celsius \n");
<   read_string(instring, sizeof(instring));
<   T_ambient = atof(instring);
<   fprintf(Logfile, "%f \n", T_ambient);
---
>     printf("CSH to pozzolanic CSH 0) prohibited or 1) allowed \n");
>     read_string(instring,sizeof(instring));
>     Csh2flag = atoi(instring);
>     printf("%d \n",Csh2flag);
3259,3263c3000,3004
<   fprintf(Logfile, "Enter the overall heat transfer coefficient ");
<   fprintf(Logfile, "in J/g/C/s \n");
<   read_string(instring, sizeof(instring));
<   U_coeff = atof(instring);
<   fprintf(Logfile, "%f \n", U_coeff);
---
>     printf("CH precipitation on aggregate surfaces ");
>     printf("0) prohibited or 1) allowed \n");
>     read_string(instring,sizeof(instring));
>     Chflag = atoi(instring);
>     printf("%d \n",Chflag);
3265,3269c3006,3011
<   fprintf(Logfile, "Enter apparent activation energy for hydration ");
<   fprintf(Logfile, "in kJ/mole \n");
<   read_string(instring, sizeof(instring));
<   E_act = atof(instring);
<   fprintf(Logfile, "%f \n", E_act);
---
>     printf("Output hydration movie frame every ____ hours: ");
>     read_string(instring,sizeof(instring));
>     MovieFrameFreq = atof(instring);
>     if (MovieFrameFreq > End_time) MovieFrameFreq = End_time + 1.0;
>     if (MovieFrameFreq <= 0.0) MovieFrameFreq = End_time + 1.0;
>     printf("\n%f \n",MovieFrameFreq);
3271,3313c3013,3016
<   fprintf(Logfile, "Enter apparent activation energy for pozzolanic ");
<   fprintf(Logfile, "reactions in kJ/mole \n");
<   read_string(instring, sizeof(instring));
<   E_act_pozz = atof(instring);
<   fprintf(Logfile, "%f \n", E_act_pozz);
< 
<   fprintf(Logfile, "Enter apparent activation energy for slag ");
<   fprintf(Logfile, "reactions in kJ/mole \n");
<   read_string(instring, sizeof(instring));
<   E_act_slag = atof(instring);
<   fprintf(Logfile, "%f \n", E_act_slag);
< 
<   fprintf(Logfile, "Calibrate time using beta factor (0), ");
<   fprintf(Logfile, "early-age calorimetry data (1), or ");
<   fprintf(Logfile, "early-age chemical shrinkage data (2): ");
<   read_string(instring, sizeof(instring));
<   TimeCalibrationMethod = atoi(instring);
<   if (TimeCalibrationMethod == BETAFACTOR) {
<     fprintf(Logfile, "\nEnter kinetic factor to convert cycles ");
<     fprintf(Logfile, "to time at 25 C \n");
<     read_string(instring, sizeof(instring));
<     Beta = atof(instring);
<     fprintf(Logfile, "%f \n", Beta);
<   } else {
<     fprintf(Logfile, "\nEnter file name for early-age data: ");
<     read_string(name, sizeof(name));
<     fprintf(Logfile, "\n%s \n", name);
<     sprintf(calfilename, "%s", name);
< 
<     /***
<      *  At this point, the isothermal calorimetry file
<      *  must have data taken
<      *  AT 25 degrees C.  We will correct the time scale using the
<      *  user-supplied activation energy for hydration
<      ***/
< 
<     fcalfile = filehandler("disrealnew", calfilename, "READ");
<     if (!fcalfile) {
<       freeallmem();
<       sprintf(buff, "Could not open time calibration ");
<       sprintf(buff, "file %s", calfilename);
<       bailout("disrealnew", buff);
<       return (1);
---
>     *nmovstep = 1;
>     if ((MovieFrameFreq > 0.0) && (MovieFrameFreq < 1.0)) {
>         *nmovstep = (int)(End_time / MovieFrameFreq);
>         if (*nmovstep < 1) *nmovstep = 1;
3317,3322c3020,3024
<      * The calorimetry file must be two-column ASCII text file.
<      * First column must be time in hours, second column must
<      * be CUMULATIVE heat in J per gram of CEMENT initially.
<      * There must be a header line, but it does not matter
<      * what is on it.
<      ***/
---
>     *    Allow user to iteratively specify surface
>     *    deactivation parameters for particles of various
>     *    phases.  First initialize all the deactivation
>     *    arrays to zero, and then gather the information
>     ***/
3324,3332c3026,3034
<     NDataLines = 0;
<     do {
<       ch = getc(fcalfile);
<     } while (ch != '\n' && !feof(fcalfile));
< 
<     while (!feof(fcalfile)) {
<       fscanf(fcalfile, "%s %s", buff1, buff2);
<       if (!feof(fcalfile))
<         NDataLines++;
---
>     for (i = 0; i <= NSPHASES; i++) {
>         Deactfrac[i] = 0.0;
>         Reactfrac[i] = 0.0;
>         Deactinit[i] = 0;
>         Deactends[i] = 0;
>         Deactterm[i] = 0;
>         Deactphaselist[i] = 0;
>         Startflag[i] = 0;
>         Stopflag[i] = 0;
3335,3341c3037,3040
<     if (NDataLines == 0) {
<       freeallmem();
<       sprintf(buff, "Calibration file ended ");
<       sprintf(buff, "prematurely: %s", calfilename);
<       bailout("disrealnew", buff);
<       return (1);
<     }
---
>     printf("Enter phase id of surface to deactivate (-1 to quit) \n");
>     read_string(instring,sizeof(instring));
>     dphase = atoi(instring);
>     printf("%d\n",dphase);
3343,3346c3042,3044
<     /***
<      * Allocate memory for storing calibration data in DataTime
<      * and DataValue vectors.
<      ***/
---
>     Numdeact = 0;
>     while (dphase != -1) {
>         deactphase = dphase;
3348,3354c3046,3050
<     DataTime = fvector(NDataLines);
<     if (!DataTime) {
<       freeallmem();
<       fclose(fcalfile);
<       bailout("disrealnew", "Could not allocate memory for DataTime array");
<       return (1);
<     }
---
>         printf("Enter fraction of surface to deactivate \n");
>         read_string(instring,sizeof(instring));
>         dfrac = atof(instring);
>         printf("%f\n",dfrac);
>         Deactfrac[deactphase] = dfrac;
3356,3362c3052,3053
<     DataValue = fvector(NDataLines);
<     if (!DataValue) {
<       freeallmem();
<       fclose(fcalfile);
<       bailout("disrealnew", "Could not allocate memory for DataValue array");
<       return (1);
<     }
---
>         Deactphaselist[Numdeact] = deactphase;
>         Numdeact++;
3364,3383c3055,3058
<     /***
<      * Now go back and read the data into the DataTime and DataValue vectors
<      ***/
< 
<     rewind(fcalfile);
<     do {
<       ch = getc(fcalfile);
<     } while (ch != '\n' && !feof(fcalfile));
< 
<     i = 0;
<     if (Verbose_flag > 1)
<       fprintf(Logfile, "\nNDataLines = %d", NDataLines);
<     while ((i < NDataLines) && !feof(fcalfile)) {
<       fscanf(fcalfile, "%s %s", buff1, buff2);
<       if (i == 0) {
<         DataTime[i] = atof(buff1);
<         DataValue[i] = atof(buff2);
<         if (Verbose_flag > 1) {
<           fprintf(Logfile, "\nDataTime[%d] = %f, ", i, DataTime[i]);
<           fprintf(Logfile, "DataValue[%d] = %f\n", i, DataValue[i]);
---
>         if ((deactphase < C3S) || (deactphase > NSPHASES)) {
>             freeallmem();
>             bailout("disrealnew","Bad ID for deactivated phase");
>             exit(1);
3385,3393d3059
<         i++;
<       } else {
<         DataTime[i] = atof(buff1);
<         DataValue[i] = atof(buff2);
<         if ((DataTime[i] > DataTime[i - 1]) &&
<             (DataValue[i] >= DataValue[i - 1]))
<           i++;
<       }
<     }
3395,3403c3061,3064
<     NDataLines = i;
< 
<     fclose(fcalfile);
<     fprintf(Logfile, "Enter temperature at which calibration data ");
<     fprintf(Logfile, "were obtained (in deg C): ");
<     read_string(buff, sizeof(buff));
<     fprintf(Logfile, "%s \n", buff);
<     DataMeasuredAtTemperature = atof(buff);
<   }
---
>         printf("Time to implement deactivation (in hours)\n");
>         read_string(instring,sizeof(instring));
>         Deactinit[deactphase] = atof(instring);
>         printf("%f\n",Deactinit[deactphase]);
3405c3066,3070
<   /* Have enough information to calculate upper bound on number of cycles */
---
>         printf("Time to begin reactivation (in hours)\n");
>         read_string(instring,sizeof(instring));
>         dends = atof(instring);
>         printf("%f\n",dends);
>         Deactends[deactphase] = dends;
3407,3415c3072,3076
<   if (TimeCalibrationMethod == BETAFACTOR) {
<     b_estimate = Beta * exp((1000.0 * E_act / 8.314) *
<                             ((1.0 / (Temp_0 + 273.15)) - (1.0 / 298.15)));
<     Ncyc = (int)((2.0 * sqrt(End_time / b_estimate)) + 0.5);
<   } else {
<     /* No way to estimate Ncyc rationally, so set it to a very large value and
<      * be prepared to allocate more memory as needed */
<     Ncyc = 10000;
<   }
---
>         printf("Time of full reactivation (in hours)\n");
>         read_string(instring,sizeof(instring));
>         dterm = atof(instring);
>         printf("%f\n",dterm);
>         Deactterm[deactphase] = dterm;
3417,3424c3078,3082
<   if (Crackwidth == 0)
<     Cracktime = End_time + 100.0;
<   if (CustomImageTime != NULL) {
<     OutTimefreq = End_time + 1.0;
<     fprintf(Logfile, "\nSetting DOH frequency for outputting ");
<     fprintf(Logfile, "microstructure = %f\n", OutTimefreq);
<     fflush(Logfile);
<   }
---
>         if(dterm == dends) {
>             Reactfrac[deactphase] = 1.0;
>         } else {
>             Reactfrac[deactphase] = 1.0/(dterm - dends + 1);
>         }
3426,3430c3084,3087
<   /***
<    *    Allocate memory for Time_cur, Molarvcsh, and Watercsh, which
<    *    hold the time-dependent values of the molar volumes
<    *    and water content of CSH
<    ***/
---
>         printf("Enter phase id of surface to deactivate (-1 to quit) \n");
>         read_string(instring,sizeof(instring));
>         dphase = atoi(instring);
>         printf("%d\n",dphase);
3432,3438c3089
<   TimeHistory = fvector(Ncyc);
<   if (!TimeHistory) {
<     freeallmem();
<     bailout("disrealnew", "Could not allocate memory for TimeHistory array");
<     exit(1);
<   }
<   TimeHistory[0] = 0.0;
---
>     }
3440,3445c3091,3095
<   Molarvcsh = fvector(Ncyc);
<   if (!Molarvcsh) {
<     freeallmem();
<     bailout("disrealnew", "Could not allocate memory for Molarvcsh array");
<     exit(1);
<   }
---
>     printf("Does pH influence hydration kinetics ");
>     printf("0) no or 1) yes \n");
>     read_string(instring,sizeof(instring));
>     PHactive = atoi(instring);
>     printf("%d\n",PHactive);
3447,3452c3097,3105
<   Watercsh = fvector(Ncyc);
<   if (!Watercsh) {
<     freeallmem();
<     bailout("disrealnew", "Could not allocate memory for Watercsh array");
<     exit(1);
<   }
---
>     /***
>     *    Set possibility of topochemical conversion of silicates
>     *    to CSH if pH effect is active, and also set the proximity
>     *    within which dissolved silicates are placed relative to the
>     *    dissolution source, to simulate the higher-density CSH
>     *    that is thought to form in the presence of alkalies
>     *    (see Juenger and Jennings, ACI Materials Journal,
>     *    Vol. 98, No. 3, pp. 251-255 (2001).
>     ***/
3454,3458c3107,3109
<   fprintf(Logfile, "Enter maximum degree of hydration to achieve ");
<   fprintf(Logfile, "before terminating \n");
<   read_string(instring, sizeof(instring));
<   Alpha_max = atof(instring);
<   fprintf(Logfile, "%f \n", Alpha_max);
---
>     fflush(stdout);
>     return(status);
> }
3460,3464c3111,3129
<   fprintf(Logfile, "Do you wish hydration under 0) saturated ");
<   fprintf(Logfile, "or 1) sealed conditions \n");
<   read_string(instring, sizeof(instring));
<   Sealed = atoi(instring);
<   fprintf(Logfile, "%d \n", Sealed);
---
> /***
> *    init
> *
> *     Initialize values for solubilities, pH effect, etc.
> *
> *     Arguments:    none
> *     Returns:    nothing
> *
> *    Calls:        no routines
> *    Called by:    main program
> ***/
> void init(void)
> {
>     int i,k,x,y;
>     float xv1,xv2,xv3,yv1,yv2,yv3;
>     float chperslag,poreperslag;
>     float resfact;
>     char buff[MAXSTRING],instring[MAXSTRING];
>     FILE *slagfile,*alkalifile;
3466c3131,3134
<   Sealed_after_crack = Sealed;
---
>     Ngoing = 0;
>     Porefl1 = Porefl2 = Porefl3 = 1;
>     Pore_off = Water_off = 0;
>     Heat_old = Heat_new = 0.0;
3468,3472c3136
<   *pscalech *= Sizemag;
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "Nuc. prob. and scale factor for CH nucleation \n");
<     fprintf(Logfile, "%f %f \n", *pnucch, *pscalech);
<   }
---
>     /* Current and previous cycle CH counts */
3474,3478c3138
<   *pscalegyp *= Sizemag;
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "Nuc. prob. and scale factor for gypsum nucleation \n");
<     fprintf(Logfile, "%f %f \n", *pnucgyp, *pscalegyp);
<   }
---
>     Chold = Chnew = 0;
3480,3484c3140
<   *pscalehg *= Sizemag;
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "Nuc. prob. and scale factor for C3AH6 nucleation \n");
<     fprintf(Logfile, "%f %f \n", *pnuchg, *pscalehg);
<   }
---
>     /* Elapsed time according to maturity principles */
3486,3490c3142,3143
<   *pscalefh3 *= Sizemag;
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "Nuc. prob. and scale factor for FH3 nucleation \n");
<     fprintf(Logfile, "%f %f \n", *pnucfh3, *pscalefh3);
<   }
---
>     Time_cur = 0.0;
>     Poregone = Poretodo = 0;
3492,3496c3145
<   fprintf(Logfile, "Enter time frequency for checking pore ");
<   fprintf(Logfile, "space percolation (in h): ");
<   read_string(instring, sizeof(instring));
<   Burntimefreq = atof(instring);
<   fprintf(Logfile, "\n%f\n", Burntimefreq);
---
>     /* Initialize counters, etc. */
3498,3502c3147,3156
<   fprintf(Logfile, "Enter time frequency for checking percolation ");
<   fprintf(Logfile, "of solids (set) (in h): ");
<   read_string(instring, sizeof(instring));
<   Settimefreq = atof(instring);
<   fprintf(Logfile, "\n%f\n", Settimefreq);
---
>     Nsilica_rx = Nasr = Nslagr = 0;
>     Nsilica = 0;
>     Ncsbar = 0;
>     Netbar = 0;
>     Porinit = 0;
>     Cyccnt = 0;
>     Setflag = 0;
>     C3sinit = C2sinit = C3ainit = C4afinit = Crackpinit = 0;
>     Anhinit = Heminit = Slaginit = Freelimeinit = 0;
>     Nasulfinit = Ksulfinit = 0;
3504,3508c3158
<   fprintf(Logfile, "Enter time frequency for checking hydration ");
<   fprintf(Logfile, "of particles (in h): ");
<   read_string(instring, sizeof(instring));
<   Phydtimefreq = atof(instring);
<   fprintf(Logfile, "\n%f\n", Phydtimefreq);
---
>     /* Initialize structure for Ants */
3510,3513c3160,3165
<   fprintf(Logfile, "Enter mass fraction of aggregate in concrete \n");
<   read_string(buff, sizeof(buff));
<   fprintf(Logfile, "%s \n", buff);
<   Mass_agg = (double)(atof(buff));
---
>     Headant = (struct Ants *)malloc(Antsize);
>     Headant->prevant = NULL;
>     Headant->nextant = NULL;
>     Headant->x = 0;
>     Headant->y = 0;
>     Headant->z = 0;
3515,3519c3167,3170
<   fprintf(Logfile, "Enter initial temperature of aggregate in concrete \n");
<   read_string(instring, sizeof(instring));
<   Temp_0_agg = atof(instring);
<   fprintf(Logfile, "%f \n", Temp_0_agg);
<   Temp_cur_agg = Temp_0_agg;
---
>     /* special ID indicating first ant in list */
>     Headant->id = 100;
>     Headant->cycbirth = 0;
>     Tailant = Headant;
3521,3525c3172,3179
<   fprintf(Logfile,
<           "Enter heat transfer coefficient between aggregate and binder \n");
<   read_string(instring, sizeof(instring));
<   U_coeff_agg = atof(instring);
<   fprintf(Logfile, "%f \n", U_coeff_agg);
---
>     /* Initialize potassium sulfate doubly linked list */
>     Headks = (struct Alksulf *)malloc(Alksulfsize);
>     Headks->prevas = NULL;
>     Headks->nextas = NULL;
>     Headks->x = 0;
>     Headks->y = 0;
>     Headks->z = 0;
>     Tailks = Headks;
3527,3530c3181,3188
<   fprintf(Logfile, "CSH to pozzolanic CSH 0) prohibited or 1) allowed \n");
<   read_string(instring, sizeof(instring));
<   Csh2flag = atoi(instring);
<   fprintf(Logfile, "%d \n", Csh2flag);
---
>     /* Initialize sodium sulfate doubly-linked list */
>     Headnas = (struct Alksulf *)malloc(Alksulfsize);
>     Headnas->prevas = NULL;
>     Headnas->nextas = NULL;
>     Headnas->x = 0;
>     Headnas->y = 0;
>     Headnas->z = 0;
>     Tailnas = Headnas;
3532,3536c3190
<   fprintf(Logfile, "CH precipitation on aggregate surfaces ");
<   fprintf(Logfile, "0) prohibited or 1) allowed \n");
<   read_string(instring, sizeof(instring));
<   Chflag = atoi(instring);
<   fprintf(Logfile, "%d \n", Chflag);
---
>     /* Set initial pH of pore solution at time t = 0 */
3538,3545c3192
<   fprintf(Logfile, "Output hydration movie frame every ____ hours: ");
<   read_string(instring, sizeof(instring));
<   MovieFrameFreq = atof(instring);
<   if (MovieFrameFreq > End_time)
<     MovieFrameFreq = End_time + 1.0;
<   if (MovieFrameFreq <= 0.0)
<     MovieFrameFreq = End_time + 1.0;
<   fprintf(Logfile, "\n%f \n", MovieFrameFreq);
---
>     PH_cur = 7.0;
3547,3552c3194
<   *nmovstep = 1;
<   if ((MovieFrameFreq > 0.0) && (MovieFrameFreq < 1.0)) {
<     *nmovstep = (int)(End_time / MovieFrameFreq);
<     if (*nmovstep < 1)
<       *nmovstep = 1;
<   }
---
>     resfact = pow((1.0/Res),1.25);
3554,3559c3196
<   /***
<    *    Allow user to iteratively specify surface
<    *    deactivation parameters for particles of various
<    *    phases.  First initialize all the deactivation
<    *    arrays to zero, and then gather the information
<    ***/
---
>     for (i = C3S; i <= NSPHASES; i++) {
3561,3575c3198,3206
<   for (i = 0; i <= NSPHASES; i++) {
<     Deactfrac[i] = 0.0;
<     Reactfrac[i] = 0.0;
<     Deactinit[i] = 0;
<     Deactends[i] = 0;
<     Deactterm[i] = 0;
<     Deactphaselist[i] = 0;
<     Startflag[i] = 0;
<     Stopflag[i] = 0;
<   }
< 
<   fprintf(Logfile, "Enter phase id of surface to deactivate (-1 to quit) \n");
<   read_string(instring, sizeof(instring));
<   dphase = atoi(instring);
<   fprintf(Logfile, "%d\n", dphase);
---
>         /***
>         *    Source of the following data is
>         *    H.F.W. Taylor, "Cement Chemistry" 2nd Edition. Telford
>         *    Publishing, London, 1997.
>         *
>         *    NOTE that for the first cycle, of the clinker phases
>         *    only the aluminates and gypsum are soluble (silicates
>         *    are not soluble initially)
>         ***/
3577,3579c3208,3211
<   Numdeact = 0;
<   while (dphase != -1) {
<     deactphase = dphase;
---
>         /***
>         *    Soluble[x] - flag indicating if phase x is soluble
>         *    Disprob[x] - probability of dissolution (relative diss. rate)
>         ***/
3581,3585c3213,3214
<     fprintf(Logfile, "Enter fraction of surface to deactivate \n");
<     read_string(instring, sizeof(instring));
<     dfrac = atof(instring);
<     fprintf(Logfile, "%f\n", dfrac);
<     Deactfrac[deactphase] = dfrac;
---
>         if (Verbose) printf("\nSetting Disbase[%d]: resfact = %f, Discoeff[%d] = %f, DISBIAS = %f",i,resfact,i,Discoeff[i],DISBIAS);
>         Disprob[i] = Disbase[i] = resfact * Discoeff[i] / DISBIAS;
3587,3588c3216
<     Deactphaselist[Numdeact] = deactphase;
<     Numdeact++;
---
>         switch (i) {
3590,3594c3218,3221
<     if ((deactphase < C3S) || (deactphase > NSPHASES)) {
<       freeallmem();
<       bailout("disrealnew", "Bad ID for deactivated phase");
<       exit(1);
<     }
---
>             case C3S:
>                 Soluble[i] = 0;
>                 Creates[i] = DIFFCSH;
>                 break;
3596,3599c3223,3226
<     fprintf(Logfile, "Time to implement deactivation (in hours)\n");
<     read_string(instring, sizeof(instring));
<     Deactinit[deactphase] = atof(instring);
<     fprintf(Logfile, "%f\n", Deactinit[deactphase]);
---
>             case C2S:
>                 Soluble[i] = 0;
>                 Creates[i] = DIFFCSH;
>                 break;
3601,3605c3228,3229
<     fprintf(Logfile, "Time to begin reactivation (in hours)\n");
<     read_string(instring, sizeof(instring));
<     dends = atof(instring);
<     fprintf(Logfile, "%f\n", dends);
<     Deactends[deactphase] = dends;
---
>             case C3A:
>                 Soluble[i] = 1;
3607,3611c3231,3234
<     fprintf(Logfile, "Time of full reactivation (in hours)\n");
<     read_string(instring, sizeof(instring));
<     dterm = atof(instring);
<     fprintf(Logfile, "%f\n", dterm);
<     Deactterm[deactphase] = dterm;
---
>                 /***
>                 *    Default value of Discoeff increased back
>                 *    to 0.4 from 0.25 7/8/99
>                 ***/
3613,3617c3236,3237
<     if (dterm == dends) {
<       Reactfrac[deactphase] = 1.0;
<     } else {
<       Reactfrac[deactphase] = 1.0 / (dterm - dends + 1);
<     }
---
>                 Creates[i] = POROSITY;
>                 break;
3619,3623c3239,3242
<     fprintf(Logfile, "Enter phase id of surface to deactivate (-1 to quit) \n");
<     read_string(instring, sizeof(instring));
<     dphase = atoi(instring);
<     fprintf(Logfile, "%d\n", dphase);
<   }
---
>             case OC3A:
>                 Soluble[i] = 1;
>                 Creates[i] = POROSITY;
>                 break;
3625,3629c3244,3247
<   fprintf(Logfile, "Does pH influence hydration kinetics ");
<   fprintf(Logfile, "0) no or 1) yes \n");
<   read_string(instring, sizeof(instring));
<   PHactive = atoi(instring);
<   fprintf(Logfile, "%d\n", PHactive);
---
>             case C4AF:
>                 Soluble[i] = 1;
>                 Creates[i] = POROSITY;
>                 break;
3631,3639c3249,3252
<   /***
<    *    Set possibility of topochemical conversion of silicates
<    *    to CSH if pH effect is active, and also set the proximity
<    *    within which dissolved silicates are placed relative to the
<    *    dissolution source, to simulate the higher-density CSH
<    *    that is thought to form in the presence of alkalies
<    *    (see Juenger and Jennings, ACI Materials Journal,
<    *    Vol. 98, No. 3, pp. 251-255 (2001).
<    ***/
---
>             case K2SO4:
>                 Soluble[i] = 1;
>                 Creates[i] = POROSITY;
>                 break;
3641,3643c3254,3257
<   fflush(Logfile);
<   return (status);
< }
---
>             case NA2SO4:
>                 Soluble[i] = 1;
>                 Creates[i] = POROSITY;
>                 break;
3645,3662c3259,3260
< /***
<  *    init
<  *
<  *     Initialize values for solubilities, pH effect, etc.
<  *
<  *     Arguments:    none
<  *     Returns:    nothing
<  *
<  *    Calls:        no routines
<  *    Called by:    main program
<  ***/
< void init(void) {
<   int i, k, x, y;
<   float xv1, xv2, xv3, yv1, yv2, yv3;
<   float chperslag, poreperslag;
<   float resfact;
<   char buff[MAXSTRING], instring[MAXSTRING];
<   FILE *slagfile, *alkalifile;
---
>             case GYPSUM:
>                 Soluble[i] = 1;
3664,3667c3262,3274
<   Ngoing = 0;
<   Porefl1 = Porefl2 = Porefl3 = 1;
<   Pore_off = Water_off = 0;
<   Heat_old = Heat_new = 0.0;
---
>                 /***
>                 *    History of Discoeff values for GYPSUM
>                 *
>                 *    Changed from 0.05 to 0.015  9/29/98
>                 *    Changed to 0.040 10/15/98
>                 *    Back to 0.05 from 0.10 7/8/99
>                 *    From 0.05 to 0.02 4/4/00
>                 *    From 0.02 to 0.025 8/13/01
>                 *
>                 *    From 0.025 to 0.025 * DISBIAS, so that
>                 *    it can be divided by DISBIAS just like the
>                 *    others 16 July 2003
>                 ***/
3669c3276,3280
<   /* Current and previous cycle CH counts */
---
>                 /***
>                 *    geaendert am 04.04.00, urspr. 0.05
>                 *    dissolved gypsum distributed at random
>                 *    throughout microstructure
>                 ***/
3671c3282,3283
<   Chold = Chnew = 0;
---
>                 Creates[i] = POROSITY;
>                 break;
3673c3285,3286
<   /* Elapsed time according to maturity principles */
---
>             case GYPSUMS:
>                 Soluble[i] = 1;
3675,3676c3288,3301
<   Time_cur = 0.0;
<   Poregone = Poretodo = 0;
---
>                 /***
>                 *    History of Discoeff values for GYPSUMS
>                 *
>                 *    Changed from 0.05 to 0.015  9/29/98
>                 *    Changed to 0.020 10/15/98 
>                 *    From 0.02 to 0.025 8/13/01
>                 *
>                 *    From 0.025 to 0.025 * DISBIAS, so that
>                 *    it can be divided by DISBIAS just like the
>                 *    others 16 July 2003
>                 *
>                 *    And also changed all sulfate based
>                 *        dissolution rates
>                 ***/
3678c3303,3304
<   /* Initialize counters, etc. */
---
>                 Creates[i] = POROSITY;
>                 break;
3680,3689c3306,3307
<   Nsilica_rx = Nasr = Nslagr = 0;
<   Nsilica = 0;
<   Ncsbar = 0;
<   Netbar = 0;
<   Porinit = 0;
<   Cyccnt = 0;
<   Setflag = 0;
<   C3sinit = C2sinit = C3ainit = C4afinit = Crackpinit = 0;
<   Anhinit = Heminit = Slaginit = Freelimeinit = 0;
<   Nasulfinit = Ksulfinit = 0;
---
>             case ANHYDRITE:
>                 Soluble[i] = 1;
3691c3309,3314
<   /* Initialize structure for Ants */
---
>                 /***
>                 *    Set default anhydrite dissolution at 4/5ths
>                 *        of that of gypsum
>                 *
>                 *    Source: Uchikawa et al., CCR, 1984
>                 ***/
3693,3698c3316,3319
<   Headant = (struct Ants *)malloc(Antsize);
<   Headant->prevant = NULL;
<   Headant->nextant = NULL;
<   Headant->x = 0;
<   Headant->y = 0;
<   Headant->z = 0;
---
>                 /***
>                 *    Dissolved anhydrite distributed at random
>                 *    throughout microstructure
>                 ***/
3700,3703c3321,3322
<   /* special ID indicating first ant in list */
<   Headant->id = 100;
<   Headant->cycbirth = 0;
<   Tailant = Headant;
---
>                 Creates[i] = POROSITY;
>                 break;
3705,3712c3324,3334
<   /* Initialize potassium sulfate doubly linked list */
<   Headks = (struct Alksulf *)malloc(Alksulfsize);
<   Headks->prevas = NULL;
<   Headks->nextas = NULL;
<   Headks->x = 0;
<   Headks->y = 0;
<   Headks->z = 0;
<   Tailks = Headks;
---
>             case HEMIHYD:
>                 Soluble[i] = 1;
> 
>                 /***
>                 *    Set default hemihydrate dissolution at
>                 *        3 times that of gypsum
>                 *
>                 *     Source: Uchikawa et al., CCR, 1984
>                 *
>                 *    Changed to 1.5 times that of gypsum 6/1/00
>                 ***/
3714,3721c3336,3341
<   /* Initialize sodium sulfate doubly-linked list */
<   Headnas = (struct Alksulf *)malloc(Alksulfsize);
<   Headnas->prevas = NULL;
<   Headnas->nextas = NULL;
<   Headnas->x = 0;
<   Headnas->y = 0;
<   Headnas->z = 0;
<   Tailnas = Headnas;
---
>                 /***
>                 *    gendert am 01.06.00, urspr. 3.0
>                 *
>                 *    Dissolved hemihydrate distributed at random
>                 *    throughout microstructure
>                 ***/
3723c3343,3344
<   /* Set initial pH of pore solution at time t = 0 */
---
>                 Creates[i] = POROSITY;
>                 break;
3725c3346
<   PH_cur = 7.0;
---
>             case CH:
3727c3348,3351
<   resfact = pow((1.0 / Res), 1.25);
---
>                 /***
>                 *    CH soluble to allow for Ostwald
>                 *    ripening of crystals
>                 ***/
3729c3353,3354
<   for (i = C3S; i <= NSPHASES; i++) {
---
>                 Soluble[i] = 1;
>                 Creates[i] = DIFFCH;
3731,3739c3356,3364
<     /***
<      *    Source of the following data is
<      *    H.F.W. Taylor, "Cement Chemistry" 2nd Edition. Telford
<      *    Publishing, London, 1997.
<      *
<      *    NOTE that for the first cycle, of the clinker phases
<      *    only the aluminates and gypsum are soluble (silicates
<      *    are not soluble initially)
<      ***/
---
>                 /***
>                 *    Solubility of CH known to decrease in the
>                 *    presence of alkali species.  See
>                 *    Sprung and Rechenberg, Proc. Symp. Effect
>                 *    of Alkalies on Properties of Concrete,
>                 *    C & CA London, Sept. 1976, p. 109 (1977),
>                 *    and Jawed and Skalny, Cem. Concr. Res. Vol. 8
>                 *    pp. 37-52 (1978).
>                 ***/
3741,3744d3365
<     /***
<      *    Soluble[x] - flag indicating if phase x is soluble
<      *    Disprob[x] - probability of dissolution (relative diss. rate)
<      ***/
3746,3751c3367
<     if (Verbose_flag > 2)
<       fprintf(Logfile,
<               "\nSetting Disbase[%d]: resfact = %f, Discoeff[%d] = %f, DISBIAS "
<               "= %f",
<               i, resfact, i, Discoeff[i], DISBIAS);
<     Disprob[i] = Disbase[i] = resfact * Discoeff[i] / DISBIAS;
---
>                 break;
3753c3369
<     switch (i) {
---
>             case CACO3:
3755,3758c3371
<     case C3S:
<       Soluble[i] = 0;
<       Creates[i] = DIFFCSH;
<       break;
---
>                 /* CaCO3 is only mildly soluble by default */
3760,3763c3373,3375
<     case C2S:
<       Soluble[i] = 0;
<       Creates[i] = DIFFCSH;
<       break;
---
>                 Soluble[i] = 1;
>                 Creates[i] = DIFFCACO3;
>                 break;
3765,3766c3377
<     case C3A:
<       Soluble[i] = 1;
---
>             case FREELIME:
3768,3771c3379
<       /***
<        *    Default value of Discoeff increased back
<        *    to 0.4 from 0.25 7/8/99
<        ***/
---
>                 /* CaO is readily soluble */
3773,3774c3381,3383
<       Creates[i] = POROSITY;
<       break;
---
>                 Soluble[i] = 1;
>                 Creates[i] = DIFFCH;
>                 break;
3776,3779c3385
<     case OC3A:
<       Soluble[i] = 1;
<       Creates[i] = POROSITY;
<       break;
---
>             case SLAG:
3781,3784c3387,3391
<     case C4AF:
<       Soluble[i] = 1;
<       Creates[i] = POROSITY;
<       break;
---
>                 /***
>                 *    Slag is not truly soluble, but use
>                 *    its dissolution probability for reaction
>                 *    probability
>                 ***/
3786,3789c3393,3395
<     case K2SO4:
<       Soluble[i] = 1;
<       Creates[i] = POROSITY;
<       break;
---
>                 Soluble[i] = 0;
>                 Creates[i] = 0;
>                 break;
3791,3794c3397,3398
<     case NA2SO4:
<       Soluble[i] = 1;
<       Creates[i] = POROSITY;
<       break;
---
>             case C3AH6:
>                 Soluble[i] = 1;
3796,3797c3400,3403
<     case GYPSUM:
<       Soluble[i] = 1;
---
>                 /***
>                 *    Changed default value of Discoeff from 0.5
>                 *    to 0.01 06.09.00
>                 ***/
3799,3811c3405
<       /***
<        *    History of Discoeff values for GYPSUM
<        *
<        *    Changed from 0.05 to 0.015  9/29/98
<        *    Changed to 0.040 10/15/98
<        *    Back to 0.05 from 0.10 7/8/99
<        *    From 0.05 to 0.02 4/4/00
<        *    From 0.02 to 0.025 8/13/01
<        *
<        *    From 0.025 to 0.025 * DISBIAS, so that
<        *    it can be divided by DISBIAS just like the
<        *    others 16 July 2003
<        ***/
---
>                 Creates[i] = POROSITY;
3813,3817c3407,3415
<       /***
<        *    geaendert am 04.04.00, urspr. 0.05
<        *    dissolved gypsum distributed at random
<        *    throughout microstructure
<        ***/
---
>                 /***
>                 *    Solubility of hydrogarnet observed to depend on
>                 *    concentration of alkali species; see Jawed and
>                 *    Skalny, Cem. Concr. Res., Vol. 8 pp. 37-52 (1978),
>                 *    and Berger et al,m Oric, 6th Intl. Congr. Chemistry
>                 *    of Cement, suppl. paper, Moscow (1974).
>                 ***/
>     
>                 break;
3819,3820c3417
<       Creates[i] = POROSITY;
<       break;
---
>             case ETTR:
3822,3823c3419
<     case GYPSUMS:
<       Soluble[i] = 1;
---
>                 /* Ettringite is initially INSOLUBLE */
3825,3838c3421
<       /***
<        *    History of Discoeff values for GYPSUMS
<        *
<        *    Changed from 0.05 to 0.015  9/29/98
<        *    Changed to 0.020 10/15/98
<        *    From 0.02 to 0.025 8/13/01
<        *
<        *    From 0.025 to 0.025 * DISBIAS, so that
<        *    it can be divided by DISBIAS just like the
<        *    others 16 July 2003
<        *
<        *    And also changed all sulfate based
<        *        dissolution rates
<        ***/
---
>                 Soluble[i] = 0;
3840,3841c3423,3426
<       Creates[i] = POROSITY;
<       break;
---
>                 /***
>                 *    Default value of Discoeff changed to
>                 *    0.008 from 0.020  3/11/99
>                 ***/
3843,3844c3428
<     case ANHYDRITE:
<       Soluble[i] = 1;
---
>                 Creates[i] = DIFFETTR;
3846,3851c3430,3436
<       /***
<        *    Set default anhydrite dissolution at 4/5ths
<        *        of that of gypsum
<        *
<        *    Source: Uchikawa et al., CCR, 1984
<        ***/
---
>                 /***
>                 *    Solubility of ettringite observed to depend on
>                 *    concentration of alkali species; see Jawed and
>                 *    Skalny, Cem. Concr. Res., Vol. 8 pp. 37-52 (1978),
>                 *    and Berger et al,m Oric, 6th Intl. Congr. Chemistry
>                 *    of Cement, suppl. paper, Moscow (1974).
>                 ***/
3853,3856c3438
<       /***
<        *    Dissolved anhydrite distributed at random
<        *    throughout microstructure
<        ***/
---
>                 break;
3858,3859c3440
<       Creates[i] = POROSITY;
<       break;
---
>             case ETTRC4AF:
3861,3862c3442,3445
<     case HEMIHYD:
<       Soluble[i] = 1;
---
>                 /***
>                 *    Iron-rich ettringite is INSOLUBLE by default,
>                 *    that it, Discoeff = 0.0 by default
>                 ***/
3864,3871c3447,3449
<       /***
<        *    Set default hemihydrate dissolution at
<        *        3 times that of gypsum
<        *
<        *     Source: Uchikawa et al., CCR, 1984
<        *
<        *    Changed to 1.5 times that of gypsum 6/1/00
<        ***/
---
>                 Soluble[i] = 0;
>                 Creates[i] = ETTRC4AF;
>                 break;
3873,3878c3451
<       /***
<        *    gendert am 01.06.00, urspr. 3.0
<        *
<        *    Dissolved hemihydrate distributed at random
<        *    throughout microstructure
<        ***/
---
>             case CACL2:
3880,3881c3453
<       Creates[i] = POROSITY;
<       break;
---
>                 /* calcium chloride is soluble */
3883c3455,3457
<     case CH:
---
>                 Soluble[i] = 1;
>                 Creates[i] = DIFFCACL2;
>                 break;
3885,3888c3459
<       /***
<        *    CH soluble to allow for Ostwald
<        *    ripening of crystals
<        ***/
---
>             case ASG:
3890,3891c3461
<       Soluble[i] = 1;
<       Creates[i] = DIFFCH;
---
>                 /* aluminosilicate glass is soluble */
3893,3901c3463
<       /***
<        *    Solubility of CH known to decrease in the
<        *    presence of alkali species.  See
<        *    Sprung and Rechenberg, Proc. Symp. Effect
<        *    of Alkalies on Properties of Concrete,
<        *    C & CA London, Sept. 1976, p. 109 (1977),
<        *    and Jawed and Skalny, Cem. Concr. Res. Vol. 8
<        *    pp. 37-52 (1978).
<        ***/
---
>                 Soluble[i] = 1;
3903c3465,3475
<       break;
---
>                 /***
>                 *    Decreased default Discoeff[ASG] from 0.2 to 0.055556
>                 *    to better fit experimental data of Xiuping Feng
>                 *    on flyash consumption
>                 *
>                 *    4 Apr 2003
>                 *
>                 *    Changed default Discoeff from 0.055556 to 0.051
>                 *
>                 *    27 Apr 2003
>                 ***/
3905c3477,3478
<     case CACO3:
---
>                 Creates[i] = DIFFAS;
>                 break;
3907c3480
<       /* CaCO3 is only mildly soluble by default */
---
>             case CAS2:
3909,3911c3482
<       Soluble[i] = 1;
<       Creates[i] = DIFFCACO3;
<       break;
---
>                 /* calcium aluminodisilicate is soluble */
3913c3484
<     case FREELIME:
---
>                 Soluble[i] = 1;
3915c3486,3496
<       /* CaO is readily soluble */
---
>                 /***
>                 *    Decreased default Discoeff[ASG] from 0.2 to 0.043478
>                 *    to better fit experimental data of Xiuping Feng
>                 *    on flyash consumption
>                 *
>                 *    4 Apr 2003
>                 *
>                 *    Changed default Discoeff from 0.043478 to 0.04
>                 *
>                 *    27 Apr 2003
>                 ***/
3917,3919c3498,3499
<       Soluble[i] = 1;
<       Creates[i] = DIFFCH;
<       break;
---
>                 Creates[i] = DIFFCAS2;
>                 break;
3921c3501,3504
<     case SLAG:
---
>             default:
>                 Creates[i] = 0;
>                 Soluble[i] = 0;
>         }
3923,3927c3506,3511
<       /***
<        *    Slag is not truly soluble, but use
<        *    its dissolution probability for reaction
<        *    probability
<        ***/
---
>     }
> 
>     /***
>     *    Read in values for alkali characteristics and
>     *    convert them to fractions from percentages
>     ***/
3929,3931c3513,3536
<       Soluble[i] = 0;
<       Creates[i] = 0;
<       break;
---
>     sprintf(buff,"%salkalichar.dat",Outputdir);
>     alkalifile=filehandler("disrealnew",buff,"READ");
>     if (!alkalifile) {
>         freeallmem();
>         exit(1);
>     }
>     fscanf(alkalifile,"%s",instring);
>     Totsodium = atof(instring);
>     fscanf(alkalifile,"%s",instring);
>     Totpotassium = atof(instring);
>     fscanf(alkalifile,"%s",instring);
>     Rssodium = atof(instring);
>     fscanf(alkalifile,"%s",instring);
>     Rspotassium = atof(instring);
>     fscanf(alkalifile,"%s",buff);
>     if (!feof(alkalifile)) {
>         Sodiumhydrox = atof(buff);
>         fscanf(alkalifile,"%s",instring);
>         Potassiumhydrox = atof(instring);
>     } else {
>         Sodiumhydrox = 0.0;
>         Potassiumhydrox = 0.0;
>     }
>     fclose(alkalifile);
3933,3934c3538,3543
<     case C3AH6:
<       Soluble[i] = 1;
---
>     Totsodium /= 100.0;
>     Totpotassium /= 100.0;
>     Rssodium /= 100.0;
>     Rspotassium /= 100.0;
>     Sodiumhydrox /= 100.0;
>     Potassiumhydrox /= 100.0;
3936,3939c3545,3566
<       /***
<        *    Changed default value of Discoeff from 0.5
<        *    to 0.01 06.09.00
<        ***/
---
>     sprintf(buff,"%salkaliflyash.dat",Outputdir);
>     alkalifile=filehandler("disrealnew",buff,"READ_NOFAIL");
>     if (!alkalifile) {
>         Totfasodium = 0.0;
>         Totfapotassium = 0.0;
>         Rsfasodium = 0.0;
>         Rsfasodium = 0.0;
>     } else {
>         fscanf(alkalifile,"%s",instring);
>         Totfasodium = atof(instring);
>         fscanf(alkalifile,"%s",instring);
>         Totfapotassium = atof(instring);
>         fscanf(alkalifile,"%s",instring);
>         Rsfasodium = atof(instring);
>         fscanf(alkalifile,"%s",instring);
>         Rsfapotassium = atof(instring);
>         Totfasodium /= 100.0;
>         Totfapotassium /= 100.0;
>         Rsfasodium /= 100.0;
>         Rsfapotassium /= 100.0;
>         fclose(alkalifile);
>     }
3941c3568
<       Creates[i] = POROSITY;
---
>     /* Read in values for slag characteristics */
3943,3949c3570,3580
<       /***
<        *    Solubility of hydrogarnet observed to depend on
<        *    concentration of alkali species; see Jawed and
<        *    Skalny, Cem. Concr. Res., Vol. 8 pp. 37-52 (1978),
<        *    and Berger et al,m Oric, 6th Intl. Congr. Chemistry
<        *    of Cement, suppl. paper, Moscow (1974).
<        ***/
---
>     sprintf(buff,"%sslagchar.dat",Outputdir);
>     slagfile=filehandler("disrealnew",buff,"READ");
>     if (!slagfile) {
>         freeallmem();
>         exit(1);
>     }
>     fscanf(slagfile,"%s",instring);;
>     fscanf(slagfile,"%s",instring);
>     
>     fscanf(slagfile,"%s",instring);
>     Specgrav[SLAG] = atof(instring);
3951c3582,3583
<       break;
---
>     fscanf(slagfile,"%s",instring);
>     Specgrav[SLAGCSH] = atof(instring);
3953c3585,3586
<     case ETTR:
---
>     fscanf(slagfile,"%s",instring);
>     Molarv[SLAG] = atof(instring);
3955c3588,3589
<       /* Ettringite is initially INSOLUBLE */
---
>     fscanf(slagfile,"%s",instring);
>     Molarv[SLAGCSH] = atof(instring);
3957c3591,3598
<       Soluble[i] = 0;
---
>     fscanf(slagfile,"%s",instring);
>     Slagcasi = atof(instring);
>     fscanf(slagfile,"%s",instring);
>     Slaghydcasi = atof(instring);
>     fscanf(slagfile,"%s",instring);
>     Siperslag = atof(instring);
>     fscanf(slagfile,"%s",instring);
>     Waterc[SLAGCSH] = Siperslag * (atof(instring));
3959,3962c3600,3609
<       /***
<        *    Default value of Discoeff changed to
<        *    0.008 from 0.020  3/11/99
<        ***/
---
>     /***
>     *    No information about dehydration of
>     *    Slag CSH, so assume the same behavior
>     *    as for normal CSH, that is that about
>     *    60% of the water (by mass) is retained
>     *    at T = 105C.
>     *
>     *    (see H.F.W. Taylor, Mater. Res. Soc. Proc.
>     *    Vol. 85, p. 47 (1987))
>     ***/
3964c3611,3612
<       Creates[i] = DIFFETTR;
---
>     Nh2o[SLAGCSH][0] = Waterc[SLAGCSH];
>     Nh2o[SLAGCSH][1] = 0.60 * Nh2o[SLAGCSH][0];
3966,3972c3614,3617
<       /***
<        *    Solubility of ettringite observed to depend on
<        *    concentration of alkali species; see Jawed and
<        *    Skalny, Cem. Concr. Res., Vol. 8 pp. 37-52 (1978),
<        *    and Berger et al,m Oric, 6th Intl. Congr. Chemistry
<        *    of Cement, suppl. paper, Moscow (1974).
<        ***/
---
>     fscanf(slagfile,"%s",instring);
>     Slagc3a = atof(instring);
>     fscanf(slagfile,"%s",instring);
>     Slagreact = atof(instring);
3974c3619
<       break;
---
>     fclose(slagfile);
3976c3621,3624
<     case ETTRC4AF:
---
>     Waterc[SLAG] = 0.0;
>     Nh2o[SLAG][0] = 0.0;
>     Nh2o[SLAG][1] = 0.0;
>     Heatf[SLAG] = 0.0;
3978,3981c3626
<       /***
<        *    Iron-rich ettringite is INSOLUBLE by default,
<        *    that it, Discoeff = 0.0 by default
<        ***/
---
>     Heatf[SLAGCSH] = 0.0;
3983,3985c3628
<       Soluble[i] = 0;
<       Creates[i] = ETTRC4AF;
<       break;
---
>     /* Compute slag probabilities as defined above */
3987c3630,3631
<     case CACL2:
---
>     chperslag = Siperslag * (Slaghydcasi - Slagcasi) + (3.0 * Slagc3a);
>     if (chperslag < 0.0) chperslag = 0.0;
3989c3633,3634
<       /* calcium chloride is soluble */
---
>     P2slag = Molarv[SLAG];
>     P2slag += Molarv[CH]*chperslag;
3991,3993c3636
<       Soluble[i] = 1;
<       Creates[i] = DIFFCACL2;
<       break;
---
>     poreperslag = Waterc[SLAGCSH]-chperslag+Waterc[C3AH6]*Slagc3a;
3995c3638,3641
<     case ASG:
---
>     P2slag += Molarv[POROSITY] * poreperslag;
>     P2slag -= Molarv[SLAGCSH];
>     P2slag -= Molarv[C3AH6]*Slagc3a;
>     P2slag /= Molarv[SLAG];
3997c3643
<       /* aluminosilicate glass is soluble */
---
>     P1slag = 1.0 - P2slag;
3999c3645
<       Soluble[i] = 1;
---
>     P3slag = (Molarv[SLAGCSH] / Molarv[SLAG]) - P1slag;
4001,4011c3647
<       /***
<        *    Decreased default Discoeff[ASG] from 0.2 to 0.055556
<        *    to better fit experimental data of Xiuping Feng
<        *    on flyash consumption
<        *
<        *    4 Apr 2003
<        *
<        *    Changed default Discoeff from 0.055556 to 0.051
<        *
<        *    27 Apr 2003
<        ***/
---
>     P4slag = chperslag * Molarv[CH] / Molarv[SLAG];
4013,4014c3649,3661
<       Creates[i] = DIFFAS;
<       break;
---
>     P5slag = Slagc3a * Molarv[C3A] / Molarv[SLAG];
>     if (P5slag > 1.0) {
>         P5slag=1.0;
>         printf("WARNING:  C3A/slag value exceeded 1.0.  ");
>         printf("Resetting to 1.0 \n");
>     }
>     if (Verbose) {
>         printf("\nP1slag = %f",P1slag);
>         printf("\nP2slag = %f",P2slag);
>         printf("\nP3slag = %f",P3slag);
>         printf("\nP4slag = %f",P4slag);
>         printf("\nP5slag = %f",P5slag);
>     }
4016c3663,3666
<     case CAS2:
---
>     /***
>     *    Set up second-order fit for pH effects on solubility/reactivity
>     *    of cement phases and pozzolanic compounds
>     ***/
4018c3668,3669
<       /* calcium aluminodisilicate is soluble */
---
>     x = 0;
>     y = 1;
4020c3671
<       Soluble[i] = 1;
---
>     for (k = C3S; k <= NSPHASES; k++) {
4022,4032c3673,3678
<       /***
<        *    Decreased default Discoeff[ASG] from 0.2 to 0.043478
<        *    to better fit experimental data of Xiuping Feng
<        *    on flyash consumption
<        *
<        *    4 Apr 2003
<        *
<        *    Changed default Discoeff from 0.043478 to 0.04
<        *
<        *    27 Apr 2003
<        ***/
---
>         xv1 = FitpH[k][x][0];
>         xv2 = FitpH[k][x][1];
>         xv3 = FitpH[k][x][2];
>         yv1 = FitpH[k][y][0];
>         yv2 = FitpH[k][y][1];
>         yv3 = FitpH[k][y][2];
4034,4035c3680,3686
<       Creates[i] = DIFFCAS2;
<       break;
---
>         /***
>         *    These are the three coefficients for a second order
>         *    fit of PHfactor to pH for cement, evaluated later
>         *    in this function.
>         *
>         *    10 April 2003
>         ***/
4037,4041c3688
<     default:
<       Creates[i] = 0;
<       Soluble[i] = 0;
<     }
<   }
---
>         PHcoeff[k][2] = (yv3-yv1)*(xv2-xv1) - (yv2-yv1)*(xv3-xv1);
4043,4071c3690,3691
<   /***
<    *    Read in values for alkali characteristics and
<    *    convert them to fractions from percentages
<    ***/
< 
<   sprintf(buff, "%salkalichar.dat", WorkingDirectory);
<   alkalifile = filehandler("disrealnew", buff, "READ");
<   if (!alkalifile) {
<     freeallmem();
<     exit(1);
<   }
<   fscanf(alkalifile, "%s", instring);
<   Totsodium = atof(instring);
<   fscanf(alkalifile, "%s", instring);
<   Totpotassium = atof(instring);
<   fscanf(alkalifile, "%s", instring);
<   Rssodium = atof(instring);
<   fscanf(alkalifile, "%s", instring);
<   Rspotassium = atof(instring);
<   fscanf(alkalifile, "%s", buff);
<   if (!feof(alkalifile)) {
<     Sodiumhydrox = atof(buff);
<     fscanf(alkalifile, "%s", instring);
<     Potassiumhydrox = atof(instring);
<   } else {
<     Sodiumhydrox = 0.0;
<     Potassiumhydrox = 0.0;
<   }
<   fclose(alkalifile);
---
>         PHcoeff[k][2] /= ( ((xv3*xv3-xv1*xv1)*(xv2-xv1))
>                     - ((xv2*xv2-xv1*xv1)*(xv3-xv1)) );
4073,4078c3693,3694
<   Totsodium /= 100.0;
<   Totpotassium /= 100.0;
<   Rssodium /= 100.0;
<   Rspotassium /= 100.0;
<   Sodiumhydrox /= 100.0;
<   Potassiumhydrox /= 100.0;
---
>         PHcoeff[k][1] = (yv2-yv1) - (PHcoeff[k][2]*(xv2*xv2-xv1*xv1));
>         PHcoeff[k][1] /= (xv2 - xv1);
4080,4101c3696
<   sprintf(buff, "%salkaliflyash.dat", WorkingDirectory);
<   alkalifile = filehandler("disrealnew", buff, "READ_NOFAIL");
<   if (!alkalifile) {
<     Totfasodium = 0.0;
<     Totfapotassium = 0.0;
<     Rsfasodium = 0.0;
<     Rsfasodium = 0.0;
<   } else {
<     fscanf(alkalifile, "%s", instring);
<     Totfasodium = atof(instring);
<     fscanf(alkalifile, "%s", instring);
<     Totfapotassium = atof(instring);
<     fscanf(alkalifile, "%s", instring);
<     Rsfasodium = atof(instring);
<     fscanf(alkalifile, "%s", instring);
<     Rsfapotassium = atof(instring);
<     Totfasodium /= 100.0;
<     Totfapotassium /= 100.0;
<     Rsfasodium /= 100.0;
<     Rsfapotassium /= 100.0;
<     fclose(alkalifile);
<   }
---
>         PHcoeff[k][0] = yv1 - (PHcoeff[k][1]*xv1) - (PHcoeff[k][2]*xv1*xv1);
4103c3698
<   /* Read in values for slag characteristics */
---
>     }
4105,4113c3700,3701
<   sprintf(buff, "%sslagchar.dat", WorkingDirectory);
<   slagfile = filehandler("disrealnew", buff, "READ");
<   if (!slagfile) {
<     freeallmem();
<     exit(1);
<   }
<   fscanf(slagfile, "%s", instring);
<   ;
<   fscanf(slagfile, "%s", instring);
---
>     return;
> }
4115,4116c3703,3720
<   fscanf(slagfile, "%s", instring);
<   Specgrav[SLAG] = atof(instring);
---
> /***
> *    initialize_output_files
> *
> *     Sets up output file names, pointers, and prints headers where
> *     necessary.
> *
> *     Arguments:    none
> *     Returns:    0 if okay, nonzero otherwise
> *
> *    Calls:        no routines
> *    Called by:    main program
> ***/
> int initialize_output_files(void)
> {
>     int numchar,numsep,i,j;
>     char strsuff[MAXSTRING],strsuffa[MAXSTRING],strsuffb[MAXSTRING];
>     char sepchar,outputdirnosep[MAXSTRING],dfileroot[MAXSTRING];
>     char *p;
4118,4119c3722,3725
<   fscanf(slagfile, "%s", instring);
<   Specgrav[SLAGCSH] = atof(instring);
---
>     sprintf(strsuffa,".%d.%1d",(int)Temp_0,Csh2flag);
>     sprintf(strsuffb,"%1d%1d",Adiaflag,Sealed);
>     strcpy(strsuff,strsuffa);
>     strcat(strsuff,strsuffb);
4121,4122c3727,3732
<   fscanf(slagfile, "%s", instring);
<   Molarv[SLAG] = atof(instring);
---
>     numchar = strlen(Outputdir);
>     for (i = 0; i < (numchar - 1); i++) {
>         outputdirnosep[i] = Outputdir[i];
>     }
>     outputdirnosep[numchar-1] = '\0';
>     sepchar = Outputdir[numchar-1];
4124,4125c3734
<   fscanf(slagfile, "%s", instring);
<   Molarv[SLAGCSH] = atof(instring);
---
>     /* Tokenize the string outputdirnosep */
4127,4134c3736,3753
<   fscanf(slagfile, "%s", instring);
<   Slagcasi = atof(instring);
<   fscanf(slagfile, "%s", instring);
<   Slaghydcasi = atof(instring);
<   fscanf(slagfile, "%s", instring);
<   Siperslag = atof(instring);
<   fscanf(slagfile, "%s", instring);
<   Waterc[SLAGCSH] = Siperslag * (atof(instring));
---
>     numsep = 0;
>     for (i = 0; i < strlen(outputdirnosep) - 1; i++) {
>         if (outputdirnosep[i] == sepchar) numsep++;
>     }
>     i = j = 0;
>     while (j < numsep) {
>         if (outputdirnosep[i] == sepchar) j++;
>         i++;
>     }
>     p = &outputdirnosep[i];
>     strcpy(dfileroot,p);
>     if (Verbose) {
>         printf("\nOutputdir is: %s",Outputdir);
>         printf("\noutputdirnosep is: %s",outputdirnosep);
>         printf("\nSeparation character is %c",sepchar);
>         printf("Number of separation characters is %d",numsep);
>         printf("\n\ndfileroot is: %s\n\n",dfileroot);
>     }
4136,4145c3755,3757
<   /***
<    *    No information about dehydration of
<    *    Slag CSH, so assume the same behavior
<    *    as for normal CSH, that is that about
<    *    60% of the water (by mass) is retained
<    *    at T = 105C.
<    *
<    *    (see H.F.W. Taylor, Mater. Res. Soc. Proc.
<    *    Vol. 85, p. 47 (1987))
<    ***/
---
>     /* sprintf(Datafilename,"%s%s.data",Outputdir,dfileroot); */
>     sprintf(Datafilename,"%s%s.csv",Outputdir,dfileroot);
>     sprintf(Imageindexname,"%simage_index.txt",Outputdir);
4147,4148c3759,3760
<   Nh2o[SLAGCSH][0] = Waterc[SLAGCSH];
<   Nh2o[SLAGCSH][1] = 0.60 * Nh2o[SLAGCSH][0];
---
>     sprintf(Moviename,"%s%s.mov",Outputdir,dfileroot);
>     /* strcat(Moviename,strsuff); */
4150,4153c3762
<   fscanf(slagfile, "%s", instring);
<   Slagc3a = atof(instring);
<   fscanf(slagfile, "%s", instring);
<   Slagreact = atof(instring);
---
>     sprintf(Parname,"%s%s.params",Outputdir,dfileroot);
4155c3764,3765
<   fclose(slagfile);
---
>     sprintf(Fileoname,"%s%s.img",Outputdir,dfileroot);
>     strcat(Fileoname,strsuff);
4157,4160c3767,3768
<   Waterc[SLAG] = 0.0;
<   Nh2o[SLAG][0] = 0.0;
<   Nh2o[SLAG][1] = 0.0;
<   Heatf[SLAG] = 0.0;
---
>     sprintf(Phrname,"%s%s.phr",Outputdir,dfileroot);
>     strcat(Phrname,strsuff);
4162c3770
<   Heatf[SLAGCSH] = 0.0;
---
>     /* Store parameters input in parameter file */
4164c3772
<   /* Compute slag probabilities as defined above */
---
>     return(0);
4166,4168c3774
<   chperslag = Siperslag * (Slaghydcasi - Slagcasi) + (3.0 * Slagc3a);
<   if (chperslag < 0.0)
<     chperslag = 0.0;
---
> }
4170,4171c3776,3791
<   P2slag = Molarv[SLAG];
<   P2slag += Molarv[CH] * chperslag;
---
> /***
> *    manage_deactivation_behavior
> *
> *     Determines which phases to deactivate, when to deactivate them,
> *     and when, if ever, to reactivate them.
> *
> *     Arguments:    none
> *     Returns:    nothing
> *
> *    Calls:        performdeactivation,performreactivation
> *    Called by:    main program
> ***/
> void manage_deactivation_behavior(void)
> {
>     register int i;
>     int j;
4173c3793,3797
<   poreperslag = Waterc[SLAGCSH] - chperslag + Waterc[C3AH6] * Slagc3a;
---
>     for (i = 0; i < Numdeact; i++) {
>         j = Deactphaselist[i];
>         if ((Deactfrac[j] > 0.0)
>             && (Time_cur >= Deactinit[j])
>             && Startflag[j] == 0) {
4175,4178c3799,3806
<   P2slag += Molarv[POROSITY] * poreperslag;
<   P2slag -= Molarv[SLAGCSH];
<   P2slag -= Molarv[C3AH6] * Slagc3a;
<   P2slag /= Molarv[SLAG];
---
>             Startflag[j] = 1;
>             if (Verbose) {
>                 printf("\nDeactivating now at time %f...",Time_cur);
>                 printf(" phase %d\n",j);
>                 printf("\tFraction to deactivate is %f\n",Deactfrac[j]);
>             }
>             performdeactivation(j,Deactfrac[j]);
>         }
4180c3808,3810
<   P1slag = 1.0 - P2slag;
---
>         /***
>         *    Decide if any reactivation is necessary
>         ***/
4182c3812,3814
<   P3slag = (Molarv[SLAGCSH] / Molarv[SLAG]) - P1slag;
---
>         if ((Deactfrac[j] > 0.0)
>             && (Time_cur >= Deactends[j])
>             && (Time_cur <= Deactterm[j])) {
4184c3816,3823
<   P4slag = chperslag * Molarv[CH] / Molarv[SLAG];
---
>             if (Time_cur == Deactterm[j]) {
>                 Stopflag[j] = 1;
>                 if (Verbose) {
>                     printf("\nTerminating deactivation for phase %d \nat time %f\n",j,Time_cur);
>                 }
>             } else if (Verbose) {
>                 printf("\nPartially reactivating for phase %d \nat time %f\n",j,Time_cur);
>             }
4186,4200c3825
<   P5slag = Slagc3a * Molarv[C3A] / Molarv[SLAG];
<   if (P5slag > 1.0) {
<     P5slag = 1.0;
<     if (Verbose_flag > 0) {
<       fprintf(Logfile, "WARNING:  C3A/slag value exceeded 1.0.  ");
<       fprintf(Logfile, "Resetting to 1.0 \n");
<     }
<   }
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "\nP1slag = %f", P1slag);
<     fprintf(Logfile, "\nP2slag = %f", P2slag);
<     fprintf(Logfile, "\nP3slag = %f", P3slag);
<     fprintf(Logfile, "\nP4slag = %f", P4slag);
<     fprintf(Logfile, "\nP5slag = %f", P5slag);
<   }
---
>             performreactivation(j,Reactfrac[j],Stopflag[j]);
4202,4205c3827,3828
<   /***
<    *    Set up second-order fit for pH effects on solubility/reactivity
<    *    of cement phases and pozzolanic compounds
<    ***/
---
>         } else if ((Deactfrac[j] > 0.0)
>             && (Time_cur >= Deactterm[j]) && Stopflag[j] == 0) {
4207,4208c3830,3833
<   x = 0;
<   y = 1;
---
>             Stopflag[j] = 1;
>             if (Verbose) printf("\nTerminating deactivation for phase %d \nat time %f\n",j,Time_cur);
>         }
>     }
4210c3835,3836
<   for (k = C3S; k <= NSPHASES; k++) {
---
>     return;
> }
4212,4217c3838,3855
<     xv1 = FitpH[k][x][0];
<     xv2 = FitpH[k][x][1];
<     xv3 = FitpH[k][x][2];
<     yv1 = FitpH[k][y][0];
<     yv2 = FitpH[k][y][1];
<     yv3 = FitpH[k][y][2];
---
> /***
> *    performdeactivation
> *
> *     Deactivate a fraction (fracdeact) of the
> *     a given phase to prevent its hydrating
> *
> *     Arguments:    int phase id to deactivate
> *                 float fraction to deactivate
> *
> *     Returns:    nothing
> *
> *    Calls:        ran1
> *    Called by:    main program
> ***/
> void performdeactivation(int pid, float fracdeact)
> {    
>     int kx,ky,kz,jx,jy,jz,faceid;
>     float prdeact;
4219,4225c3857
<     /***
<      *    These are the three coefficients for a second order
<      *    fit of PHfactor to pH for cement, evaluated later
<      *    in this function.
<      *
<      *    10 April 2003
<      ***/
---
>     /* Scan entire 3-D microstructure */
4227c3859,3862
<     PHcoeff[k][2] = (yv3 - yv1) * (xv2 - xv1) - (yv2 - yv1) * (xv3 - xv1);
---
>     jx = jy = jz = 0;
>     for (kz = 0; kz < Zsyssize; kz++) {
>         for (ky = 0; ky < Ysyssize; ky++) {
>             for (kx = 0; kx < Xsyssize; kx++) {
4229,4230c3864,3866
<     PHcoeff[k][2] /= (((xv3 * xv3 - xv1 * xv1) * (xv2 - xv1)) -
<                       ((xv2 * xv2 - xv1 * xv1) * (xv3 - xv1)));
---
>                 /***
>                 *    Choose which phases to deactivate
>                 ***/
4232,4233c3868
<     PHcoeff[k][1] = (yv2 - yv1) - (PHcoeff[k][2] * (xv2 * xv2 - xv1 * xv1));
<     PHcoeff[k][1] /= (xv2 - xv1);
---
>                 if (Mic[kx][ky][kz] == pid) {
4235,4236c3870,3910
<     PHcoeff[k][0] = yv1 - (PHcoeff[k][1] * xv1) - (PHcoeff[k][2] * xv1 * xv1);
<   }
---
>                     for(faceid = 0; faceid < 6; faceid++) {
>                         switch (faceid) {
>                             case 0:
>                                 jx=kx+1;
>                                 if (jx > (Xsyssize - 1)) jx = 0;
>                                 jy = ky;
>                                 jz = kz;
>                                 break;
>                             case 1:
>                                 jx = kx - 1;
>                                 if (jx < 0) jx = Xsyssize - 1;
>                                 jy = ky;
>                                 jz = kz;
>                                 break;
>                             case 2:
>                                 jy=ky+1;
>                                 if (jy > (Ysyssize - 1)) jy = 0;
>                                 jx = kx;
>                                 jz = kz;
>                                 break;
>                             case 3:
>                                 jy = ky - 1;
>                                 if (jy < 0) jy = Ysyssize - 1;
>                                 jx = kx;
>                                 jz = kz;
>                                 break;
>                             case 4:
>                                 jz = ky + 1;
>                                 if (jz > (Zsyssize - 1)) jz = 0;
>                                 jx = kx;
>                                 jy = ky;
>                                 break;
>                             case 5:
>                                 jz = ky - 1;
>                                 if (jz < 0) jz = Zsyssize - 1;
>                                 jx = kx;
>                                 jy = ky;
>                                 break;
>                             default:
>                                 break;
>                         }
4238,4239c3912,3915
<   return;
< }
---
>                         /***
>                         *    If the neighboring pixel is porosity,
>                         *    perhaps deactivate this pixel face
>                         ***/
4241,4257c3917
< /***
<  *    initialize_output_files
<  *
<  *     Sets up output file names, pointers, and prints headers where
<  *     necessary.
<  *
<  *     Arguments:    none
<  *     Returns:    0 if okay, nonzero otherwise
<  *
<  *    Calls:        no routines
<  *    Called by:    main program
<  ***/
< int initialize_output_files(void) {
<   int numchar, numsep, i, j;
<   char strsuff[MAXSTRING], strsuffa[MAXSTRING], strsuffb[MAXSTRING];
<   char sepchar, outputdirnosep[MAXSTRING], dfileroot[MAXSTRING];
<   char *p;
---
>                         if (Mic[jx][jy][jz] == POROSITY || Mic[jx][jy][jz] == CRACKP) {
4259,4262c3919,3920
<   sprintf(strsuffa, ".%d.%1d", (int)Temp_0, Csh2flag);
<   sprintf(strsuffb, "%1d%1d", Adiaflag, Sealed);
<   strcpy(strsuff, strsuffa);
<   strcat(strsuff, strsuffb);
---
>                             prdeact = ran1(Seed);
>                             if (prdeact < fracdeact) {
4264,4269c3922,3931
<   numchar = strlen(WorkingDirectory);
<   for (i = 0; i < (numchar - 1); i++) {
<     outputdirnosep[i] = WorkingDirectory[i];
<   }
<   outputdirnosep[numchar - 1] = '\0';
<   sepchar = WorkingDirectory[numchar - 1];
---
>                                 /***
>                                 *    Deactivation is by multiplying
>                                 *    by prime factor
>                                 ***/
>     
>                                 Deactivated[kx][ky][kz] *= Primevalues[faceid];
>                             }
>                         }
>                     }
>                 }
4271c3933,3935
<   /* Tokenize the string outputdirnosep */
---
>             }    /* End of loop over Z */
>         }        /* End of loop over Y */
>     }            /* End of loop over X */
4273,4292c3937
<   numsep = 0;
<   for (i = 0; i < strlen(outputdirnosep) - 1; i++) {
<     if (outputdirnosep[i] == sepchar)
<       numsep++;
<   }
<   i = j = 0;
<   while (j < numsep) {
<     if (outputdirnosep[i] == sepchar)
<       j++;
<     i++;
<   }
<   p = &outputdirnosep[i];
<   strcpy(dfileroot, p);
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "\nWorkingDirectory is: %s", WorkingDirectory);
<     fprintf(Logfile, "\noutputdirnosep is: %s", outputdirnosep);
<     fprintf(Logfile, "\nSeparation character is %c", sepchar);
<     fprintf(Logfile, "Number of separation characters is %d", numsep);
<     fprintf(Logfile, "\n\ndfileroot is: %s\n\n", dfileroot);
<   }
---
> }
4294,4296c3939,3959
<   /* sprintf(Datafilename,"%s%s.data",WorkingDirectory,dfileroot); */
<   sprintf(Datafilename, "%s%s.csv", WorkingDirectory, dfileroot);
<   sprintf(Imageindexname, "%simage_index.txt", WorkingDirectory);
---
> /***
> *    performreactivation
> *
> *     Reactivate a fraction (fracreact) of the
> *     a deactivated surface to allow its hydrating
> *
> *     Arguments:    int phase id to reactivate
> *                 float fraction to deactivate
> *                 int finalreact
> *
> *     Returns:    nothing
> *
> *    Calls:        ran1
> *    Called by:    main program
> ***/
> void performreactivation(int pid, float fracreact, int finalreact)
> {    
>     int kx,ky,kz,faceid,cv;
>     float prreact;
>        
>     /* Scan entire 3-D microstructure */
4298,4299c3961,3963
<   sprintf(Moviename, "%s%s.mov", WorkingDirectory, dfileroot);
<   /* strcat(Moviename,strsuff); */
---
>     for (kz = 0; kz < Zsyssize; kz++) {
>         for (ky = 0; ky < Ysyssize; ky++) {
>             for (kx = 0; kx < Xsyssize; kx++) {
4301c3965
<   sprintf(Parname, "%s%s.params", WorkingDirectory, dfileroot);
---
>                 if (Mic[kx][ky][kz] == pid) {
4303,4304c3967,3971
<   sprintf(Fileoname, "%s%s.img", WorkingDirectory, dfileroot);
<   strcat(Fileoname, strsuff);
---
>                     for (faceid = 0; faceid < 6; faceid++) {
>                         cv = Deactivated[kx][ky][kz]%Primevalues[faceid];
>                         if (!cv) {
>                             prreact = ran1(Seed);
>                             if ((prreact < fracreact) || (finalreact) ) {
4306,4307c3973,3976
<   sprintf(Phrname, "%s%s.phr", WorkingDirectory, dfileroot);
<   strcat(Phrname, strsuff);
---
>                                 /***
>                                 *    Reactivation is by dividing by
>                                 *    prime factor
>                                 ***/
4309c3978,3980
<   /* Store parameters input in parameter file */
---
>                                 Deactivated[kx][ky][kz] /= Primevalues[faceid];
>                             }
>                         }
4311c3982,3988
<   return (0);
---
>                     }    /* End of loop over faces of pixel */
>                 }
> 
>             }            /* End of loop over Z */
>         }                /* End of loop over Y */
>     }                    /* End of loop over X */
> 
4315,4328c3992,4009
<  *    manage_deactivation_behavior
<  *
<  *     Determines which phases to deactivate, when to deactivate them,
<  *     and when, if ever, to reactivate them.
<  *
<  *     Arguments:    none
<  *     Returns:    nothing
<  *
<  *    Calls:        performdeactivation,performreactivation
<  *    Called by:    main program
<  ***/
< void manage_deactivation_behavior(void) {
<   register int i;
<   int j;
---
> *    chckedge
> *
> *     Check if a pixel located at (xck,yck,zck) is on a
> *     surface with pore space in the 3D system
> *     
> *     Arguments:    int phase to check
> *                 integer x,y, and z coordinates to check
> *
> *     Returns:    1 if on a surface, 0 otherwise
> *
> *    Calls:        no other routines
> *    Called by:    passone
> ***/
> int chckedge(int phase, int xck, int yck, int zck)
> {
>     int edgeback = 0;
>     int x2,y2,z2;
>     int ip;
4330,4343d4010
<   for (i = 0; i < Numdeact; i++) {
<     j = Deactphaselist[i];
<     if ((Deactfrac[j] > 0.0) && (Time_cur >= Deactinit[j]) &&
<         Startflag[j] == 0) {
< 
<       Startflag[j] = 1;
<       if (Verbose_flag > 1) {
<         fprintf(Logfile, "\nDeactivating now at time %f...", Time_cur);
<         fprintf(Logfile, " phase %d\n", j);
<         fprintf(Logfile, "\tFraction to deactivate is %f\n", Deactfrac[j]);
<       }
<       performdeactivation(j, Deactfrac[j]);
<     }
< 
4345,4346c4012,4017
<      *    Decide if any reactivation is necessary
<      ***/
---
>     *    Check all neighboring pixels (6, 18, or 26)
>     *    and use periodic boundary conditions
>     *
>     *    Change number of NEIGHBORS in header file
>     *    called disrealnew.h
>     ***/
4348,4349c4019
<     if ((Deactfrac[j] > 0.0) && (Time_cur >= Deactends[j]) &&
<         (Time_cur <= Deactterm[j])) {
---
>     for (ip = 0; ((ip < NEIGHBORS) && (!edgeback)); ip++) {
4351,4361c4021,4023
<       if (Time_cur == Deactterm[j]) {
<         Stopflag[j] = 1;
<         if (Verbose_flag > 1) {
<           fprintf(Logfile,
<                   "\nTerminating deactivation for phase %d \nat time %f\n", j,
<                   Time_cur);
<         }
<       } else if (Verbose_flag > 1) {
<         fprintf(Logfile, "\nPartially reactivating for phase %d \nat time %f\n",
<                 j, Time_cur);
<       }
---
>         x2 = xck + Xoff[ip];
>         y2 = yck + Yoff[ip];
>         z2 = zck + Zoff[ip];
4363c4025,4027
<       performreactivation(j, Reactfrac[j], Stopflag[j]);
---
>         x2 += checkbc(x2,Xsyssize);
>         y2 += checkbc(y2,Ysyssize);
>         z2 += checkbc(z2,Zsyssize);
4365,4372c4029,4041
<     } else if ((Deactfrac[j] > 0.0) && (Time_cur >= Deactterm[j]) &&
<                Stopflag[j] == 0) {
< 
<       Stopflag[j] = 1;
<       if (Verbose_flag > 1)
<         fprintf(Logfile,
<                 "\nTerminating deactivation for phase %d \nat time %f\n", j,
<                 Time_cur);
---
>         if (Mic[x2][y2][z2] == POROSITY
>                 || Mic[x2][y2][z2] == CRACKP
>                 || Mic[x2][y2][z2] == CSH
>                 || Mic[x2][y2][z2] == POZZCSH
>                 || Mic[x2][y2][z2] == SLAGCSH) {
>             edgeback = 1;
>         } 
>         /* JWB: Added this block as a trial to prevent adjacent
>          * particles from blocking each other's dissolution
>          */
>         else if (Micpart[xck][yck][zck] != Micpart[x2][y2][z2]) {
>             edgeback = 1;
>         }
4374d4042
<   }
4376c4044
<   return;
---
>     return(edgeback);
4380,4395c4048,4065
<  *    performdeactivation
<  *
<  *     Deactivate a fraction (fracdeact) of the
<  *     a given phase to prevent its hydrating
<  *
<  *     Arguments:    int phase id to deactivate
<  *                 float fraction to deactivate
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        ran1
<  *    Called by:    main program
<  ***/
< void performdeactivation(int pid, float fracdeact) {
<   int kx, ky, kz, jx, jy, jz, faceid;
<   float prdeact;
---
> *    resetcrackpores
> *
> *     Scans over all pixels.  If a pixel of type POROSITY or CRACKP
> *     is found, then checks nearest neighbors to decide majority type
> *     of pore pixels surrounding a pixel at position xck,yck,zck
> *     
> *     Arguments:    none
> *
> *     Returns:    nothing
> *
> *    Calls:        no other routines
> *    Called by:    main function
> ***/
> void resetcrackpores(void)
> {
>     int porecnt,crackcnt,curid;
>     int x1,y1,z1,x2,y2,z2;
>     int ip;
4397c4067,4073
<   /* Scan entire 3-D microstructure */
---
>     /***
>     *    Check all neighboring pixels (6, 18, or 26)
>     *    and use periodic boundary conditions
>     *
>     *    Change number of NEIGHBORS in header file
>     *    called disrealnew.h
>     ***/
4399,4402c4075,4079
<   jx = jy = jz = 0;
<   for (kx = 0; kx < Xsyssize; kx++) {
<     for (ky = 0; ky < Ysyssize; ky++) {
<       for (kz = 0; kz < Zsyssize; kz++) {
---
>     for (z1 = 0 ; z1 < Zsyssize; z1++) {
>         for (y1 = 0 ; y1 < Ysyssize; y1++) {
>             for (x1 = 0 ; x1 < Xsyssize; x1++) {
>                 if (Mic[x1][y1][z1] == POROSITY
>                     || Mic[x1][y1][z1] == CRACKP) {
4404,4406c4081,4083
<         /***
<          *    Choose which phases to deactivate
<          ***/
---
>                     curid = Mic[x1][y1][z1];
>                     porecnt = crackcnt = 0;
>                     for (ip = 0; ip < NEIGHBORS; ip++) {
4408c4085,4087
<         if (Mic[kx][ky][kz] == pid) {
---
>                         x2 = x1 + Xoff[ip];
>                         y2 = y1 + Yoff[ip];
>                         z2 = z1 + Zoff[ip];
4410,4456c4089,4091
<           for (faceid = 0; faceid < 6; faceid++) {
<             switch (faceid) {
<             case 0:
<               jx = kx + 1;
<               if (jx > (Xsyssize - 1))
<                 jx = 0;
<               jy = ky;
<               jz = kz;
<               break;
<             case 1:
<               jx = kx - 1;
<               if (jx < 0)
<                 jx = Xsyssize - 1;
<               jy = ky;
<               jz = kz;
<               break;
<             case 2:
<               jy = ky + 1;
<               if (jy > (Ysyssize - 1))
<                 jy = 0;
<               jx = kx;
<               jz = kz;
<               break;
<             case 3:
<               jy = ky - 1;
<               if (jy < 0)
<                 jy = Ysyssize - 1;
<               jx = kx;
<               jz = kz;
<               break;
<             case 4:
<               jz = ky + 1;
<               if (jz > (Zsyssize - 1))
<                 jz = 0;
<               jx = kx;
<               jy = ky;
<               break;
<             case 5:
<               jz = ky - 1;
<               if (jz < 0)
<                 jz = Zsyssize - 1;
<               jx = kx;
<               jy = ky;
<               break;
<             default:
<               break;
<             }
---
>                         x2 += checkbc(x2,Xsyssize);
>                         y2 += checkbc(y2,Ysyssize);
>                         z2 += checkbc(z2,Zsyssize);
4458,4461c4093,4095
<             /***
<              *    If the neighboring pixel is porosity,
<              *    perhaps deactivate this pixel face
<              ***/
---
>                         if (Mic[x2][y2][z2] == POROSITY) porecnt++;
>                         if (Mic[x2][y2][z2] == CRACKP) crackcnt++;
>                     }
4463,4474c4097,4106
<             if (Mic[jx][jy][jz] == POROSITY || Mic[jx][jy][jz] == CRACKP) {
< 
<               prdeact = ran1(Seed);
<               if (prdeact < fracdeact) {
< 
<                 /***
<                  *    Deactivation is by multiplying
<                  *    by prime factor
<                  ***/
< 
<                 Deactivated[kx][ky][kz] *= Primevalues[faceid];
<               }
---
>                     if ((porecnt >= crackcnt) && curid == CRACKP) {
>                         Mic[x1][y1][z1] = POROSITY;
>                         Count[CRACKP]--;
>                         Count[POROSITY]++;
>                     } else if ((crackcnt < porecnt) && curid == POROSITY) {
>                         Mic[x1][y1][z1] = CRACKP;
>                         Count[CRACKP]++;
>                         Count[POROSITY]--;
>                     }
>                 }
4476d4107
<           }
4477a4109
>     }
4479,4481c4111
<       } /* End of loop over Z */
<     } /* End of loop over Y */
<   } /* End of loop over X */
---
>     return;
4485,4501c4115,4129
<  *    performreactivation
<  *
<  *     Reactivate a fraction (fracreact) of the
<  *     a deactivated surface to allow its hydrating
<  *
<  *     Arguments:    int phase id to reactivate
<  *                 float fraction to deactivate
<  *                 int finalreact
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        ran1
<  *    Called by:    main program
<  ***/
< void performreactivation(int pid, float fracreact, int finalreact) {
<   int kx, ky, kz, faceid, cv;
<   float prreact;
---
> *    countphase
> *
> *       Scan microstructure and determine the number of voxels of a particular phase
> *
> *     Arguments:    int phid (phase id to check)
> *
> *     Returns:    int number of voxels of that phase
> *
> *    Calls:        nothing
> *    Called by:    main
> ***/
> int countphase(int phid)
> {
>     register int xid,yid,zid;
>     int cntphase = 0;
4503c4131
<   /* Scan entire 3-D microstructure */
---
>     /* Scan the entire 3-D microstructure */
4505,4507c4133,4135
<   for (kx = 0; kx < Xsyssize; kx++) {
<     for (ky = 0; ky < Ysyssize; ky++) {
<       for (kz = 0; kz < Zsyssize; kz++) {
---
>     for (zid = 0; zid < Zsyssize; zid++) {
>         for (yid = 0; yid < Ysyssize; yid++) {
>             for (xid = 0; xid < Xsyssize; xid++) {
4509c4137
<         if (Mic[kx][ky][kz] == pid) {
---
>                 if (Mic[xid][yid][zid] == phid) cntphase += 1;
4511,4532c4139,4141
<           for (faceid = 0; faceid < 6; faceid++) {
<             cv = Deactivated[kx][ky][kz] % Primevalues[faceid];
<             if (!cv) {
<               prreact = ran1(Seed);
<               if ((prreact < fracreact) || (finalreact)) {
< 
<                 /***
<                  *    Reactivation is by dividing by
<                  *    prime factor
<                  ***/
< 
<                 Deactivated[kx][ky][kz] /= Primevalues[faceid];
<               }
<             }
< 
<           } /* End of loop over faces of pixel */
<         }
< 
<       } /* End of loop over Z */
<     } /* End of loop over Y */
<   } /* End of loop over X */
< }
---
>             }        /* end of xid */
>         }            /* end of yid */
>     }                /* end of zid */
4534,4584c4143
< /***
<  *    chckedge
<  *
<  *     Check if a pixel located at (xck,yck,zck) is on a
<  *     surface with pore space in the 3D system
<  *
<  *     Arguments:    int phase to check
<  *                 integer x,y, and z coordinates to check
<  *
<  *     Returns:    1 if on a surface, 0 otherwise
<  *
<  *    Calls:        no other routines
<  *    Called by:    passone
<  ***/
< int chckedge(int phase, int xck, int yck, int zck) {
<   int edgeback = 0;
<   int x2, y2, z2;
<   int ip;
< 
<   /***
<    *    Check all neighboring pixels (6, 18, or 26)
<    *    and use periodic boundary conditions
<    *
<    *    Change number of NEIGHBORS in header file
<    *    called disrealnew.h
<    ***/
< 
<   for (ip = 0; ((ip < NEIGHBORS) && (!edgeback)); ip++) {
< 
<     x2 = xck + Xoff[ip];
<     y2 = yck + Yoff[ip];
<     z2 = zck + Zoff[ip];
< 
<     x2 += checkbc(x2, Xsyssize);
<     y2 += checkbc(y2, Ysyssize);
<     z2 += checkbc(z2, Zsyssize);
< 
<     if (Mic[x2][y2][z2] == POROSITY || Mic[x2][y2][z2] == CRACKP ||
<         Mic[x2][y2][z2] == CSH || Mic[x2][y2][z2] == POZZCSH ||
<         Mic[x2][y2][z2] == SLAGCSH) {
<       edgeback = 1;
<     }
<     /* JWB: Added this block as a trial to prevent adjacent
<      * particles from blocking each other's dissolution
<      */
<     else if (Micpart[xck][yck][zck] != Micpart[x2][y2][z2]) {
<       edgeback = 1;
<     }
<   }
< 
<   return (edgeback);
---
>     return (cntphase);
4588,4604c4147,4164
<  *    resetcrackpores
<  *
<  *     Scans over all pixels.  If a pixel of type POROSITY or CRACKP
<  *     is found, then checks nearest neighbors to decide majority type
<  *     of pore pixels surrounding a pixel at position xck,yck,zck
<  *
<  *     Arguments:    none
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        no other routines
<  *    Called by:    main function
<  ***/
< void resetcrackpores(void) {
<   int porecnt, crackcnt, curid;
<   int x1, y1, z1, x2, y2, z2;
<   int ip;
---
> *    passone
> *
> *     First pass through microstructure during dissolution.
> *     Low and high indicate the phase ID range to check for
> *     surface sites.
> *
> *     Arguments:    int low, high (phase id range to check)
> *                 int cycid
> *                 int cshexflag (0 or 1 only)
> *
> *     Returns:    nothing
> *
> *    Calls:        chckedge
> *    Called by:    dissolve
> ***/
> void passone(int low, int high, int cycid, int cshexflag)
> {
>     int i,xid,yid,zid,phid,edgef,phread,cshcyc;
4606,4612c4166
<   /***
<    *    Check all neighboring pixels (6, 18, or 26)
<    *    and use periodic boundary conditions
<    *
<    *    Change number of NEIGHBORS in header file
<    *    called disrealnew.h
<    ***/
---
>     /* Gypready used to determine if any soluble gypsum remains */
4614,4617c4168,4170
<   for (x1 = 0; x1 < Zsyssize; x1++) {
<     for (y1 = 0; y1 < Ysyssize; y1++) {
<       for (z1 = 0; z1 < Zsyssize; z1++) {
<         if (Mic[x1][y1][z1] == POROSITY || Mic[x1][y1][z1] == CRACKP) {
---
>     if ((low <= GYPSUM) && (GYPSUM <= high)) {
>         Gypready = 0;
>     }
4619,4621c4172
<           curid = Mic[x1][y1][z1];
<           porecnt = crackcnt = 0;
<           for (ip = 0; ip < NEIGHBORS; ip++) {
---
>     /* Zero out count for the relevant phases */
4623,4647c4174,4175
<             x2 = x1 + Xoff[ip];
<             y2 = y1 + Yoff[ip];
<             z2 = z1 + Zoff[ip];
< 
<             x2 += checkbc(x2, Xsyssize);
<             y2 += checkbc(y2, Ysyssize);
<             z2 += checkbc(z2, Zsyssize);
< 
<             if (Mic[x2][y2][z2] == POROSITY)
<               porecnt++;
<             if (Mic[x2][y2][z2] == CRACKP)
<               crackcnt++;
<           }
< 
<           if ((porecnt >= crackcnt) && curid == CRACKP) {
<             Mic[x1][y1][z1] = POROSITY;
<             Count[CRACKP]--;
<             Count[POROSITY]++;
<           } else if ((crackcnt < porecnt) && curid == POROSITY) {
<             Mic[x1][y1][z1] = CRACKP;
<             Count[CRACKP]++;
<             Count[POROSITY]--;
<           }
<         }
<       }
---
>     for (i = low; i <= high; i++) {
>         Count[i] = 0;
4649d4176
<   }
4651,4652c4178
<   return;
< }
---
>     /* Scan the entire 3-D microstructure */
4654,4669c4180,4182
< /***
<  *    countphase
<  *
<  *       Scan microstructure and determine the number of voxels of a
<  *particular phase
<  *
<  *     Arguments:    int phid (phase id to check)
<  *
<  *     Returns:    int number of voxels of that phase
<  *
<  *    Calls:        nothing
<  *    Called by:    main
<  ***/
< int countphase(int phid) {
<   register int xid, yid, zid;
<   int cntphase = 0;
---
>     for (zid = 0; zid < Zsyssize; zid++) {
>         for (yid = 0; yid < Ysyssize; yid++) {
>             for (xid = 0; xid < Xsyssize; xid++) {
4671c4184
<   /* Scan the entire 3-D microstructure */
---
>                 phread = Mic[xid][yid][zid];
4673,4675c4186
<   for (xid = 0; xid < Xsyssize; xid++) {
<     for (yid = 0; yid < Ysyssize; yid++) {
<       for (zid = 0; zid < Zsyssize; zid++) {
---
>                 /* Update heat data and water consumed for solid CSH */
4677,4678c4188,4192
<         if (Mic[xid][yid][zid] == phid)
<           cntphase += 1;
---
>                 if ((cshexflag) && (phread == CSH)) {
>                     cshcyc = Cshage[xid][yid][zid];
>                     Heatsum += Heatf[CSH] / Molarvcsh[cshcyc];
>                     Molesh2o += Watercsh[cshcyc] / Molarvcsh[cshcyc];
>                 }
4680,4682c4194
<       } /* end of xid */
<     } /* end of yid */
<   } /* end of zid */
---
>                 /* Identify phase and update count */
4684,4685c4196
<   return (cntphase);
< }
---
>                 phid = NPHASES + 10; /* Clearly out of bounds */
4687,4704c4198
< /***
<  *    passone
<  *
<  *     First pass through microstructure during dissolution.
<  *     Low and high indicate the phase ID range to check for
<  *     surface sites.
<  *
<  *     Arguments:    int low, high (phase id range to check)
<  *                 int cycid
<  *                 int cshexflag (0 or 1 only)
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        chckedge
<  *    Called by:    dissolve
<  ***/
< void passone(int low, int high, int cycid, int cshexflag) {
<   int i, xid, yid, zid, phid, edgef, phread, cshcyc;
---
>                 for (i = low; ((i <= high) && (phid == NPHASES + 10)); i++) {
4706c4200
<   /* Gypready used to determine if any soluble gypsum remains */
---
>                     if (Mic[xid][yid][zid] == i) {
4708,4710c4202
<   if ((low <= GYPSUM) && (GYPSUM <= high)) {
<     Gypready = 0;
<   }
---
>                         phid = i;
4712c4204
<   /* Zero out count for the relevant phases */
---
>                         /* Update count for this phase */
4714,4716c4206
<   for (i = low; i <= high; i++) {
<     Count[i] = 0;
<   }
---
>                         Count[i]++;
4718c4208,4210
<   /* Scan the entire 3-D microstructure */
---
>                         if ((i == GYPSUM) || (i == GYPSUMS)) {
>                             Gypready++;
>                         }
4720,4722c4212
<   for (xid = 0; xid < Xsyssize; xid++) {
<     for (yid = 0; yid < Ysyssize; yid++) {
<       for (zid = 0; zid < Zsyssize; zid++) {
---
>                         /* If first cycle, then accumulate initial counts */
4724c4214,4215
<         phread = Mic[xid][yid][zid];
---
>                         if ((cycid == 1) ||
>                                 ( (cycid == 0) && (Ncyc == 0) )) {
4726c4217,4221
<         /* Update heat data and water consumed for solid CSH */
---
>                             /***
>                             *    Ordered in terms of likely volume
>                             *    fractions (largest to smallest) to
>                             *    speed execution
>                             ***/
4728,4760c4223,4262
<         if ((cshexflag) && (phread == CSH)) {
<           cshcyc = Cshage[xid][yid][zid];
<           Heatsum += Heatf[CSH] / Molarvcsh[cshcyc];
<           Molesh2o += Watercsh[cshcyc] / Molarvcsh[cshcyc];
<         }
< 
<         /* Identify phase and update count */
< 
<         phid = NPHASES + 10; /* Clearly out of bounds */
< 
<         for (i = low; ((i <= high) && (phid == NPHASES + 10)); i++) {
< 
<           if (Mic[xid][yid][zid] == i) {
< 
<             phid = i;
< 
<             /* Update count for this phase */
< 
<             Count[i]++;
< 
<             if ((i == GYPSUM) || (i == GYPSUMS)) {
<               Gypready++;
<             }
< 
<             /* If first cycle, then accumulate initial counts */
< 
<             if ((cycid == 1) || ((cycid == 0) && (Ncyc == 0))) {
< 
<               /***
<                *    Ordered in terms of likely volume
<                *    fractions (largest to smallest) to
<                *    speed execution
<                ***/
---
>                             if (i == POROSITY) {
>                                 Porinit++;
>                             } else if (i == C3S) {
>                                 C3sinit++;
>                             } else if (i == C2S) {
>                                 C2sinit++;
>                             } else if (i == C3A) {
>                                 C3ainit++;
>                             } else if (i == OC3A) {
>                                 Oc3ainit++;
>                             } else if (i == C4AF) {
>                                 C4afinit++;
>                             } else if (i == K2SO4) {
>                                 Ksulfinit++;
>                             } else if (i == NA2SO4) {
>                                 Nasulfinit++;
>                             } else if (i == GYPSUM) {
>                                 Ncsbar++;
>                             } else if (i == GYPSUMS) {
>                                 Ncsbar++;
>                             } else if (i == ANHYDRITE) {
>                                 Anhinit++;
>                             } else if (i == HEMIHYD) {
>                                 Heminit++;
>                             } else if (i == SFUME || i == AMSIL) {
>                                 Nsilica++;
>                             } else if (i == SLAG) {
>                                 Slaginit++;
>                             } else if (i == FREELIME) {
>                                 Freelimeinit++;
>                             } else if (i == ETTR) {
>                                 Netbar++;
>                             } else if (i == ETTRC4AF) {
>                                 Netbar++;
>                             } else if (i == CRACKP) {
>                                 Crackpinit++;
>                             }
>                         }
>                     }
>                 }
4762,4801c4264,4267
<               if (i == POROSITY) {
<                 Porinit++;
<               } else if (i == C3S) {
<                 C3sinit++;
<               } else if (i == C2S) {
<                 C2sinit++;
<               } else if (i == C3A) {
<                 C3ainit++;
<               } else if (i == OC3A) {
<                 Oc3ainit++;
<               } else if (i == C4AF) {
<                 C4afinit++;
<               } else if (i == K2SO4) {
<                 Ksulfinit++;
<               } else if (i == NA2SO4) {
<                 Nasulfinit++;
<               } else if (i == GYPSUM) {
<                 Ncsbar++;
<               } else if (i == GYPSUMS) {
<                 Ncsbar++;
<               } else if (i == ANHYDRITE) {
<                 Anhinit++;
<               } else if (i == HEMIHYD) {
<                 Heminit++;
<               } else if (i == SFUME || i == AMSIL) {
<                 Nsilica++;
<               } else if (i == SLAG) {
<                 Slaginit++;
<               } else if (i == FREELIME) {
<                 Freelimeinit++;
<               } else if (i == ETTR) {
<                 Netbar++;
<               } else if (i == ETTRC4AF) {
<                 Netbar++;
<               } else if (i == CRACKP) {
<                 Crackpinit++;
<               }
<             }
<           }
<         }
---
>                 /***
>                 *    Currently do NOT identify
>                 *    SURFACE pixels of K2SO4 and NA2SO4
>                 ***/
4803,4806c4269,4270
<         /***
<          *    Currently do NOT identify
<          *    SURFACE pixels of K2SO4 and NA2SO4
<          ***/
---
>                 if (phid != NPHASES + 10 && Mic[xid][yid][zid] != K2SO4
>                     && Mic[xid][yid][zid] != NA2SO4) {
4808,4809c4272,4275
<         if (phid != NPHASES + 10 && Mic[xid][yid][zid] != K2SO4 &&
<             Mic[xid][yid][zid] != NA2SO4) {
---
>                     /***
>                     *    If phase is soluble, see if it is
>                     *    in contact with porosity
>                     ***/
4811,4814c4277,4279
<           /***
<            *    If phase is soluble, see if it is
<            *    in contact with porosity
<            ***/
---
>                     if ((cycid != 0) && (Soluble[phid] == 1)) {
>                         edgef = chckedge(phid,xid,yid,zid);
>                         if (edgef == 1) {
4816,4818c4281,4286
<           if ((cycid != 0) && (Soluble[phid] == 1)) {
<             edgef = chckedge(phid, xid, yid, zid);
<             if (edgef == 1) {
---
>                             /***
>                             *    Surface eligible species has an
>                             *    ID that is OFFSET greater than its
>                             *    original value.  Means that it is
>                             *    ready for dissolution.
>                             ***/
4820,4825c4288,4291
<               /***
<                *    Surface eligible species has an
<                *    ID that is OFFSET greater than its
<                *    original value.  Means that it is
<                *    ready for dissolution.
<                ***/
---
>                                 Mic[xid][yid][zid] += (int)(OFFSET);
>                         }
>                     }
>                 }
4827,4834c4293,4295
<               Mic[xid][yid][zid] += (int)(OFFSET);
<             }
<           }
<         }
< 
<       } /* end of xid */
<     } /* end of yid */
<   } /* end of zid */
---
>             }        /* end of xid */
>         }            /* end of yid */
>     }                /* end of zid */
4838,4856c4299,4318
<  *    loccsh
<  *
<  *     Place a diffusing CSH species near dissolution source
<  *     at (xcur,ycur,zcur)
<  *
<  *     Arguments:    int x,y, and z coordinates
<  *                 int id of pore type used to create the diffusing species
<  *                 (change added 24 May 2004)
<  *
<  *     Returns:    1 if species is placed, 0 otherwise
<  *
<  *    Calls:        no other routines
<  *    Called by:    dissolve
<  ***/
< int loccsh(int xcur, int ycur, int zcur, int sourcepore) {
<   int effort, tries, xmod, ymod, zmod;
<   int maxtries = 500;
<   int halfbox;
<   struct Ants *antnew;
---
> *    loccsh
> *
> *     Place a diffusing CSH species near dissolution source
> *     at (xcur,ycur,zcur)
> *
> *     Arguments:    int x,y, and z coordinates
> *                 int id of pore type used to create the diffusing species
> *                 (change added 24 May 2004)
> *
> *     Returns:    1 if species is placed, 0 otherwise
> *
> *    Calls:        no other routines
> *    Called by:    dissolve
> ***/
> int loccsh(int xcur, int ycur, int zcur, int sourcepore)
> {
>     int effort,tries,xmod,ymod,zmod;
>     int maxtries=500;
>     int halfbox;
>     struct Ants *antnew;
4858,4859c4320,4321
<   /* effort indicates if appropriate location found */
<   effort = 0;
---
>     /* effort indicates if appropriate location found */
>     effort = 0;
4861c4323
<   tries = 0;
---
>     tries = 0;
4863c4325
<   /* Execute up to maxtries tries in immediate vicinity */
---
>     /* Execute up to maxtries tries in immediate vicinity */
4865,4866c4327,4328
<   halfbox = Distloccsh / 2;
<   while ((!effort) && (tries < maxtries)) {
---
>     halfbox = Distloccsh / 2;
>     while ((!effort) && (tries < maxtries)) {
4868,4877c4330,4336
<     tries++;
<     xmod = (-halfbox) + (int)(Distloccsh * ran1(Seed));
<     ymod = (-halfbox) + (int)(Distloccsh * ran1(Seed));
<     zmod = (-halfbox) + (int)(Distloccsh * ran1(Seed));
<     if (xmod > halfbox)
<       xmod = halfbox;
<     if (ymod > halfbox)
<       ymod = halfbox;
<     if (zmod > halfbox)
<       zmod = halfbox;
---
>         tries++;
>         xmod = (-halfbox) + (int)(Distloccsh * ran1(Seed));
>         ymod = (-halfbox) + (int)(Distloccsh * ran1(Seed));
>         zmod = (-halfbox) + (int)(Distloccsh * ran1(Seed));
>         if (xmod > halfbox) xmod = halfbox;
>         if (ymod > halfbox) ymod = halfbox;
>         if (zmod > halfbox) zmod = halfbox;
4879,4881c4338,4340
<     xmod += xcur;
<     ymod += ycur;
<     zmod += zcur;
---
>         xmod += xcur;
>         ymod += ycur;
>         zmod += zcur;
4883c4342
<     /* Periodic boundary conditions */
---
>         /* Periodic boundary conditions */
4885,4887c4344,4346
<     xmod += checkbc(xmod, Xsyssize);
<     ymod += checkbc(ymod, Ysyssize);
<     zmod += checkbc(zmod, Zsyssize);
---
>         xmod += checkbc(xmod,Xsyssize);
>         ymod += checkbc(ymod,Ysyssize);
>         zmod += checkbc(zmod,Zsyssize);
4889,4893c4348,4352
<     if (Mic[xmod][ymod][zmod] == sourcepore) {
<       effort = 1;
<       Mic[xmod][ymod][zmod] = DIFFCSH;
<       Nmade++;
<       Ngoing++;
---
>         if (Mic[xmod][ymod][zmod] == sourcepore) {
>             effort = 1;
>             Mic[xmod][ymod][zmod] = DIFFCSH;
>             Nmade++;
>             Ngoing++;
4895,4900c4354,4359
<       /***
<        *    Add this diffusing CSH species
<        *    to the linked list.  May want to look at
<        *    allocating space for new ants in chunks of,
<        *    say, 50, rather than one at a time.
<        ***/
---
>             /***
>             *    Add this diffusing CSH species
>             *    to the linked list.  May want to look at
>             *    allocating space for new ants in chunks of,
>             *    say, 50, rather than one at a time.
>             ***/
4902,4907c4361,4366
<       antnew = (struct Ants *)malloc(Antsize);
<       antnew->x = xmod;
<       antnew->y = ymod;
<       antnew->z = zmod;
<       antnew->id = DIFFCSH;
<       antnew->cycbirth = Cyccnt;
---
>             antnew = (struct Ants *)malloc(Antsize);
>             antnew->x = xmod;
>             antnew->y = ymod;
>             antnew->z = zmod;
>             antnew->id = DIFFCSH;
>             antnew->cycbirth = Cyccnt;
4909,4912c4368,4371
<       /***
<        *    Now connect this ant structure to
<        *    end of linked list
<        ***/
---
>             /***
>             *    Now connect this ant structure to
>             *    end of linked list
>             ***/
4914,4917c4373,4377
<       antnew->prevant = Tailant;
<       Tailant->nextant = antnew;
<       antnew->nextant = NULL;
<       Tailant = antnew;
---
>             antnew->prevant = Tailant;
>             Tailant->nextant = antnew;
>             antnew->nextant = NULL;
>             Tailant = antnew;
>         }
4919d4378
<   }
4921c4380
<   return (effort);
---
>     return(effort);
4925,4940c4384,4400
<  *    countbox
<  *
<  *     Count the number of pore pixels within a cube of
<  *     size boxsize, centered at (qx,qy,qz)
<  *
<  *     Arguments:    int boxsize
<  *                 int x,y, and z coordinates of box center
<  *
<  *     Returns:    int number of pore pixels found within box
<  *
<  *    Calls:        no other routines
<  *    Called by:    makeinert
<  ***/
< int countbox(int boxsize, int qx, int qy, int qz) {
<   int nfound, ix, iy, iz, qxlo, qxhi, qylo, qyhi, qzlo, qzhi;
<   int hx, hy, hz, boxhalf;
---
> *    countbox
> *
> *     Count the number of pore pixels within a cube of
> *     size boxsize, centered at (qx,qy,qz)
> *
> *     Arguments:    int boxsize
> *                 int x,y, and z coordinates of box center
> *
> *     Returns:    int number of pore pixels found within box
> *
> *    Calls:        no other routines
> *    Called by:    makeinert
> ***/
> int countbox(int boxsize, int qx, int qy, int qz)
> {
>     int nfound,ix,iy,iz,qxlo,qxhi,qylo,qyhi,qzlo,qzhi;
>     int hx,hy,hz,boxhalf;
4942,4949c4402,4409
<   boxhalf = boxsize / 2;
<   nfound = 0;
<   qxlo = qx - boxhalf;
<   qxhi = qx + boxhalf;
<   qylo = qy - boxhalf;
<   qyhi = qy + boxhalf;
<   qzlo = qz - boxhalf;
<   qzhi = qz + boxhalf;
---
>     boxhalf = boxsize / 2;
>     nfound = 0;
>     qxlo = qx - boxhalf;
>     qxhi = qx + boxhalf;
>     qylo = qy - boxhalf;
>     qyhi = qy + boxhalf;
>     qzlo = qz - boxhalf;
>     qzhi = qz + boxhalf;
4951,4954c4411,4414
<   /***
<    *    Count the number of requisite pixels in the
<    *    3-D cube box using periodic boundaries
<    ***/
---
>     /***
>     *    Count the number of requisite pixels in the
>     *    3-D cube box using periodic boundaries
>     ***/
4956,4958c4416,4418
<   for (ix = qxlo; ix <= qxhi; ix++) {
<     hx = ix;
<     hx += checkbc(hx, Xsyssize);
---
>     for (ix = qxlo; ix <= qxhi; ix++) {
>         hx = ix;
>         hx += checkbc(hx,Xsyssize);
4960,4962c4420,4422
<     for (iy = qylo; iy <= qyhi; iy++) {
<       hy = iy;
<       hy += checkbc(hy, Ysyssize);
---
>         for (iy = qylo; iy <= qyhi; iy++) {
>             hy = iy;
>             hy += checkbc(hy,Ysyssize);
4964,4966c4424,4426
<       for (iz = qzlo; iz <= qzhi; iz++) {
<         hz = iz;
<         hz += checkbc(hz, Zsyssize);
---
>             for (iz = qzlo; iz <= qzhi; iz++) {
>                 hz = iz;
>                 hz += checkbc(hz,Zsyssize);
4968,4971c4428,4431
<         /***
<          *    Count if porosity, diffusing species,
<          *    or empty porosity
<          ***/
---
>                 /***
>                 *    Count if porosity, diffusing species,
>                 *    or empty porosity
>                 ***/
4973c4433,4434
<         if ((Mic[hx][hy][hz] == POROSITY) || (Mic[hx][hy][hz] > NSPHASES)) {
---
>                 if ((Mic[hx][hy][hz] == POROSITY)
>                     || (Mic[hx][hy][hz] > NSPHASES)) {
4975,4976c4436,4437
<           nfound++;
<         }
---
>                     nfound++;
>                    }
4978,4980c4439,4441
<       } /* End of loop over z */
<     } /* End of loop over y */
<   } /* End of loop over x */
---
>             }    /* End of loop over z */
>         }        /* End of loop over y */
>     }            /* End of loop over x */
4982c4443
<   return (nfound);
---
>     return(nfound);
4986,5091c4447,4572
<  *    makeinert
<  *
<  *    Create ndesire pixels of empty pore space to simulate
<  *    self-desiccation
<  *
<  *     Arguments:    int ndesire (number to create)
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        countbox
<  *    Called by:    dissolve
<  ***/
< void makeinert(int ndesire) {
<   int idesire;
<   int px, py, pz, placed, cntpore, cntmax;
<   struct Togo *headtogo, *tailtogo, *newtogo, *lasttogo, *onetogo;
< 
<   /***
<    *    First allocate and initialize the first member
<    *    of the linked list
<    ***/
< 
<   headtogo = (struct Togo *)malloc(Togosize);
<   headtogo->x = headtogo->y = headtogo->z = (-1);
<   headtogo->npore = 0;
<   headtogo->nexttogo = NULL;
<   headtogo->prevtogo = NULL;
<   tailtogo = headtogo;
<   cntmax = 0;
< 
<   /***
<    *    Add needed number of elements to the end of the list
<    *    Consider allocating the space in chunks of, say, 50,
<    *    instead of one at a time to speed up execution
<    ***/
< 
<   for (idesire = 2; idesire <= ndesire; idesire++) {
<     newtogo = (struct Togo *)malloc(Togosize);
<     newtogo->npore = 0;
<     newtogo->x = newtogo->y = newtogo->z = (-1);
<     tailtogo->nexttogo = newtogo;
<     newtogo->prevtogo = tailtogo;
<     tailtogo = newtogo;
<   }
< 
<   /* Now scan the microstructure and RANK the sites */
< 
<   for (pz = 0; pz < Zsyssize; pz++) {
<     for (py = 0; py < Ysyssize; py++) {
<       for (px = 0; px < Xsyssize; px++) {
< 
<         if (Mic[px][py][pz] == POROSITY) {
<           cntpore = countbox(Cubesize, px, py, pz);
< 
<           if (cntpore > cntmax)
<             cntmax = cntpore;
< 
<           /***
<            *    Store this site value at appropriate place in
<            *    sorted linked list
<            ***/
< 
<           if (cntpore > (tailtogo->npore)) {
<             placed = 0;
<             lasttogo = tailtogo;
<             while (!placed) {
<               newtogo = lasttogo->prevtogo;
<               if (!newtogo) {
<                 placed = 2;
<               } else if (cntpore <= (newtogo->npore)) {
<                 placed = 1;
<               }
< 
<               if (!placed)
<                 lasttogo = newtogo;
<             }
< 
<             onetogo = (struct Togo *)malloc(Togosize);
<             onetogo->x = px;
<             onetogo->y = py;
<             onetogo->z = pz;
<             onetogo->npore = cntpore;
< 
<             /* Insertion at the head of the list */
< 
<             if (placed == 2) {
<               onetogo->prevtogo = NULL;
<               onetogo->nexttogo = headtogo;
<               headtogo->prevtogo = onetogo;
<               headtogo = onetogo;
<             }
< 
<             if (placed == 1) {
<               onetogo->nexttogo = lasttogo;
<               onetogo->prevtogo = newtogo;
<               lasttogo->prevtogo = onetogo;
<               newtogo->nexttogo = onetogo;
<             }
< 
<             /* Eliminate the last element */
< 
<             lasttogo = tailtogo;
<             tailtogo = tailtogo->prevtogo;
<             tailtogo->nexttogo = NULL;
<             free(lasttogo);
<           }
---
> *    makeinert
> *
> *    Create ndesire pixels of empty pore space to simulate
> *    self-desiccation
> *
> *     Arguments:    int ndesire (number to create)
> *
> *     Returns:    nothing
> *
> *    Calls:        countbox
> *    Called by:    dissolve
> ***/
> void makeinert(int ndesire)
> {
>     int idesire;
>     int px,py,pz,placed,cntpore,cntmax;
>     struct Togo *headtogo,*tailtogo,*newtogo,*lasttogo,*onetogo;
> 
>     /***
>     *    First allocate and initialize the first member
>     *    of the linked list
>     ***/
> 
>     headtogo = (struct Togo *)malloc(Togosize);
>     headtogo->x = headtogo->y = headtogo->z = (-1);
>     headtogo->npore = 0;
>     headtogo->nexttogo = NULL;
>     headtogo->prevtogo = NULL;
>     tailtogo = headtogo;
>     cntmax = 0;
> 
>     /***
>     *    Add needed number of elements to the end of the list
>     *    Consider allocating the space in chunks of, say, 50,
>     *    instead of one at a time to speed up execution
>     ***/
> 
>     for (idesire = 2; idesire <= ndesire; idesire++) {
>         newtogo = (struct Togo *)malloc(Togosize);
>         newtogo->npore = 0;
>         newtogo->x = newtogo->y = newtogo->z = (-1);
>         tailtogo->nexttogo = newtogo;
>         newtogo->prevtogo = tailtogo;
>         tailtogo = newtogo;
>     }
> 
>     /* Now scan the microstructure and RANK the sites */
> 
>     for (pz = 0; pz < Zsyssize; pz++) {
>         for (py = 0; py < Ysyssize; py++) {
>             for (px = 0; px < Xsyssize; px++) {
> 
>                 if (Mic[px][py][pz] == POROSITY) {
>                     cntpore = countbox(Cubesize,px,py,pz);
> 
>                     if (cntpore > cntmax) cntmax = cntpore;
> 
>                     /***
>                     *    Store this site value at appropriate place in
>                     *    sorted linked list
>                     ***/
> 
>                     if (cntpore > (tailtogo->npore)) {
>                         placed = 0;
>                         lasttogo = tailtogo;
>                         while (!placed) {
>                             newtogo = lasttogo->prevtogo;
>                             if (!newtogo) {
>                                 placed = 2;
>                             } else if (cntpore <= (newtogo->npore)) {
>                                 placed = 1;
>                             }
> 
>                             if (!placed) lasttogo = newtogo;
>                         }
> 
>                         onetogo = (struct Togo *)malloc(Togosize);
>                         onetogo->x = px;
>                         onetogo->y = py;
>                         onetogo->z = pz;
>                         onetogo->npore = cntpore;
> 
>                         /* Insertion at the head of the list */
> 
>                         if (placed == 2) {
>                             onetogo->prevtogo = NULL;
>                             onetogo->nexttogo = headtogo;
>                             headtogo->prevtogo = onetogo;
>                             headtogo = onetogo;
>                         }
> 
>                         if (placed == 1) {
>                             onetogo->nexttogo = lasttogo;
>                             onetogo->prevtogo = newtogo;
>                             lasttogo->prevtogo = onetogo;
>                             newtogo->nexttogo = onetogo;
>                         }
> 
>                         /* Eliminate the last element */
> 
>                         lasttogo = tailtogo;
>                         tailtogo = tailtogo->prevtogo;
>                         tailtogo->nexttogo = NULL;
>                         free(lasttogo);
>                     }
>                 }
> 
>             }    /* End of loop in z */
>         }        /* End of loop in y */
>     }            /* End of loop in x */
> 
>     /***
>     *    Now remove the sites starting at the
>     *    head of the list and free all of the
>     *    used memory
>     ***/
> 
>     for (idesire = 1; idesire <= ndesire; idesire++) {
>         px = headtogo->x;
>         py = headtogo->y;
>         pz = headtogo->z;
> 
>         if (px != (-1)) {
>             Mic[px][py][pz] = EMPTYP;
>             Count[POROSITY]--;
>             Count[EMPTYP]++;
5094,5112c4575,4577
<       } /* End of loop in z */
<     } /* End of loop in y */
<   } /* End of loop in x */
< 
<   /***
<    *    Now remove the sites starting at the
<    *    head of the list and free all of the
<    *    used memory
<    ***/
< 
<   for (idesire = 1; idesire <= ndesire; idesire++) {
<     px = headtogo->x;
<     py = headtogo->y;
<     pz = headtogo->z;
< 
<     if (px != (-1)) {
<       Mic[px][py][pz] = EMPTYP;
<       Count[POROSITY]--;
<       Count[EMPTYP]++;
---
>         lasttogo=headtogo;
>         headtogo=headtogo->nexttogo;
>         free(lasttogo);
5115,5118c4580,4584
<     lasttogo = headtogo;
<     headtogo = headtogo->nexttogo;
<     free(lasttogo);
<   }
---
>     /***
>     *    If only small cubes of porosity were found,
>     *    then adjust Cubesize to have a more efficient
>     *    search in the future
>     ***/
5120,5128c4586,4589
<   /***
<    *    If only small cubes of porosity were found,
<    *    then adjust Cubesize to have a more efficient
<    *    search in the future
<    ***/
< 
<   if (Cubesize > CUBEMIN) {
<     if ((2 * cntmax) < (Cubesize * Cubesize * Cubesize)) {
<       Cubesize -= 2;
---
>     if (Cubesize > CUBEMIN) {
>         if ((2 * cntmax) < (Cubesize * Cubesize * Cubesize)) {
>             Cubesize -= 2;
>         }
5130d4590
<   }
5134,5150c4594,4611
<  *    extslagcsh
<  *
<  *     Add extra SLAGCSH when SLAG reacts at position
<  *     (xpres,ypres,zpres)
<  *
<  *     Arguments:    int x,y, and z coordinates
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        moveone, edgecnt
<  *    Called by:    dissolve
<  ***/
< void extslagcsh(int xpres, int ypres, int zpres) {
<   int check, sump, xchr, ychr, zchr, fchr, i1, action, numnear;
<   int maxtries = 100;
<   int maxxtries = 5000;
<   int tries;
---
> *    extslagcsh
> *
> *     Add extra SLAGCSH when SLAG reacts at position
> *     (xpres,ypres,zpres)
> *
> *     Arguments:    int x,y, and z coordinates
> *
> *     Returns:    nothing
> *
> *    Calls:        moveone, edgecnt
> *    Called by:    dissolve
> ***/
> void extslagcsh(int xpres, int ypres, int zpres)
> {
>     int check,sump,xchr,ychr,zchr,fchr,i1,action,numnear;
>     int maxtries = 100;
>     int maxxtries = 5000;
>     int tries;
5152,5157c4613,4618
<   /***
<    *    First try 6 neighboring locations until
<    *        a) successful,
<    *        b) all 6 sites are tried, or
<    *        c) 100 tries are made
<    ***/
---
>     /***
>     *    First try 6 neighboring locations until
>     *        a) successful,        
>     *        b) all 6 sites are tried, or
>     *        c) 100 tries are made 
>     ***/
5159,5160c4620,4621
<   fchr = 0;
<   sump = 1;
---
>     fchr = 0;
>     sump = 1;
5162c4623,4629
<   for (i1 = 1; ((i1 <= maxtries) && (!fchr) && (sump != 30030)); i1++) {
---
>     for (i1 = 1; ((i1 <= maxtries) && (!fchr)
>                                     && (sump != 30030)); i1++) {
>         
>         /***
>         *    Determine location of neighbor
>         *    (using periodic boundaries)
>         ***/
5164,5167c4631,4634
<     /***
<      *    Determine location of neighbor
<      *    (using periodic boundaries)
<      ***/
---
>         xchr = xpres;
>         ychr = ypres;
>         zchr = zpres;
>         action = 0;
5169,5172c4636,4637
<     xchr = xpres;
<     ychr = ypres;
<     zchr = zpres;
<     action = 0;
---
>         sump *= moveone(&xchr,&ychr,&zchr,&action,sump);
>         if (!action && (Verbose == 1)) printf("Error in value of action in extpozz \n");
5174,5176c4639
<     sump *= moveone(&xchr, &ychr, &zchr, &action, sump);
<     if (!action && (Verbose_flag > 1))
<       fprintf(Logfile, "Error in value of action in extpozz \n");
---
>         check = Mic[xchr][ychr][zchr];
5178c4641
<     check = Mic[xchr][ychr][zchr];
---
>         /* If neighbor is porosity, locate the SLAG CSH there */
5180,5189c4643,4649
<     /* If neighbor is porosity, locate the SLAG CSH there */
< 
<     if (check == POROSITY || check == CRACKP) {
<       Mic[xchr][ychr][zchr] = SLAGCSH;
<       Count[SLAGCSH]++;
<       if (check == POROSITY)
<         Count[POROSITY]--;
<       if (check == CRACKP)
<         Count[CRACKP]--;
<       fchr = 1;
---
>         if (check == POROSITY || check == CRACKP) {
>             Mic[xchr][ychr][zchr] = SLAGCSH;
>             Count[SLAGCSH]++;
>             if (check == POROSITY) Count[POROSITY]--;
>             if (check == CRACKP) Count[CRACKP]--;
>             fchr = 1;
>         }
5191d4650
<   }
5193,5196c4652,4655
<   /***
<    *    If no neighbor available, locate SLAGCSH
<    *    at random location in pore space
<    ***/
---
>     /***
>     *    If no neighbor available, locate SLAGCSH
>     *    at random location in pore space
>     ***/
5198,5199c4657,4658
<   tries = 0;
<   while (!fchr) {
---
>     tries = 0;
>     while (!fchr) {
5201c4660,4664
<     tries++;
---
>         tries++;
>     
>         /***
>         *    Generate a random location in the 3-D system
>         ***/
5203,5205c4666,4668
<     /***
<      *    Generate a random location in the 3-D system
<      ***/
---
>         xchr = (int)((float)Xsyssize * ran1(Seed));
>         ychr = (int)((float)Ysyssize * ran1(Seed));
>         zchr = (int)((float)Zsyssize * ran1(Seed));
5207,5209c4670,4673
<     xchr = (int)((float)Xsyssize * ran1(Seed));
<     ychr = (int)((float)Ysyssize * ran1(Seed));
<     zchr = (int)((float)Zsyssize * ran1(Seed));
---
>         if (xchr >= Xsyssize) xchr = 0;
>         if (ychr >= Ysyssize) ychr = 0; 
>         if (zchr >= Zsyssize) zchr = 0; 
>         check = Mic[xchr][ychr][zchr];
5211,5217c4675,4678
<     if (xchr >= Xsyssize)
<       xchr = 0;
<     if (ychr >= Ysyssize)
<       ychr = 0;
<     if (zchr >= Zsyssize)
<       zchr = 0;
<     check = Mic[xchr][ychr][zchr];
---
>         /***
>         *    If location is porosity, locate the
>         *    extra SLAGCSH there
>         ***/
5219,5222c4680,4681
<     /***
<      *    If location is porosity, locate the
<      *    extra SLAGCSH there
<      ***/
---
>         if (check == POROSITY) {
>             numnear = edgecnt(xchr,ychr,zchr,SLAG,CSH,SLAGCSH);
5224,5225c4683,4688
<     if (check == POROSITY) {
<       numnear = edgecnt(xchr, ychr, zchr, SLAG, CSH, SLAGCSH);
---
>             /***
>             *    Be sure that one neighboring species is CSH or
>             *    SLAG material (anywhere within a 3x3x3 cube)
>             *    If more than maxxtries tries have already been made
>             *    then locate it at this pore pixel no matter what
>             ***/
5227,5239c4690,4696
<       /***
<        *    Be sure that one neighboring species is CSH or
<        *    SLAG material (anywhere within a 3x3x3 cube)
<        *    If more than maxxtries tries have already been made
<        *    then locate it at this pore pixel no matter what
<        ***/
< 
<       if ((tries > maxxtries) || (numnear < NEIGHBORS)) {
<         Mic[xchr][ychr][zchr] = SLAGCSH;
<         Count[SLAGCSH]++;
<         Count[POROSITY]--;
<         fchr = 1;
<       }
---
>             if ((tries > maxxtries) || (numnear < NEIGHBORS)) {
>                 Mic[xchr][ychr][zchr] = SLAGCSH;
>                 Count[SLAGCSH]++;
>                 Count[POROSITY]--;
>                 fchr = 1;
>             }
>         }
5241d4697
<   }
5245,5285c4701,4741
<  *    dissolve
<  *
<  *     Implement one cycle of dissolution
<  *
<  *     Arguments:    int cycle number
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        passone, loccsch, makeinert
<  *    Called by:    main program
<  ***/
< void dissolve(int cycle) {
<   int gct = 0;
<   int nc3aext, ncshext, nchext, ngypext, nanhext;
<   int nsum5, nsum4, nsum3, nsum2, nhemext, nsum6, nsum7, nsum8, nc4aext,
<       nso4ext, vcement;
<   int nkspix, nnaspix, totks, totnas, skipnodes;
<   int pixdeact, phid, phnew, plnew, cread;
<   int i, k, x, y, xl, yl, zl, curx, cury, curz, xc, yc, plok;
<   int zc, cycnew, sollime, sourcepore;
<   int placed, cshrand, maxsulfate, maxallowed;
<   int ctest, ncshgo, nsurf, suminit;
<   int xext, nhgd, npchext, nslagc3a = 0;
<   float na2omintotmass, k2omintotmass, mwna2so4, mwna2o, mwk2so4, mwk2o;
<   float plfh3, savechgone, sulfavemolarv, mk2so4, mna2so4;
<   float dfact, dfact1, molesdh2o, h2oinit, heat4, fhemext, fc4aext;
<   double factCSH, factPOZZCSH, factTfract;
<   double Pozzcshscale = 20000.0;
<   float pconvert, pc3scsh, pc2scsh, calcx, calcy, calcz, tdisfact;
<   float frafm, frettr, frhyg, frtot, mc3ar, mc4ar, p3init, fact, satsquared;
<   float resfact, molwh2o, volpix, ohadj;
<   double massdiff, mass105, mass1000, fchext, fc3aext, fanhext;
<   double mass_now, tot_mass, mass_fa_now, vol_fa_now, pdis, psfact;
<   double other_solid_volume_per_gcem;
<   double empty_volume_per_gcem;
<   double water_volume_per_gcem;
<   double cement_volume_per_gcem;
<   float refporefrac, xv1, yv1, yv3;
<   struct Ants *antadd;
<   struct Alksulf *curas;
<   FILE *fpout01;
---
> *    dissolve
> *
> *     Implement one cycle of dissolution
> *
> *     Arguments:    int cycle number
> *
> *     Returns:    nothing
> *
> *    Calls:        passone, loccsch, makeinert
> *    Called by:    main program
> ***/
> void dissolve(int cycle)
> {
>     int gct=0;
>     int nc3aext,ncshext,nchext,ngypext,nanhext;
>     int nsum5,nsum4,nsum3,nsum2,nhemext,nsum6,nsum7,nsum8,nc4aext,nso4ext,vcement;
>     int nkspix,nnaspix,totks,totnas,skipnodes;
>     int pixdeact,phid,phnew,plnew,cread;
>     int i,k,x,y,xl,yl,zl,curx,cury,curz,xc,yc,plok;
>     int zc,cycnew,sollime,sourcepore;
>     int placed,cshrand,maxsulfate,maxallowed;
>     int ctest,ncshgo,nsurf,suminit;
>     int xext,nhgd,npchext,nslagc3a=0;
>     float na2omintotmass,k2omintotmass,mwna2so4,mwna2o,mwk2so4,mwk2o;
>     float plfh3,savechgone,sulfavemolarv,mk2so4,mna2so4;
>     float dfact,dfact1,molesdh2o,h2oinit,heat4,fhemext,fc4aext;
>     double factCSH,factPOZZCSH,factTfract;
>     double Pozzcshscale = 20000.0;
>     float pconvert,pc3scsh,pc2scsh,calcx,calcy,calcz,tdisfact;
>     float frafm,frettr,frhyg,frtot,mc3ar,mc4ar,p3init,fact,satsquared;
>     float resfact,molwh2o,volpix,ohadj;
>     double massdiff,mass105,mass1000,fchext,fc3aext,fanhext;
>     double mass_now,tot_mass,mass_fa_now,vol_fa_now,pdis,psfact;
>     double other_solid_volume_per_gcem;
>     double empty_volume_per_gcem;
>     double water_volume_per_gcem;
>     double cement_volume_per_gcem;
>     float refporefrac,xv1,yv1,yv3;
>     struct Ants *antadd;
>     struct Alksulf *curas;
>     FILE *fpout01;
5287c4743
<   resfact = pow((1.0 / Res), 1.25);
---
>     resfact = pow((1.0/Res),1.25);
5289,5293c4745,4749
<   /***
<    *    volpix is the volume of one pixel, in cm^3
<    *
<    *    molwh2o is the molecular mass of water, in g/mole
<    ***/
---
>     /***
>     *    volpix is the volume of one pixel, in cm^3
>     *
>     *    molwh2o is the molecular mass of water, in g/mole
>     ***/
5295,5296c4751,4752
<   volpix = pow(Res * 0.00010, 3.0);
<   molwh2o = 18.0;
---
>     volpix = pow(Res * 0.00010,3.0);
>     molwh2o = 18.0;
5298c4754
<   /* Initialize variables */
---
>     /* Initialize variables */
5300c4756
<   Nmade = 0;
---
>     Nmade = 0;
5302,5305c4758,4761
<   /***
<    *    Counter for number of CSH diffusing species to
<    *    be located at random locations in microstructure
<    ***/
---
>     /***
>     *    Counter for number of CSH diffusing species to
>     *    be located at random locations in microstructure
>     ***/
5307c4763
<   npchext = ncshgo = cshrand = 0;
---
>     npchext = ncshgo = cshrand = 0;
5309c4765
<   /*    New and old values for heat released */
---
>     /*    New and old values for heat released */
5311c4767
<   Heat_old = Heat_new;
---
>     Heat_old = Heat_new;
5313c4769
<   /* Initialize dissolution and phase counters */
---
>     /* Initialize dissolution and phase counters */
5315,5319c4771,4775
<   nsurf = 0;
<   for (i = 0; i < NPHASES; i++) {
<     Discount[i] = 0;
<     Count[i] = 0;
<   }
---
>     nsurf = 0;
>     for (i = 0; i < NPHASES; i++) {
>         Discount[i] = 0;
>         Count[i] = 0;
>     }
5321c4777,4931
<   /* PASS ONE: identify all edge points which are soluble */
---
>     /* PASS ONE: identify all edge points which are soluble */
> 
>     /***
>     *    Molesh2o is the number of MOLES of water consumed by all hydration
>     *        reactions over all cycles. It is set to zero at the
>     *        beginning of each dissolve cycle and
>     *        recalculated by counting the current number of voxels of
>     *        each hydration product and multiplying by number of moles
>     *        of water per voxel of that hydration product, which is
>     *        Waterc[i] / Molarv[i].
>     *
>     *        Note Waterc[i] is the number of moles of water consumed per
>     *        mole of the product created, Molarv[i] is the volume per
>     *        mole of the the product, so Waterc[i] / Molarv[i] is the
>     *        moles of water consumed per unit volume of the product created.
>     ***/
> 
>     Soluble[C3AH6] = 0;
>     Heatsum = Molesh2o = 0.0;
> 
>     /***
>     *    Function passone determines initial number of each phase
>     *    if cycle = 1, otherwise just determines if a pixel is
>     *    eligible for dissolution.  Every eligible pixel will
>     *    have its phaseid value increased by OFFSET after passone
>     *    has finished
>     ***/
> 
>     passone(POROSITY,NPHASES - 1,cycle,1);
>     sollime = 0;
>     
>     for (zl = 0; zl < Zsyssize; zl++) {
>         for (yl = 0; yl < Ysyssize; yl++) {
>             for (xl = 0; xl < Xsyssize; xl++) {
>                 if (Mic[xl][yl][zl] == (FREELIME + OFFSET)) {
>                     sollime++;
>                 }
>             }
>         }
>     }
> 
>     Sulf_solid = Count[GYPSUM];
>     Sulf_solid += Count[GYPSUMS];
>     Sulf_solid += Count[HEMIHYD];
>     Sulf_solid += Count[ANHYDRITE];
>     Sulf_solid += Count[K2SO4];
>     Sulf_solid += Count[NA2SO4];
> 
>     /***
>     *    If first cycle, then determine all mixture
>     *    proportions based on user input and original
>     *    microstructure
>     ***/
> 
>     if (cycle == 1) {
> 
>         /* Mass of cement in system */
> 
>         Cemmass = Specgrav[C3S] * (float)Count[C3S];
>         Cemmass += Specgrav[C2S] * (float)Count[C2S];
>         Cemmass += Specgrav[C3A] * (float)Count[C3A];
>         Cemmass += Specgrav[OC3A] * (float)Count[OC3A];
>         Cemmass += Specgrav[C4AF] * (float)Count[C4AF];
>         /* Cemmass += Specgrav[K2SO4] * (float)Count[K2SO4]; */
>         /* Cemmass += Specgrav[NA2SO4] * (float)Count[NA2SO4]; */
> 
>         Cemmasswgyp = Cemmass
>                 + (Specgrav[GYPSUM] * (float)Count[GYPSUM])
>                 + (Specgrav[ANHYDRITE] * (float)Count[ANHYDRITE])
>                 + (Specgrav[HEMIHYD] * (float)Count[HEMIHYD]);
> 
>         Totfract = (float)(Count[C3S] + Count[C2S] + Count[C3A] + Count[OC3A]);
>         Totfract += (float)(Count[C4AF] + Count[GYPSUM] + Count[HEMIHYD] + Count[ANHYDRITE]);
> 
>         Totfract /= (float)(Syspix);
> 
>         /***
>         *    Check that Totsodium and Totpotassium are
>         *    not less than necessary to be consistent
>         *    with the counts of NA2SO4 and K2SO4
>         ***/
> 
>         mna2so4 = Specgrav[NA2SO4] * (float)Count[NA2SO4];
>         mk2so4 = Specgrav[K2SO4] * (float)Count[K2SO4];
> 
> 
>         /* Molecular weights of the alkali compounds involved */
>         mwna2so4 = 142.04;
>         mwna2o = 61.98;
>         mwk2so4 = 174.26;
>         mwk2o = 94.2;
> 
>         /* Minimum total mass of sodium oxide per gram of cement */
>         na2omintotmass = (mna2so4 * (mwna2o/mwna2so4)) / Cemmasswgyp;
> 
>         /* Minimum total mass of potassium oxide per gram of cement */
>         k2omintotmass = (mk2so4 * (mwk2o/mwk2so4)) / Cemmasswgyp;
>     
>         if (Totsodium < na2omintotmass) {
>             /*
>             printf("\nWARNING:  Prescribed total mass of Na2O ");
>             printf("\n\tin alkali characteristics file is less ");
>             printf("\n\tthan is consistent with the mass of ");
>             printf("\n\tNA2SO4 in the microstructure.");
>             printf("\n\n\tResetting Totsodium variable to be ")'
>             printf("\n\tconsistent... Totsodium is now \n");
>             Totsodium = na2omintotmass;
>             printf("%f \n",Totsodium);
>             */
>         }
> 
>         if (Totpotassium < k2omintotmass) {
>             /*
>             printf("\nWARNING:  Prescribed total mass of K2O ");
>             printf("\n\tin alkali characteristics file is less ");
>             printf("\n\tthan is consistent with the mass of ");
>             printf("\n\tK2SO4 in the microstructure.");
>             printf("\n\n\tResetting Totpotassium variable to be ")'
>             printf("\n\tconsistent... Totpotassium is now \n");
>             Totpotassium = k2omintotmass;
>             printf("%f \n",Totpotassium);
>             */
>         }
> 
>         /***
>         *    All NA2SO4 and K2SO4 are considered readily soluble, so
>         *    we check that Rssodium and Rspotassium are consistent
>         *    with the counts of these alkali salts
>         ***/
> 
>         if (Rssodium < na2omintotmass) {
>             /*
>             printf("\nWARNING:  Prescribed mass of readily soluble Na2O ");
>             printf("\n\tin alkali characteristics file is less ");
>             printf("\n\tthan is consistent with the mass of ");
>             printf("\n\tNA2SO4 in the microstructure.");
>             printf("\n\n\tResetting Rssodium variable to be ")'
>             printf("\n\tconsistent... Rssodium is now \n");
>             Rssodium = na2omintotmass;
>             printf("%f \n",Rssodium);
>             */
>         }
> 
>         if (Rspotassium < k2omintotmass) {
>             /*
>             printf("\nWARNING:  Prescribed mass of readily soluble K2O ");
>             printf("\n\tin alkali characteristics file is less ");
>             printf("\n\tthan is consistent with the mass of ");
>             printf("\n\tK2SO4 in the microstructure.");
>             printf("\n\n\tResetting Rspotassium variable to be ")'
>             printf("\n\tconsistent... Rspotassium is now \n");
>             Rspotassium = k2omintotmass;
>             printf("%f \n",Rspotassium);
>             */
>         }
5323,5336c4933,4940
<   /***
<    *    Molesh2o is the number of MOLES of water consumed by all hydration
<    *        reactions over all cycles. It is set to zero at the
<    *        beginning of each dissolve cycle and
<    *        recalculated by counting the current number of voxels of
<    *        each hydration product and multiplying by number of moles
<    *        of water per voxel of that hydration product, which is
<    *        Waterc[i] / Molarv[i].
<    *
<    *        Note Waterc[i] is the number of moles of water consumed per
<    *        mole of the product created, Molarv[i] is the volume per
<    *        mole of the the product, so Waterc[i] / Molarv[i] is the
<    *        moles of water consumed per unit volume of the product created.
<    ***/
---
>         Flyashmass = Specgrav[SFUME] * (float)Count[SFUME];
>         Flyashmass += Specgrav[AMSIL] * (float)Count[AMSIL];
>         Flyashmass += Specgrav[ASG] * (float)Count[ASG];
>         Flyashmass += Specgrav[CAS2] * (float)Count[CAS2];
>         Flyashvol = (float)Count[SFUME];
>         Flyashvol += (float)Count[AMSIL];
>         Flyashvol += (float)Count[ASG];
>         Flyashvol += (float)Count[CAS2];
5338,5339c4942,4944
<   Soluble[C3AH6] = 0;
<   Heatsum = Molesh2o = 0.0;
---
>         vcement = Count[C3S] + Count[C2S] + Count[C3A] + Count[OC3A]
>                     + Count[C4AF] + Count[GYPSUM] + Count[HEMIHYD]
>                     + Count[ANHYDRITE];
5341,5347c4946,4947
<   /***
<    *    Function passone determines initial number of each phase
<    *    if cycle = 1, otherwise just determines if a pixel is
<    *    eligible for dissolution.  Every eligible pixel will
<    *    have its phaseid value increased by OFFSET after passone
<    *    has finished
<    ***/
---
>         Meancemdens = Cemmasswgyp / ((float) vcement);
>         cement_volume_per_gcem = 1.0 / Meancemdens;
5349,5350c4949
<   passone(POROSITY, NPHASES - 1, cycle, 1);
<   sollime = 0;
---
>         CH_mass = Specgrav[CH] * (float)Count[CH];
5352,5360c4951
<   for (zl = 0; zl < Zsyssize; zl++) {
<     for (yl = 0; yl < Ysyssize; yl++) {
<       for (xl = 0; xl < Xsyssize; xl++) {
<         if (Mic[xl][yl][zl] == (FREELIME + OFFSET)) {
<           sollime++;
<         }
<       }
<     }
<   }
---
>         /* Total mass in system neglecting single aggregate */
5362,5367c4953,4968
<   Sulf_solid = Count[GYPSUM];
<   Sulf_solid += Count[GYPSUMS];
<   Sulf_solid += Count[HEMIHYD];
<   Sulf_solid += Count[ANHYDRITE];
<   Sulf_solid += Count[K2SO4];
<   Sulf_solid += Count[NA2SO4];
---
>         tot_mass = Cemmass + CH_mass
>                 + (float)Count[POROSITY]
>                 + (Specgrav[INERT] * (float)Count[INERT])
>                 + (Specgrav[CACL2] * (float)Count[CACL2])
>                 + (Specgrav[ASG] * (float)Count[ASG])
>                 + (Specgrav[SLAG] * (float)Count[SLAG])
>                 + (Specgrav[HEMIHYD] * (float)Count[HEMIHYD])
>                 + (Specgrav[ANHYDRITE] * (float)Count[ANHYDRITE])
>                 + (Specgrav[CAS2] * (float)Count[CAS2])
>                 + (Specgrav[CSH] * (float)Count[CSH])
>                 + (Specgrav[GYPSUM] * (float)Count[GYPSUM])
>                 + (Specgrav[GYPSUMS] * (float)Count[GYPSUMS])
>                 + (Specgrav[SFUME] * (float)Count[SFUME])
>                 + (Specgrav[AMSIL] * (float)Count[AMSIL])
>                 + (Specgrav[FREELIME] * (float)Count[FREELIME])
>                 + (Specgrav[CACO3] * (float)Count[CACO3]);
5369,5373c4970,4973
<   /***
<    *    If first cycle, then determine all mixture
<    *    proportions based on user input and original
<    *    microstructure
<    ***/
---
>         /***
>         *    Calculation of total solid mass, in g,
>         *    at 105C and 1000C
>         ***/
5375c4975
<   if (cycle == 1) {
---
>         Mass_105 = Mass_1000 = massdiff = 0.0;
5377c4977
<     /* Mass of cement in system */
---
>         for (i = POROSITY; i <= NSPHASES; i++) {
5379,5385c4979,4982
<     Cemmass = Specgrav[C3S] * (float)Count[C3S];
<     Cemmass += Specgrav[C2S] * (float)Count[C2S];
<     Cemmass += Specgrav[C3A] * (float)Count[C3A];
<     Cemmass += Specgrav[OC3A] * (float)Count[OC3A];
<     Cemmass += Specgrav[C4AF] * (float)Count[C4AF];
<     /* Cemmass += Specgrav[K2SO4] * (float)Count[K2SO4]; */
<     /* Cemmass += Specgrav[NA2SO4] * (float)Count[NA2SO4]; */
---
>             /***
>             *     Explicit decision NOT to include water in a saturated crack
>             *     pore in the nonevaporable water calculations.
>             ***/
5387,5389c4984,4986
<     Cemmasswgyp = Cemmass + (Specgrav[GYPSUM] * (float)Count[GYPSUM]) +
<                   (Specgrav[ANHYDRITE] * (float)Count[ANHYDRITE]) +
<                   (Specgrav[HEMIHYD] * (float)Count[HEMIHYD]);
---
>             Mass_105 += ((double)Count[i] * (Specgrav[i] -
>                         ( molwh2o * (Nh2o[i][0] - Nh2o[i][1])
>                         / Molarv[i] )));
5391,5393c4988,4989
<     Totfract = (float)(Count[C3S] + Count[C2S] + Count[C3A] + Count[OC3A]);
<     Totfract += (float)(Count[C4AF] + Count[GYPSUM] + Count[HEMIHYD] +
<                         Count[ANHYDRITE]);
---
>             massdiff += ((double)(Count[i]) * Nh2o[i][1] / Molarv[i]);
>         }    
5395c4991,4992
<     Totfract /= (float)(Syspix);
---
>         Mass_105 *= ((double)volpix);
>         massdiff *= ((double)(volpix * molwh2o));
5397,5401c4994
<     /***
<      *    Check that Totsodium and Totpotassium are
<      *    not less than necessary to be consistent
<      *    with the counts of NA2SO4 and K2SO4
<      ***/
---
>         Mass_1000 = Mass_105 - massdiff;
5403,5404c4996,4999
<     mna2so4 = Specgrav[NA2SO4] * (float)Count[NA2SO4];
<     mk2so4 = Specgrav[K2SO4] * (float)Count[K2SO4];
---
>         /***
>         *    Water-to-cement ratio.  Decision to NOT include cracked pore water
>         *    in the accounting for w/c.  Could amend this later if desired
>         ***/
5406,5410c5001,5005
<     /* Molecular weights of the alkali compounds involved */
<     mwna2so4 = 142.04;
<     mwna2o = 61.98;
<     mwk2so4 = 174.26;
<     mwk2o = 94.2;
---
>         if (Cemmass != 0.0) {
>             W_to_c = (float)(((double)Count[POROSITY]) / Cemmasswgyp);
>         } else {
>             W_to_c = 0.0;
>         }
5412,5413c5007,5011
<     /* Minimum total mass of sodium oxide per gram of cement */
<     na2omintotmass = (mna2so4 * (mwna2o / mwna2so4)) / Cemmasswgyp;
---
>         if ((tot_mass - (float)(Count[POROSITY])) != 0.0) {
>             W_to_s = (float)(((double)Count[POROSITY]) / (tot_mass - (float)(Count[POROSITY])));
>         } else {
>             W_to_s = 0.0;
>         }
5415,5416c5013
<     /* Minimum total mass of potassium oxide per gram of cement */
<     k2omintotmass = (mk2so4 * (mwk2o / mwk2so4)) / Cemmasswgyp;
---
>         /* Adjust masses for presence of aggregates in concrete */
5418,5433c5015,5016
<     if (Totsodium < na2omintotmass) {
<       /*
<       if (Verbose_flag > 0) {
<       fprintf(Logfile,"\nWARNING:  Prescribed total mass of Na2O ");
<       fprintf(Logfile,"\n\tin alkali characteristics file is less ");
<       fprintf(Logfile,"\n\tthan is consistent with the mass of ");
<       fprintf(Logfile,"\n\tNA2SO4 in the microstructure.");
<       fprintf(Logfile,"\n\n\tResetting Totsodium variable to be ")'
<       fprintf(Logfile,"\n\tconsistent... Totsodium is now \n");
<       }
<       Totsodium = na2omintotmass;
<       if (Verbose_flag > 0) {
<       fprintf(Logfile,"%f \n",Totsodium);
<       }
<       */
<     }
---
>         Mass_water = ((1.0 - Mass_agg) * (float)Count[POROSITY]) / tot_mass;
>         Mass_CH = ((1.0 - Mass_agg) * CH_mass) / tot_mass;
5435,5450c5018,5029
<     if (Totpotassium < k2omintotmass) {
<       /*
<       if (Verbose_flag > 0) {
<       fprintf(Logfile,"\nWARNING:  Prescribed total mass of K2O ");
<       fprintf(Logfile,"\n\tin alkali characteristics file is less ");
<       fprintf(Logfile,"\n\tthan is consistent with the mass of ");
<       fprintf(Logfile,"\n\tK2SO4 in the microstructure.");
<       fprintf(Logfile,"\n\n\tResetting Totpotassium variable to be ")'
<       fprintf(Logfile,"\n\tconsistent... Totpotassium is now \n");
<       }
<       Totpotassium = k2omintotmass;
<       if (Verbose_flag > 0) {
<       fprintf(Logfile,"%f \n",Totpotassium);
<       }
<       */
<     }
---
>         /* Pozzolan-to-cement ratio */
>         if (Cemmass != 0.0) {
>             S_to_c = (float)( ((double)Count[INERT] * Specgrav[INERT]
>                     + (double)Count[CACL2] * Specgrav[CACL2]
>                     + (double)Count[ASG] * Specgrav[ASG]
>                     + (double)Count[CAS2] * Specgrav[CAS2]
>                     + (double)Count[SLAG] * Specgrav[SLAG]
>                     + (double)Count[AMSIL] * Specgrav[AMSIL]
>                     + (double)Count[SFUME] * Specgrav[SFUME] ) / Cemmass);
>         } else {
>             S_to_c = 0.0;
>         }
5452,5456c5031
<     /***
<      *    All NA2SO4 and K2SO4 are considered readily soluble, so
<      *    we check that Rssodium and Rspotassium are consistent
<      *    with the counts of these alkali salts
<      ***/
---
>         /* Convert to kJ/kg for heat produced */
5458,5473c5033,5047
<     if (Rssodium < na2omintotmass) {
<       /*
<       if (Verbose_flag > 0) {
<       fprintf(Logfile,"\nWARNING:  Prescribed mass of readily soluble Na2O ");
<       fprintf(Logfile,"\n\tin alkali characteristics file is less ");
<       fprintf(Logfile,"\n\tthan is consistent with the mass of ");
<       fprintf(Logfile,"\n\tNA2SO4 in the microstructure.");
<       fprintf(Logfile,"\n\n\tResetting Rssodium variable to be ")'
<       fprintf(Logfile,"\n\tconsistent... Rssodium is now \n");
<       }
<       Rssodium = na2omintotmass;
<       if (Verbose_flag > 0) {
<       fprintf(Logfile,"%f \n",Rssodium);
<       }
<       */
<     }
---
>         water_volume_per_gcem = W_to_c;
>         if (Cemmass != 0.0) {
>             empty_volume_per_gcem = (double)((Count[EMPTYP]
>                                              + Count[CRACKP]) / Cemmass);
>             other_solid_volume_per_gcem = (double)(
>                             (double)(
>                                 Count[INERT] + Count[INERTAGG]
>                                 + Count[SLAG] + Count[AMSIL]
>                                 + Count[SFUME] + Count[CACL2]
>                                 + Count[ASG] + Count[CAS2]
>                              ) / Cemmass );
>         } else {
>             empty_volume_per_gcem = 0.0;
>             other_solid_volume_per_gcem = 0.0;
>         }
5475,5490c5049
<     if (Rspotassium < k2omintotmass) {
<       /*
<       if (Verbose_flag > 0) {
<       fprintf(Logfile,"\nWARNING:  Prescribed mass of readily soluble K2O ");
<       fprintf(Logfile,"\n\tin alkali characteristics file is less ");
<       fprintf(Logfile,"\n\tthan is consistent with the mass of ");
<       fprintf(Logfile,"\n\tK2SO4 in the microstructure.");
<       fprintf(Logfile,"\n\n\tResetting Rspotassium variable to be ")'
<       fprintf(Logfile,"\n\tconsistent... Rspotassium is now \n");
<       }
<       Rspotassium = k2omintotmass;
<       if (Verbose_flag > 0) {
<       fprintf(Logfile,"%f \n",Rspotassium);
<       }
<       */
<     }
---
>         if (W_to_c > 0.01) {
5492,5499c5051,5077
<     Flyashmass = Specgrav[SFUME] * (float)Count[SFUME];
<     Flyashmass += Specgrav[AMSIL] * (float)Count[AMSIL];
<     Flyashmass += Specgrav[ASG] * (float)Count[ASG];
<     Flyashmass += Specgrav[CAS2] * (float)Count[CAS2];
<     Flyashvol = (float)Count[SFUME];
<     Flyashvol += (float)Count[AMSIL];
<     Flyashvol += (float)Count[ASG];
<     Flyashvol += (float)Count[CAS2];
---
>         /***
>         *    Heat conversion factor converts the model heat
>         *    units to kJ per kg of CEMENT (not including other solids).
>         *
>         *    Model units of heat are (kJ/system volume)
>         *
>         *       J                kJ       cm3 sys
>         *    ------- = 1000 * -------     -------
>         *     g cem             cm3 sys    g cem
>         *
>         *
>         * where 
>         *
>         *      cm^3 sys    cm^3 cem     cm3 H2O   cm3 other solid
>         *     ---------- = --------- + -------- + ----------------
>         *      g cem       g cem        g cem       g cem
>         *
>         *                + cm3 Empty
>         *                  ---------
>         *                   g cem
>         *
>         *                = (cement_volume_per_gcem
>         *                   + water_volume_per_gcem
>         *                   + other_solid_volume_per_gcem
>         *                   + empty_volume_per_gcem)
>         *
>         ***/
5501,5502c5079,5086
<     vcement = Count[C3S] + Count[C2S] + Count[C3A] + Count[OC3A] + Count[C4AF] +
<               Count[GYPSUM] + Count[HEMIHYD] + Count[ANHYDRITE];
---
>             Heat_cf = (double)((1000.0/((double)Syspix))
>                         * ( cement_volume_per_gcem
>                             + water_volume_per_gcem
>                             + other_solid_volume_per_gcem
>                             + empty_volume_per_gcem
>                           ));
>                         
>         } else {
5504,5505c5088,5092
<     Meancemdens = Cemmasswgyp / ((float)vcement);
<     cement_volume_per_gcem = 1.0 / Meancemdens;
---
>             /***
>             *    With w/c < 0.01, we use volume per 1 gram
>             *    of SILICA FUME. Otherwise, the conversion
>             *    is the same as in the previous comment
>             ***/
5507c5094,5100
<     CH_mass = Specgrav[CH] * (float)Count[CH];
---
>             Heat_cf = (double)((1000.0/((double)Syspix))
>                           * ( (1.0 / Specgrav[SFUME])
>                             + (double)( Count[POROSITY]
>                                         + Count[CH]
>                                         + Count[INERT] )
>                           / (Specgrav[SFUME] * (double)Count[SFUME]) ));
>         }
5509c5102,5104
<     /* Total mass in system neglecting single aggregate */
---
>         Mass_fill_pozz = (1.0 - Mass_agg)
>                             * ((double)Count[SFUME] * Specgrav[SFUME])
>                             / tot_mass;
5511,5525c5106,5115
<     tot_mass = Cemmass + CH_mass + (float)Count[POROSITY] +
<                (Specgrav[INERT] * (float)Count[INERT]) +
<                (Specgrav[CACL2] * (float)Count[CACL2]) +
<                (Specgrav[ASG] * (float)Count[ASG]) +
<                (Specgrav[SLAG] * (float)Count[SLAG]) +
<                (Specgrav[HEMIHYD] * (float)Count[HEMIHYD]) +
<                (Specgrav[ANHYDRITE] * (float)Count[ANHYDRITE]) +
<                (Specgrav[CAS2] * (float)Count[CAS2]) +
<                (Specgrav[CSH] * (float)Count[CSH]) +
<                (Specgrav[GYPSUM] * (float)Count[GYPSUM]) +
<                (Specgrav[GYPSUMS] * (float)Count[GYPSUMS]) +
<                (Specgrav[SFUME] * (float)Count[SFUME]) +
<                (Specgrav[AMSIL] * (float)Count[AMSIL]) +
<                (Specgrav[FREELIME] * (float)Count[FREELIME]) +
<                (Specgrav[CACO3] * (float)Count[CACO3]);
---
>         Mass_fill = (1.0 - Mass_agg)
>                     * (    (double)Count[INERT]*Specgrav[INERT]
>                         + (double)Count[ASG]*Specgrav[ASG]
>                         + (double)Count[SLAG]*Specgrav[SLAG]
>                         + (double)Count[CAS2]*Specgrav[CAS2]
>                         + (double)Count[CACO3]*Specgrav[CACO3]
>                         + (double)Count[SFUME]*Specgrav[SFUME]
>                         + (double)Count[AMSIL]*Specgrav[AMSIL]
>                         + (double)Count[CACL2]*Specgrav[CACL2] )
>                     / tot_mass;
5527,5530c5117,5124
<     /***
<      *    Calculation of total solid mass, in g,
<      *    at 105C and 1000C
<      ***/
---
>         if (Verbose) {
>             printf("Calculated w/c is %.4f\n",W_to_c);
>             printf("Calculated s/c is %.4f \n",S_to_c);
>             printf("Calculated heat conversion factor is %f \n",Heat_cf);
>             printf("Calculated mass fractions of water and filler ");
>             printf("are %.4f  and %.4f \n",Mass_water,Mass_fill);
>         }
>     }
5532c5126,5127
<     Mass_105 = Mass_1000 = massdiff = 0.0;
---
>     cement_volume_per_gcem = 1.0 / Meancemdens;
>     molesdh2o = 0.0;
5534c5129
<     for (i = POROSITY; i <= NSPHASES; i++) {
---
>     /* Alpha is the degree of hydration */
5536,5539c5131
<       /***
<        *     Explicit decision NOT to include water in a saturated crack
<        *     pore in the nonevaporable water calculations.
<        ***/
---
>     Alpha = 0.0;
5541,5543c5133,5137
<       Mass_105 +=
<           ((double)Count[i] *
<            (Specgrav[i] - (molwh2o * (Nh2o[i][0] - Nh2o[i][1]) / Molarv[i])));
---
>     /***
>     *    heat4 contains measured heat release for
>     *    C4AF hydration, based on
>     *    Fukuhara et al., Cem. and Conc. Res. article
>     ***/
5545,5546c5139
<       massdiff += ((double)(Count[i]) * Nh2o[i][1] / Molarv[i]);
<     }
---
>     heat4 = 0.0;
5548,5549c5141,5142
<     Mass_105 *= ((double)volpix);
<     massdiff *= ((double)(volpix * molwh2o));
---
>     /* Total cement mass corrected for hydration */
>     mass_now = mass_fa_now = 0.0;
5551c5144,5146
<     Mass_1000 = Mass_105 - massdiff;
---
>     /* Initial combined counts of cement phases */
>     suminit = C3sinit + C2sinit + C3ainit + C4afinit;
>     suminit += (Ksulfinit + Nasulfinit);
5554,5556c5149,5153
<      *    Water-to-cement ratio.  Decision to NOT include cracked pore water
<      *    in the accounting for w/c.  Could amend this later if desired
<      ***/
---
>     *    ctest is number of diffusing gypsum pixels that
>     *    are likely to form ettringite.
>     *
>     *    1 unit of C3A can react with 2.5 units of Gypsum
>     ***/
5558,5562c5155,5156
<     if (Cemmass != 0.0) {
<       W_to_c = (float)(((double)Count[POROSITY]) / Cemmasswgyp);
<     } else {
<       W_to_c = 0.0;
<     }
---
>     ctest = Count[DIFFGYP];
>     fflush(stdout);
5564,5568c5158,5159
<     if ((tot_mass - (float)(Count[POROSITY])) != 0.0) {
<       W_to_s = (float)(((double)Count[POROSITY]) /
<                        (tot_mass - (float)(Count[POROSITY])));
<     } else {
<       W_to_s = 0.0;
---
>     if ((float)ctest > (2.5 * (double)(Count[DIFFC3A] + Count[DIFFC4A]))) {
>         ctest = 2.5 * (double)(Count[DIFFC3A] + Count[DIFFC4A]);
5571c5162
<     /* Adjust masses for presence of aggregates in concrete */
---
>     mass105 = mass1000 = massdiff = 0.0;
5573,5574c5164
<     Mass_water = ((1.0 - Mass_agg) * (float)Count[POROSITY]) / tot_mass;
<     Mass_CH = ((1.0 - Mass_agg) * CH_mass) / tot_mass;
---
>     for (i = 0; i < NPHASES; i++) {
5576,5588c5166,5169
<     /* Pozzolan-to-cement ratio */
<     if (Cemmass != 0.0) {
<       S_to_c = (float)(((double)Count[INERT] * Specgrav[INERT] +
<                         (double)Count[CACL2] * Specgrav[CACL2] +
<                         (double)Count[ASG] * Specgrav[ASG] +
<                         (double)Count[CAS2] * Specgrav[CAS2] +
<                         (double)Count[SLAG] * Specgrav[SLAG] +
<                         (double)Count[AMSIL] * Specgrav[AMSIL] +
<                         (double)Count[SFUME] * Specgrav[SFUME]) /
<                        Cemmass);
<     } else {
<       S_to_c = 0.0;
<     }
---
>         /***
>         *    Calculate contribution to non-evaporable water of
>         *    the solid phases
>         ***/
5590c5171
<     /* Convert to kJ/kg for heat produced */
---
>         if ((i <= NSPHASES && (i != CSH)) || i == CRACKP) {
5592,5604c5173,5175
<     water_volume_per_gcem = W_to_c;
<     if (Cemmass != 0.0) {
<       empty_volume_per_gcem =
<           (double)((Count[EMPTYP] + Count[CRACKP]) / Cemmass);
<       other_solid_volume_per_gcem =
<           (double)((double)(Count[INERT] + Count[INERTAGG] + Count[SLAG] +
<                             Count[AMSIL] + Count[SFUME] + Count[CACL2] +
<                             Count[ASG] + Count[CAS2]) /
<                    Cemmass);
<     } else {
<       empty_volume_per_gcem = 0.0;
<       other_solid_volume_per_gcem = 0.0;
<     }
---
>             mass105 += ((double)Count[i] * (Specgrav[i] -
>                         ( molwh2o * (Nh2o[i][0] - Nh2o[i][1])
>                             / Molarv[i] )));
5606c5177
<     if (W_to_c > 0.01) {
---
>             massdiff += ((double)(Count[i]) * Nh2o[i][1] / Molarv[i]);
5608,5634c5179
<       /***
<        *    Heat conversion factor converts the model heat
<        *    units to kJ per kg of CEMENT (not including other solids).
<        *
<        *    Model units of heat are (kJ/system volume)
<        *
<        *       J                kJ       cm3 sys
<        *    ------- = 1000 * -------     -------
<        *     g cem             cm3 sys    g cem
<        *
<        *
<        * where
<        *
<        *      cm^3 sys    cm^3 cem     cm3 H2O   cm3 other solid
<        *     ---------- = --------- + -------- + ----------------
<        *      g cem       g cem        g cem       g cem
<        *
<        *                + cm3 Empty
<        *                  ---------
<        *                   g cem
<        *
<        *                = (cement_volume_per_gcem
<        *                   + water_volume_per_gcem
<        *                   + other_solid_volume_per_gcem
<        *                   + empty_volume_per_gcem)
<        *
<        ***/
---
>         } else if (i == CSH) {
5636,5638c5181,5185
<       Heat_cf = (double)((1000.0 / ((double)Syspix)) *
<                          (cement_volume_per_gcem + water_volume_per_gcem +
<                           other_solid_volume_per_gcem + empty_volume_per_gcem));
---
>             /***
>             *    Assume that CSH loses 40% of its water at 105
>             *    (see H.F.W. Taylor, Mater. Res. Soc. Proc.,
>             *    Vol. 85, p. 47 (1987))
>             ***/
5640c5187,5189
<     } else {
---
>             mass105 += ((double)Count[i] * (Specgrav[CSH] -
>                         ( molwh2o * 0.4 * Watercsh[cycle]
>                             / Molarvcsh[cycle] )));
5642,5646c5191,5193
<       /***
<        *    With w/c < 0.01, we use volume per 1 gram
<        *    of SILICA FUME. Otherwise, the conversion
<        *    is the same as in the previous comment
<        ***/
---
>             massdiff += ((double)(Count[i]) * (1.0 - 0.4) * Watercsh[cycle]
>                             / Molarvcsh[cycle]);
>         }
5648,5652c5195,5200
<       Heat_cf = (double)((1000.0 / ((double)Syspix)) *
<                          ((1.0 / Specgrav[SFUME]) +
<                           (double)(Count[POROSITY] + Count[CH] + Count[INERT]) /
<                               (Specgrav[SFUME] * (double)Count[SFUME])));
<     }
---
>         if ((i != POROSITY) && (i != CRACKP)
>             && (i <= NSPHASES)
>             && (i != INERTAGG)
>             && (i != CSH)
>             && (i != FAC3A)
>             && (i != FLYASH)) {
5654,5655c5202
<     Mass_fill_pozz =
<         (1.0 - Mass_agg) * ((double)Count[SFUME] * Specgrav[SFUME]) / tot_mass;
---
>             Heatsum += ((double)Count[i] * Heatf[i] / Molarv[i]);
5657,5666c5204,5207
<     Mass_fill = (1.0 - Mass_agg) *
<                 ((double)Count[INERT] * Specgrav[INERT] +
<                  (double)Count[ASG] * Specgrav[ASG] +
<                  (double)Count[SLAG] * Specgrav[SLAG] +
<                  (double)Count[CAS2] * Specgrav[CAS2] +
<                  (double)Count[CACO3] * Specgrav[CACO3] +
<                  (double)Count[SFUME] * Specgrav[SFUME] +
<                  (double)Count[AMSIL] * Specgrav[AMSIL] +
<                  (double)Count[CACL2] * Specgrav[CACL2]) /
<                 tot_mass;
---
>             /***
>             *    Tabulate moles of H2O consumed by
>             *    reactions so far
>             ***/
5668,5675c5209,5214
<     if (Verbose_flag > 2) {
<       fprintf(Logfile, "Calculated w/c is %.4f\n", W_to_c);
<       fprintf(Logfile, "Calculated s/c is %.4f \n", S_to_c);
<       fprintf(Logfile, "Calculated heat conversion factor is %f \n", Heat_cf);
<       fprintf(Logfile, "Calculated mass fractions of water and filler ");
<       fprintf(Logfile, "are %.4f  and %.4f \n", Mass_water, Mass_fill);
<     }
<   }
---
>             /***
>              *   Molesh2o is the MOLES of water consumed by
>              *   hydration reactions
>              ***/
>             Molesh2o += ((double)Count[i] * Waterc[i] / Molarv[i]);
>         }
5677,5678c5216
<   cement_volume_per_gcem = 1.0 / Meancemdens;
<   molesdh2o = 0.0;
---
>         /* ASSUME that all C3A which can, does form ettringite */
5680c5218
<   /* Alpha is the degree of hydration */
---
>         if (i == DIFFC3A) {
5682c5220,5222
<   Alpha = 0.0;
---
>             Heatsum += (((double)Count[DIFFC3A] - ((float)ctest / 2.5))
>                         * Heatf[C3A] / Molarv[C3A]);
>         }
5684,5688c5224
<   /***
<    *    heat4 contains measured heat release for
<    *    C4AF hydration, based on
<    *    Fukuhara et al., Cem. and Conc. Res. article
<    ***/
---
>         /* ASSUME that all C4AF which can, does form ettringite */
5690c5226,5229
<   heat4 = 0.0;
---
>         if (i == DIFFC4A) {
>             Heatsum += (((double)Count[DIFFC4A] - ((float)ctest/2.5))
>                         * Heatf[C4AF] / Molarv[C4AF]);
>         }
5692,5693c5231,5234
<   /* Total cement mass corrected for hydration */
<   mass_now = mass_fa_now = 0.0;
---
>         /***
>         *    ASSUME all gypsum which can, does form ettringite.
>         *    The remainder will remain as gypsum
>         ***/
5695,5697c5236
<   /* Initial combined counts of cement phases */
<   suminit = C3sinit + C2sinit + C3ainit + C4afinit;
<   suminit += (Ksulfinit + Nasulfinit);
---
>         if (i == DIFFGYP) {
5699,5704c5238,5239
<   /***
<    *    ctest is number of diffusing gypsum pixels that
<    *    are likely to form ettringite.
<    *
<    *    1 unit of C3A can react with 2.5 units of Gypsum
<    ***/
---
>             Heatsum += ((double)(Count[DIFFGYP] - ctest)
>                         * Heatf[GYPSUM] / Molarv[GYPSUM]);
5706,5707c5241,5243
<   ctest = Count[DIFFGYP];
<   fflush(Logfile);
---
>             /***
>             *    3.3 is the molar expansion from GYPSUM to ETTR
>             ***/
5709,5711c5245,5246
<   if ((float)ctest > (2.5 * (double)(Count[DIFFC3A] + Count[DIFFC4A]))) {
<     ctest = 2.5 * (double)(Count[DIFFC3A] + Count[DIFFC4A]);
<   }
---
>             Heatsum += ((float)ctest * 3.30 * Heatf[ETTR] / Molarv[ETTR]);
>             molesdh2o += ((float)ctest * 3.30 * Waterc[ETTR] / Molarv[ETTR]);
5713c5248
<   mass105 = mass1000 = massdiff = 0.0;
---
>         } else if (i == DIFFCH) {
5715c5250,5251
<   for (i = 0; i < NPHASES; i++) {
---
>             Heatsum += ((double)Count[DIFFCH] * Heatf[CH] / Molarv[CH]);
>             molesdh2o += ((double)Count[DIFFCH] * Waterc[CH] / Molarv[CH]);
5717,5720c5253
<     /***
<      *    Calculate contribution to non-evaporable water of
<      *    the solid phases
<      ***/
---
>         } else if (i == DIFFFH3) {
5722c5255,5256
<     if ((i <= NSPHASES && (i != CSH)) || i == CRACKP) {
---
>             Heatsum += ((double)Count[DIFFFH3] * Heatf[FH3] / Molarv[FH3]);
>             molesdh2o += ((double)Count[DIFFFH3] * Waterc[FH3] / Molarv[FH3]);
5724,5726c5258
<       mass105 +=
<           ((double)Count[i] *
<            (Specgrav[i] - (molwh2o * (Nh2o[i][0] - Nh2o[i][1]) / Molarv[i])));
---
>         } else if (i == DIFFCSH) {
5728c5260,5263
<       massdiff += ((double)(Count[i]) * Nh2o[i][1] / Molarv[i]);
---
>             /***
>             *    Use current CSH properties,
>             *    i.e. Molarvcsh[cycle]  and Watercsh[cycle]
>             ***/
5730c5265,5268
<     } else if (i == CSH) {
---
>             Heatsum += ((double)Count[DIFFCSH]
>                         * Heatf[CSH] / Molarvcsh[cycle]);
>             molesdh2o += ((double)Count[DIFFCSH]
>                         * Watercsh[cycle] / Molarvcsh[cycle]);
5732,5736c5270
<       /***
<        *    Assume that CSH loses 40% of its water at 105
<        *    (see H.F.W. Taylor, Mater. Res. Soc. Proc.,
<        *    Vol. 85, p. 47 (1987))
<        ***/
---
>         } else if (i == DIFFETTR) {
5738,5740c5272,5273
<       mass105 += ((double)Count[i] *
<                   (Specgrav[CSH] -
<                    (molwh2o * 0.4 * Watercsh[cycle] / Molarvcsh[cycle])));
---
>             Heatsum += ((double)Count[DIFFETTR] * Heatf[ETTR] / Molarv[ETTR]);
>             molesdh2o += ((double)Count[DIFFETTR] * Waterc[ETTR] / Molarv[ETTR]);
5742,5744c5275
<       massdiff += ((double)(Count[i]) * (1.0 - 0.4) * Watercsh[cycle] /
<                    Molarvcsh[cycle]);
<     }
---
>         } else if (i == DIFFCACL2) {
5746,5747c5277,5280
<     if ((i != POROSITY) && (i != CRACKP) && (i <= NSPHASES) &&
<         (i != INERTAGG) && (i != CSH) && (i != FAC3A) && (i != FLYASH)) {
---
>             Heatsum += ((double)Count[DIFFCACL2]
>                         * Heatf[CACL2] / Molarv[CACL2]);
>             molesdh2o += ((double)Count[DIFFCACL2]
>                         * Waterc[CACL2] / Molarv[CACL2]);
5749c5282
<       Heatsum += ((double)Count[i] * Heatf[i] / Molarv[i]);
---
>         } else if (i == DIFFAS) {
5751,5754c5284,5285
<       /***
<        *    Tabulate moles of H2O consumed by
<        *    reactions so far
<        ***/
---
>             Heatsum += ((double)Count[DIFFAS] * Heatf[ASG] / Molarv[ASG]);
>             molesdh2o += ((double)Count[DIFFAS] * Waterc[ASG] / Molarv[ASG]);
5756,5761c5287
<       /***
<        *   Molesh2o is the MOLES of water consumed by
<        *   hydration reactions
<        ***/
<       Molesh2o += ((double)Count[i] * Waterc[i] / Molarv[i]);
<     }
---
>         } else if (i == DIFFCAS2) {
5763c5289,5290
<     /* ASSUME that all C3A which can, does form ettringite */
---
>             Heatsum += ((double)Count[DIFFCAS2] * Heatf[CAS2] / Molarv[CAS2]);
>             molesdh2o += ((double)Count[DIFFCAS2] * Waterc[CAS2] / Molarv[CAS2]);
5765c5292
<     if (i == DIFFC3A) {
---
>         } else if (i == DIFFANH) {
5767,5769c5294,5297
<       Heatsum += (((double)Count[DIFFC3A] - ((float)ctest / 2.5)) * Heatf[C3A] /
<                   Molarv[C3A]);
<     }
---
>             /***
>             *    ASSUME that all diffusing anhydrite leads
>             *    to gypsum formation
>             ***/
5771c5299,5300
<     /* ASSUME that all C4AF which can, does form ettringite */
---
>             Heatsum += ((double)Count[DIFFANH]
>                         * Heatf[GYPSUMS] / Molarv[GYPSUMS]);
5773,5776c5302
<     if (i == DIFFC4A) {
<       Heatsum += (((double)Count[DIFFC4A] - ((float)ctest / 2.5)) *
<                   Heatf[C4AF] / Molarv[C4AF]);
<     }
---
>             /* 2 moles of water per mole of gypsum formed */
5778,5781c5304
<     /***
<      *    ASSUME all gypsum which can, does form ettringite.
<      *    The remainder will remain as gypsum
<      ***/
---
>             molesdh2o += ((double)Count[DIFFANH] *2.0 / Molarv[GYPSUMS]);
5783c5306
<     if (i == DIFFGYP) {
---
>         } else if (i == DIFFHEM) {
5785,5786c5308,5311
<       Heatsum +=
<           ((double)(Count[DIFFGYP] - ctest) * Heatf[GYPSUM] / Molarv[GYPSUM]);
---
>             /***
>             *    ASSUME that all diffusing hemihydrate leads
>             *    to gypsum formation
>             ***/
5788,5790c5313,5314
<       /***
<        *    3.3 is the molar expansion from GYPSUM to ETTR
<        ***/
---
>             Heatsum += ((double)Count[DIFFHEM]
>                         * Heatf[GYPSUMS] / Molarv[GYPSUMS]);
5792,5793c5316
<       Heatsum += ((float)ctest * 3.30 * Heatf[ETTR] / Molarv[ETTR]);
<       molesdh2o += ((float)ctest * 3.30 * Waterc[ETTR] / Molarv[ETTR]);
---
>             /* 1.5 moles of water per mole of gypsum formed */
5795c5318
<     } else if (i == DIFFCH) {
---
>             molesdh2o += ((double)Count[DIFFHEM] *1.5 / Molarv[GYPSUMS]);
5797,5798c5320
<       Heatsum += ((double)Count[DIFFCH] * Heatf[CH] / Molarv[CH]);
<       molesdh2o += ((double)Count[DIFFCH] * Waterc[CH] / Molarv[CH]);
---
>         } else if (i == C3S) {
5800c5322,5324
<     } else if (i == DIFFFH3) {
---
>             Alpha += ((double)(C3sinit - Count[C3S]));
>             mass_now += (Specgrav[C3S] * (double)Count[C3S]);
>             heat4 += (0.517 * (double)(C3sinit - Count[C3S]) * Specgrav[C3S]);
5802,5803c5326
<       Heatsum += ((double)Count[DIFFFH3] * Heatf[FH3] / Molarv[FH3]);
<       molesdh2o += ((double)Count[DIFFFH3] * Waterc[FH3] / Molarv[FH3]);
---
>         } else if (i == C2S) {
5805c5328,5330
<     } else if (i == DIFFCSH) {
---
>             Alpha += ((double)(C2sinit - Count[C2S]));
>             mass_now += (Specgrav[C2S] * (double)Count[C2S]);
>             heat4 += (0.262 * (double)(C2sinit - Count[C2S]) * Specgrav[C2S]);
5807,5810c5332
<       /***
<        *    Use current CSH properties,
<        *    i.e. Molarvcsh[cycle]  and Watercsh[cycle]
<        ***/
---
>         } else if (i == C3A) {
5812,5814c5334,5337
<       Heatsum += ((double)Count[DIFFCSH] * Heatf[CSH] / Molarvcsh[cycle]);
<       molesdh2o +=
<           ((double)Count[DIFFCSH] * Watercsh[cycle] / Molarvcsh[cycle]);
---
>             Alpha += ((double)(C3ainit - Count[C3A]));
>             mass_now += (Specgrav[C3A] * (double)Count[C3A]);
>             mc3ar = ((double)(C3ainit - Count[C3A]) / Molarv[C3A]);
>             mc4ar = ((double)(C4afinit - Count[C4AF]) / Molarv[C4AF]);
5816c5339,5344
<     } else if (i == DIFFETTR) {
---
>             if((mc3ar + mc4ar) > 0.0) {
>                 frhyg = (mc3ar / (mc3ar + mc4ar))
>                         * (double)Count[C3AH6] / Molarv[C3AH6];
>             } else {
>                 frhyg = 0.0;
>             }
5818,5819c5346,5348
<       Heatsum += ((double)Count[DIFFETTR] * Heatf[ETTR] / Molarv[ETTR]);
<       molesdh2o += ((double)Count[DIFFETTR] * Waterc[ETTR] / Molarv[ETTR]);
---
>             frettr = (double)Count[ETTR] / Molarv[ETTR];
>             frafm = 3.0 * (double)Count[AFM] / Molarv[AFM];
>             frtot = frafm + frettr + frhyg;
5821c5350,5360
<     } else if (i == DIFFCACL2) {
---
>             if (frtot > 0.0) {
>                 frettr /= frtot;
>                 frafm /= frtot;
>                 frhyg /= frtot;
>                 heat4 += (frafm * 1.144
>                         * (double)(C3ainit - Count[C3A]) * Specgrav[C3A]);
>                 heat4 += (frhyg * 0.908
>                         * (double)(C3ainit - Count[C3A]) * Specgrav[C3A]);
>                 heat4 += (frettr * 1.672
>                         * (double)(C3ainit - Count[C3A]) * Specgrav[C3A]);
>             }
5823,5824c5362
<       Heatsum += ((double)Count[DIFFCACL2] * Heatf[CACL2] / Molarv[CACL2]);
<       molesdh2o += ((double)Count[DIFFCACL2] * Waterc[CACL2] / Molarv[CACL2]);
---
>         } else if (i == OC3A) {
5826c5364,5367
<     } else if (i == DIFFAS) {
---
>             Alpha += ((double)(Oc3ainit - Count[OC3A]));
>             mass_now += (Specgrav[OC3A] * (double)Count[OC3A]);
>             mc3ar = (double)(Oc3ainit - Count[OC3A]) / Molarv[OC3A];
>             mc4ar = (double)(C4afinit - Count[C4AF]) / Molarv[C4AF];
5828,5829c5369,5374
<       Heatsum += ((double)Count[DIFFAS] * Heatf[ASG] / Molarv[ASG]);
<       molesdh2o += ((double)Count[DIFFAS] * Waterc[ASG] / Molarv[ASG]);
---
>             if((mc3ar + mc4ar) > 0.0) {
>                 frhyg = (mc3ar / (mc3ar + mc4ar))
>                         * (double)Count[C3AH6] / Molarv[C3AH6];
>             } else {
>                 frhyg = 0.0;
>             }
5831c5376,5378
<     } else if (i == DIFFCAS2) {
---
>             frettr = (double)Count[ETTR] / Molarv[ETTR];
>             frafm = 3.0 * (double)Count[AFM] / Molarv[AFM];
>             frtot = frafm + frettr + frhyg;
5833,5834c5380,5390
<       Heatsum += ((double)Count[DIFFCAS2] * Heatf[CAS2] / Molarv[CAS2]);
<       molesdh2o += ((double)Count[DIFFCAS2] * Waterc[CAS2] / Molarv[CAS2]);
---
>             if (frtot > 0.0) {
>                 frettr /= frtot;
>                 frafm /= frtot;
>                 frhyg /= frtot;
>                 heat4 += (frafm * 1.144
>                         * (double)(Oc3ainit - Count[OC3A]) * Specgrav[OC3A]);
>                 heat4 += (frhyg * 0.908
>                         * (double)(Oc3ainit - Count[OC3A]) * Specgrav[OC3A]);
>                 heat4 += (frettr * 1.672
>                         * (double)(Oc3ainit - Count[OC3A]) * Specgrav[OC3A]);
>             }
5836c5392
<     } else if (i == DIFFANH) {
---
>         } else if (i == C4AF) {
5838,5841c5394,5398
<       /***
<        *    ASSUME that all diffusing anhydrite leads
<        *    to gypsum formation
<        ***/
---
>             Alpha += ((double)(C4afinit - Count[C4AF]));
>             mass_now += (Specgrav[C4AF] * (double)Count[C4AF]);
>             mc3ar = (double)(C3ainit - Count[C3A]) / Molarv[C3A];
>             mc3ar += ((double)(Oc3ainit - Count[OC3A]) / Molarv[OC3A]);
>             mc4ar = (double)(C4afinit - Count[C4AF]) / Molarv[C4AF];
5843c5400,5405
<       Heatsum += ((double)Count[DIFFANH] * Heatf[GYPSUMS] / Molarv[GYPSUMS]);
---
>             if ((mc3ar + mc4ar) > 0.0) {
>                 frhyg = (mc4ar / (mc3ar + mc4ar))
>                         * (double)Count[C3AH6] / Molarv[C3AH6];
>             } else {
>                 frhyg = 0.0;
>             }
5845c5407,5408
<       /* 2 moles of water per mole of gypsum formed */
---
>             frettr = (double)Count[ETTRC4AF] / Molarv[ETTRC4AF];
>             frtot = frettr + frhyg;
5847c5410,5417
<       molesdh2o += ((double)Count[DIFFANH] * 2.0 / Molarv[GYPSUMS]);
---
>             if (frtot > 0.0) {
>                 frettr /= frtot;
>                 frhyg /= frtot;
>                 heat4 += (frhyg * 0.418
>                     * (double)(C4afinit - Count[C4AF]) * Specgrav[C4AF]);
>                 heat4 += (frettr * 0.725
>                     * (double)(C4afinit - Count[C4AF]) * Specgrav[C4AF]);
>             }
5849c5419
<     } else if (i == DIFFHEM) {
---
>         } else if (i == ANHYDRITE) {
5851,5854c5421,5424
<       /***
<        *    ASSUME that all diffusing hemihydrate leads
<        *    to gypsum formation
<        ***/
---
>             /*
>             Alpha+=(float)(Anhinit-Count[ANHYDRITE]);
>             mass_now+=Specgrav[ANHYDRITE]*(float)Count[ANHYDRITE];
>             */
5856c5426,5429
<       Heatsum += ((double)Count[DIFFHEM] * Heatf[GYPSUMS] / Molarv[GYPSUMS]);
---
>             /***
>             *    0.187 kJ/g anhydrite for
>             *    anhydrite --> gypsum conversion
>             ***/
5858c5431,5432
<       /* 1.5 moles of water per mole of gypsum formed */
---
>             heat4 += (0.187 * (double)(Anhinit - Count[ANHYDRITE])
>                     * Specgrav[ANHYDRITE]);
5860c5434,5437
<       molesdh2o += ((double)Count[DIFFHEM] * 1.5 / Molarv[GYPSUMS]);
---
>             /***
>             *    2 moles of water consumed per mole of
>             *    anhydrite reacted
>             ***/
5862c5439,5440
<     } else if (i == C3S) {
---
>             Molesh2o += ((double)(Anhinit - Count[ANHYDRITE])
>                     * 2.0 / Molarv[ANHYDRITE]);
5864,5866d5441
<       Alpha += ((double)(C3sinit - Count[C3S]));
<       mass_now += (Specgrav[C3S] * (double)Count[C3S]);
<       heat4 += (0.517 * (double)(C3sinit - Count[C3S]) * Specgrav[C3S]);
5868c5443
<     } else if (i == C2S) {
---
>         } else if (i == HEMIHYD) {
5870,5872c5445,5448
<       Alpha += ((double)(C2sinit - Count[C2S]));
<       mass_now += (Specgrav[C2S] * (double)Count[C2S]);
<       heat4 += (0.262 * (double)(C2sinit - Count[C2S]) * Specgrav[C2S]);
---
>             /*
>             Alpha += (float)(Heminit - Count[HEMIHYD]);
>             mass_now += Specgrav[HEMIHYD] * (float)Count[HEMIHYD];
>             */
5874c5450,5453
<     } else if (i == C3A) {
---
>             /***
>             *    0.132 kJ/g hemihydrate for
>             *    hemihydrate-->gypsum conversion
>             ***/
5876,5879c5455,5456
<       Alpha += ((double)(C3ainit - Count[C3A]));
<       mass_now += (Specgrav[C3A] * (double)Count[C3A]);
<       mc3ar = ((double)(C3ainit - Count[C3A]) / Molarv[C3A]);
<       mc4ar = ((double)(C4afinit - Count[C4AF]) / Molarv[C4AF]);
---
>             heat4 += (0.132 * (double)(Heminit - Count[HEMIHYD])
>                     * Specgrav[HEMIHYD]);
5881,5886c5458,5461
<       if ((mc3ar + mc4ar) > 0.0) {
<         frhyg =
<             (mc3ar / (mc3ar + mc4ar)) * (double)Count[C3AH6] / Molarv[C3AH6];
<       } else {
<         frhyg = 0.0;
<       }
---
>             /***
>             *    1.5 moles of water consumed per mole
>             *    of hemihydrate converted
>             ***/
5888,5890c5463,5466
<       frettr = (double)Count[ETTR] / Molarv[ETTR];
<       frafm = 3.0 * (double)Count[AFM] / Molarv[AFM];
<       frtot = frafm + frettr + frhyg;
---
>             Molesh2o += ((double)(Heminit - Count[HEMIHYD])
>                     * 1.5 / Molarv[HEMIHYD]);
>                     
>         } else if (i == K2SO4) {
5892,5902c5468,5471
<       if (frtot > 0.0) {
<         frettr /= frtot;
<         frafm /= frtot;
<         frhyg /= frtot;
<         heat4 +=
<             (frafm * 1.144 * (double)(C3ainit - Count[C3A]) * Specgrav[C3A]);
<         heat4 +=
<             (frhyg * 0.908 * (double)(C3ainit - Count[C3A]) * Specgrav[C3A]);
<         heat4 +=
<             (frettr * 1.672 * (double)(C3ainit - Count[C3A]) * Specgrav[C3A]);
<       }
---
>             /***
>             *    0.070 kJ/g potassium sulfate for
>             *    k2so4-->gypsum conversion
>             ***/
5904c5473,5474
<     } else if (i == OC3A) {
---
>             heat4 += (0.070 * (double)(Ksulfinit - Count[K2SO4])
>                     * Specgrav[K2SO4]);
5906,5909c5476,5479
<       Alpha += ((double)(Oc3ainit - Count[OC3A]));
<       mass_now += (Specgrav[OC3A] * (double)Count[OC3A]);
<       mc3ar = (double)(Oc3ainit - Count[OC3A]) / Molarv[OC3A];
<       mc4ar = (double)(C4afinit - Count[C4AF]) / Molarv[C4AF];
---
>             /***
>             *    All K2SO4 dissolved assumed to form GYPSUMS,
>             *    thus consuming 2.0 moles of water
>             ***/
5911,5916c5481,5484
<       if ((mc3ar + mc4ar) > 0.0) {
<         frhyg =
<             (mc3ar / (mc3ar + mc4ar)) * (double)Count[C3AH6] / Molarv[C3AH6];
<       } else {
<         frhyg = 0.0;
<       }
---
>             Molesh2o += ((double)(Ksulfinit - Count[K2SO4])
>                     * 2.0 / Molarv[K2SO4]);
>                     
>         } else if (i == NA2SO4) {
5918,5920c5486,5489
<       frettr = (double)Count[ETTR] / Molarv[ETTR];
<       frafm = 3.0 * (double)Count[AFM] / Molarv[AFM];
<       frtot = frafm + frettr + frhyg;
---
>             /***
>             *    0.442 kJ/g sodium sulfate for
>             *    na2so4-->gypsum conversion
>             ***/
5922,5932c5491,5492
<       if (frtot > 0.0) {
<         frettr /= frtot;
<         frafm /= frtot;
<         frhyg /= frtot;
<         heat4 +=
<             (frafm * 1.144 * (double)(Oc3ainit - Count[OC3A]) * Specgrav[OC3A]);
<         heat4 +=
<             (frhyg * 0.908 * (double)(Oc3ainit - Count[OC3A]) * Specgrav[OC3A]);
<         heat4 += (frettr * 1.672 * (double)(Oc3ainit - Count[OC3A]) *
<                   Specgrav[OC3A]);
<       }
---
>             heat4 += (0.442 * (double)(Nasulfinit - Count[NA2SO4])
>                     * Specgrav[NA2SO4]);
5934c5494,5497
<     } else if (i == C4AF) {
---
>             /***
>             *    All NA2SO4 dissolved assumed to form GYPSUMS,
>             *    thus consuming 2.0 moles of water
>             ***/
5936,5940c5499,5502
<       Alpha += ((double)(C4afinit - Count[C4AF]));
<       mass_now += (Specgrav[C4AF] * (double)Count[C4AF]);
<       mc3ar = (double)(C3ainit - Count[C3A]) / Molarv[C3A];
<       mc3ar += ((double)(Oc3ainit - Count[OC3A]) / Molarv[OC3A]);
<       mc4ar = (double)(C4afinit - Count[C4AF]) / Molarv[C4AF];
---
>             Molesh2o += ((double)(Nasulfinit - Count[NA2SO4])
>                     * 2.0 / Molarv[NA2SO4]);
>                     
>         } else if (i == FREELIME) {
5942,5947c5504,5505
<       if ((mc3ar + mc4ar) > 0.0) {
<         frhyg =
<             (mc4ar / (mc3ar + mc4ar)) * (double)Count[C3AH6] / Molarv[C3AH6];
<       } else {
<         frhyg = 0.0;
<       }
---
>             heat4 += (0.979 * (double)(Freelimeinit - Count[FREELIME])
>                             * Specgrav[FREELIME]);
5949,5950c5507,5508
<       frettr = (double)Count[ETTRC4AF] / Molarv[ETTRC4AF];
<       frtot = frettr + frhyg;
---
>         }
>     }
5952,5959c5510,5511
<       if (frtot > 0.0) {
<         frettr /= frtot;
<         frhyg /= frtot;
<         heat4 +=
<             (frhyg * 0.418 * (double)(C4afinit - Count[C4AF]) * Specgrav[C4AF]);
<         heat4 += (frettr * 0.725 * (double)(C4afinit - Count[C4AF]) *
<                   Specgrav[C4AF]);
<       }
---
>     mass105 *= volpix;
>     massdiff *= (volpix * molwh2o);
5961c5513
<     } else if (i == ANHYDRITE) {
---
>     mass1000 = mass105 - massdiff;
5963,5966c5515,5519
<       /*
<       Alpha+=(float)(Anhinit-Count[ANHYDRITE]);
<       mass_now+=Specgrav[ANHYDRITE]*(float)Count[ANHYDRITE];
<       */
---
>     /***
>     *    Calculate non-evaporable water content on relative to
>     *        (1) original dry cement powder
>     *        (2) ignited cement powder
>     ***/
5968,5971c5521,5529
<       /***
<        *    0.187 kJ/g anhydrite for
<        *    anhydrite --> gypsum conversion
<        ***/
---
>     if (mass1000 <= 0.0 || Mass_105 <= 0.0) {
>         Wn_o = 0.0;
>         Wn_i = 0.0;
>     } else { 
>         Wn_o = ((mass105 * Mass_1000)/(mass1000 * Mass_105)) - 1.0;
>     
>         Wn_i = (mass105/mass1000) - 1.0;
>         Wn_i -= ((Mass_105/Mass_1000) - 1.0);
>     }
5973,5974c5531,5535
<       heat4 +=
<           (0.187 * (double)(Anhinit - Count[ANHYDRITE]) * Specgrav[ANHYDRITE]);
---
>     if (suminit != 0) {
>         Alpha /= (float)suminit;
>     } else {
>         Alpha = 0.0;
>     }
5976,5979c5537
<       /***
<        *    2 moles of water consumed per mole of
<        *    anhydrite reacted
<        ***/
---
>     /* Current degree of hydration on a mass basis */
5981,5982c5539,5543
<       Molesh2o +=
<           ((double)(Anhinit - Count[ANHYDRITE]) * 2.0 / Molarv[ANHYDRITE]);
---
>     if (Cemmass > 0.0){
>         Alpha_cur = 1.0 - (mass_now / Cemmass);
>     } else {
>         Alpha_cur = 0.0;
>     }
5984c5545
<     } else if (i == HEMIHYD) {
---
>     /* Current degree of hydration of fly ash on a mass basis */
5986,5989c5547,5554
<       /*
<       Alpha += (float)(Heminit - Count[HEMIHYD]);
<       mass_now += Specgrav[HEMIHYD] * (float)Count[HEMIHYD];
<       */
---
>     mass_fa_now = Specgrav[SFUME]*(double)Count[SFUME];
>     mass_fa_now += Specgrav[AMSIL]*(double)Count[AMSIL];
>     mass_fa_now += Specgrav[ASG]*(double)Count[ASG];
>     mass_fa_now += Specgrav[CAS2]*(double)Count[CAS2];
>     vol_fa_now = (double)Count[SFUME];
>     vol_fa_now += (double)Count[AMSIL];
>     vol_fa_now += (double)Count[ASG];
>     vol_fa_now += (double)Count[CAS2];
5991,5996c5556,5562
<       /***
<        *    0.132 kJ/g hemihydrate for
<        *    hemihydrate-->gypsum conversion
<        ***/
< 
<       heat4 += (0.132 * (double)(Heminit - Count[HEMIHYD]) * Specgrav[HEMIHYD]);
---
>     if (Flyashmass > 0.0){
>         Alpha_fa_cur = 1.0 - (mass_fa_now / Flyashmass);
>         Alpha_fa_vol = 1.0 - (vol_fa_now / Flyashvol);
>     } else {
>         Alpha_fa_cur = 0.0;
>         Alpha_fa_vol = 0.0;
>     }
5998,6001c5564,5571
<       /***
<        *    1.5 moles of water consumed per mole
<        *    of hemihydrate converted
<        ***/
---
>     /***
>      * h2oinit is the intial number of MOLES of water.  Water
>      * and saturated porosity are assumed to be one and the same,
>      * so Porinit, being the number of voxels of saturated porosity
>      * and therefore a measure of the saturated pore volume, is
>      * assumed to be the same as the volume of pure water
>      ***/
>     h2oinit = (float)Porinit / Molarv[POROSITY];
6003c5573,5579
<       Molesh2o += ((double)(Heminit - Count[HEMIHYD]) * 1.5 / Molarv[HEMIHYD]);
---
>     /***
>     *    Only will be important if a crack is added at
>     *    the zeroth cycle, which currently is not possible
>     *    (24 May 2004)
>     ***/
>      
>     h2oinit += (float)Crackpinit / Molarv[CRACKP];
6005c5581,5587
<     } else if (i == K2SO4) {
---
>     /***
>     *    ASSUME 0.78 kJ/g S for pozzolanic reaction 
>     *
>     *    Each unit of silica fume consumes 1.35 units of CH,
>     *    so divide Nsilica_rx by 1.35 to get silca fume which has reacted
>     *    (Nsilica_rx = number silica units that have reacted)
>     ***/
6007,6010c5589,5590
<       /***
<        *    0.070 kJ/g potassium sulfate for
<        *    k2so4-->gypsum conversion
<        ***/
---
>     psfact = (SF_SiO2_val)/100.0;
>     heat4 += 0.78 * psfact * ((float)Nsilica_rx / 1.35) * Specgrav[SFUME];
6012c5592,5597
<       heat4 += (0.070 * (double)(Ksulfinit - Count[K2SO4]) * Specgrav[K2SO4]);
---
>     /***
>     *    ASSUME 0.8 kJ/g S for slag reaction 
>     *
>     *    Seems consistent with measurements made by
>     *    Biernacki and Richardson 
>     ***/
6014,6017c5599
<       /***
<        *    All K2SO4 dissolved assumed to form GYPSUMS,
<        *    thus consuming 2.0 moles of water
<        ***/
---
>     heat4 += 0.8 * ((float)Nslagr) * Specgrav[SLAG];
6019c5601,5606
<       Molesh2o += ((double)(Ksulfinit - Count[K2SO4]) * 2.0 / Molarv[K2SO4]);
---
>     /***
>     *    ASSUME 0.8 kJ/g AS for stratlingite formation (DeLarrard)
>     *
>     *    Each unit of AS consumes 1.3267 units of CH,
>     *    so divide Nasr by 1.3267 to get ASG which has reacted
>     ***/
6021c5608
<     } else if (i == NA2SO4) {
---
>     heat4 += 0.8 * ((float)Nasr / 1.3267) * Specgrav[ASG];
6023,6026c5610,5614
<       /***
<        *    0.442 kJ/g sodium sulfate for
<        *    na2so4-->gypsum conversion
<        ***/
---
>     /***
>     *    Should be additional code here for heat release
>     *    due to CAS2 --> stratlingite conversion, but data
>     *    are unavailable at this time
>     ***/
6028,6029c5616,5631
<       heat4 +=
<           (0.442 * (double)(Nasulfinit - Count[NA2SO4]) * Specgrav[NA2SO4]);
---
>     /***
>     *    Adjust heat sum for water left in system...
>     *    The addition of 0.5 ensures that we round to the
>     *    nearest integer
>     *
>     *    h2oinit is the initial MOLES of water in the system
>     *    Molesh2o is the number of MOLES of water consumed by all hydration
>     *        reactions over all cycles. It is set to zero at the
>     *        beginning of each dissolve cycle and
>     *        recalculated
>     *
>     *    Water_left is the VOLUME of liquid water remaining in the system,
>     *    which should include water in capillary pores AND water in
>     *    CSH gel pores.
>     *
>     ***/
6031,6034c5633,5636
<       /***
<        *    All NA2SO4 dissolved assumed to form GYPSUMS,
<        *    thus consuming 2.0 moles of water
<        ***/
---
>     Water_left = (h2oinit - Molesh2o) * Molarv[POROSITY] + 0.5;
>     Water_left += Count[CRACKP];
>     Countkeep = Count[POROSITY] + Count[CRACKP];
>     Heatsum += ((h2oinit - Molesh2o - molesdh2o) * Heatf[POROSITY]);
6036c5638,5661
<       Molesh2o += ((double)(Nasulfinit - Count[NA2SO4]) * 2.0 / Molarv[NA2SO4]);
---
>     if (Cyccnt == 0) {
>         Datafile = filehandler("disrealnew",Datafilename,"WRITE");
>         if (!Datafile) {
>             freeallmem();
>             exit(1);
>         }
>         fprintf(Datafile,"Cycle,time(h),Alpha_mass,");
>         fprintf(Datafile,"Alpha_fa_mass,heat(kJ/kg_cem),");
>         fprintf(Datafile,"Temperature(C),Gsratio,");
>         fprintf(Datafile,"Wno(g/g),Wni(g/g),ChemShrink(mL/g),pH,");
>         fprintf(Datafile,"Conductivity(S/m),[Na+](M),[K+](M),[Ca++](M),");
>         fprintf(Datafile,"[SO4--](M),{K+},{Ca++},{OH-},{SO4--},");
>         fprintf(Datafile,"Vfpore,Poreconnx,Poreconny,Poreconnz,Poreconnave,");
>         fprintf(Datafile,"Solidconnx,Solidconny,Solidconnz,Solidconnave,");
>         fprintf(Datafile,"VfC3S,VfC2S,VfC3A,VfOC3A,");
>         fprintf(Datafile,"VfC4AF,VfK2SO4,VfNA2SO4,VfGYPSUM,");
>         fprintf(Datafile,"VfHEMIHYD,VfANHYDRITE,VfCACO3,");
>         fprintf(Datafile,"VfFREELIME,VfSFUME,VfINERT,");
>         fprintf(Datafile,"VfSLAG,VfASG,VfCAS2,VfAMSIL,");
>         fprintf(Datafile,"VfCH,VfCSH,VfPOZZCSH,VfSLAGCSH,");
>         fprintf(Datafile,"VfC3AH6,VfETTR,VfAFM,VfFH3,");
>         fprintf(Datafile,"VfCACL2,VfFRIEDEL,VfSTRAT,VfGYPSUMS,");
>         fprintf(Datafile,"VfABSGYP,VfAFMC,VfINERTAGG,VfEMPTYP\n");
>         fclose(Datafile);
6038,6041c5663,5668
<     } else if (i == FREELIME) {
< 
<       heat4 += (0.979 * (double)(Freelimeinit - Count[FREELIME]) *
<                 Specgrav[FREELIME]);
---
>         if ((fpout01 = fopen("SfumeEffect.csv","w")) == NULL) {
>             printf("\nWARNING:  Could not open SfumeEffect.csv to write header\n");
>         } else {
>             fprintf(fpout01,"CSH,TOTCSH,Cs_acc,Psfume,dface,Cshscale,Disprob[C3S]\n");
>             fclose(fpout01);
>         }
6043d5669
<   }
6045,6046c5671,5674
<   mass105 *= volpix;
<   massdiff *= (volpix * molwh2o);
---
>     /***
>     *    Use heat4 for all adiabatic calculations
>     *    due to best agreement with calorimetry data
>     ***/
6048c5676
<   mass1000 = mass105 - massdiff;
---
>     Heat_new = heat4;
6050,6054c5678,5682
<   /***
<    *    Calculate non-evaporable water content on relative to
<    *        (1) original dry cement powder
<    *        (2) ignited cement powder
<    ***/
---
>     /***
>     *    Should we include water in saturated CRACKP in the
>     *    calculations for chemical shrinkage?  Currently, no.
>     *    (24 May 2004)
>     ***/
6056,6060c5684,5685
<   if (mass1000 <= 0.0 || Mass_105 <= 0.0) {
<     Wn_o = 0.0;
<     Wn_i = 0.0;
<   } else {
<     Wn_o = ((mass105 * Mass_1000) / (mass1000 * Mass_105)) - 1.0;
---
>     Chs_new = ((double)(Count[EMPTYP] + Count[POROSITY] - Water_left)
>                 * Heat_cf /1000.0);
6062,6064c5687,5694
<     Wn_i = (mass105 / mass1000) - 1.0;
<     Wn_i -= ((Mass_105 / Mass_1000) - 1.0);
<   }
---
>     if (Verbose) printf("\nChs_new = %f\n",Chs_new);
>     if (((Water_left + Water_off) < 0) && (Sealed==1) ) {
>         if (Verbose) printf("All water consumed at cycle %d \n",Cyccnt);
>         fflush(stdout);
>         freeallmem();
>         bailout("dissolve","Normal exit");
>         exit(1);
>     }
6066,6070c5696,5737
<   if (suminit != 0) {
<     Alpha /= (float)suminit;
<   } else {
<     Alpha = 0.0;
<   }
---
>     /***
>     *    Attempt to create empty porosity to account
>     *    for self-desiccation
>     *
>     *    Water_left is the total volume of LIQUID water in the system,
>     *    which can occupy both capillary pores, (POROSITY) voxels, and
>     *    also part of the CSH voxels depending on the internal
>     *    gel porosity.
>     *
>     *    Water_off is the volume of LIQUID water that was in the
>     *    system at the moment the pore space depercolated, otherwise
>     *    it is zero.
>     *
>     *   See H.F.W. Taylor, Mater. Res. Soc. Proc.
> 	* 	Vol. 85, p. 47 (1987) for information on
> 	* 	stoichiometry at 105 C
> 	*
>     *   In that paper, Taylor proposes that the molar
>     *   ratio of BOUND H2O to Ca is 1.4. So if C-S-H
>     *   is defined as 1 mol CSH = 1 mol Si, then 1 mol
>     *   of CSH has 1.7 mol Ca and therefore 2.38 moles
>     *   of bound water per mole of CSH.
>     *
>     *   So Waterc[CSH] of 4.0 assumes
>     *   1.62 moles of free water per mole of CSH.
>     *   Using the Molarv[CSH] value of 107.81 cm3
>     *   below, and the fact that 1.62 moles of free water
>     *   occupies a volume of 29.16 cm3, this implies that 
>     *   CSH has an internal free-water pore volume
>     *   of 29.16 cm3/mole or a free water volume
>     *   fraction of 0.27.
>     *
>     *   Therefore, the condition below was changed to account
>     *   for the free water in CSH. 
>     *
>     *   @TODO Change the hard-wired 0.27 factor below to account
>     *   for changes in free water volume fraction due to
>     *   temperature change.
>     *
> 	*	18 Dec 2020
>     *
>     ***/
6072c5739,5742
<   /* Current degree of hydration on a mass basis */
---
>     if ((Sealed == 1) && ((Count[POROSITY] + Count[CRACKP]
>                     + (0.27*Count[CSH]) - Water_left) > 0)) {
>         Poretodo = (Count[POROSITY] + Count[CRACKP] + (0.27*Count[CSH])
>                 - Pore_off) - (Water_left - Water_off) - Slagemptyp;
6074,6078c5744,5748
<   if (Cemmass > 0.0) {
<     Alpha_cur = 1.0 - (mass_now / Cemmass);
<   } else {
<     Alpha_cur = 0.0;
<   }
---
>         if (Poretodo > 0) {
>             makeinert(Poretodo);
>             Poregone += Poretodo;
>         }
>     }
6080c5750,5756
<   /* Current degree of hydration of fly ash on a mass basis */
---
>     /***
>     *    The following is an adjusted pH to compensate
>     *    for the water/c ratio, relative to a w/c
>     *    of 0.4.  This appears to be necessary only for
>     *    flyash reactions.  Eventually should be eliminated
>     *    in favor of something more realistic.
>     ***/
6082,6097c5758,5759
<   mass_fa_now = Specgrav[SFUME] * (double)Count[SFUME];
<   mass_fa_now += Specgrav[AMSIL] * (double)Count[AMSIL];
<   mass_fa_now += Specgrav[ASG] * (double)Count[ASG];
<   mass_fa_now += Specgrav[CAS2] * (double)Count[CAS2];
<   vol_fa_now = (double)Count[SFUME];
<   vol_fa_now += (double)Count[AMSIL];
<   vol_fa_now += (double)Count[ASG];
<   vol_fa_now += (double)Count[CAS2];
< 
<   if (Flyashmass > 0.0) {
<     Alpha_fa_cur = 1.0 - (mass_fa_now / Flyashmass);
<     Alpha_fa_vol = 1.0 - (vol_fa_now / Flyashvol);
<   } else {
<     Alpha_fa_cur = 0.0;
<     Alpha_fa_vol = 0.0;
<   }
---
>     ohadj = log10(pow((W_to_c/0.503130),0.75)*pow(10.0,(PH_cur - 14.0)));
>     ohadj += 14.0;
6099,6106c5761,5764
<   /***
<    * h2oinit is the intial number of MOLES of water.  Water
<    * and saturated porosity are assumed to be one and the same,
<    * so Porinit, being the number of voxels of saturated porosity
<    * and therefore a measure of the saturated pore volume, is
<    * assumed to be the same as the volume of pure water
<    ***/
<   h2oinit = (float)Porinit / Molarv[POROSITY];
---
>     /***
>     *    Output phase counts
>     *    phfile for reactant and product phases
>     ***/
6108,6112c5766,5768
<   /***
<    *    Only will be important if a crack is added at
<    *    the zeroth cycle, which currently is not possible
<    *    (24 May 2004)
<    ***/
---
>     if (cycle == 0) {
>         return;
>     }
6114c5770
<   h2oinit += (float)Crackpinit / Molarv[CRACKP];
---
>     Cyccnt++;
6116,6122c5772,5774
<   /***
<    *    ASSUME 0.78 kJ/g S for pozzolanic reaction
<    *
<    *    Each unit of silica fume consumes 1.35 units of CH,
<    *    so divide Nsilica_rx by 1.35 to get silca fume which has reacted
<    *    (Nsilica_rx = number silica units that have reacted)
<    ***/
---
>     /* Update current volume count for CH */
>     Chold = Chnew;
>     Chnew = Count[CH];
6124,6125c5776,5780
<   psfact = (SF_SiO2_val) / 100.0;
<   heat4 += 0.78 * psfact * ((float)Nsilica_rx / 1.35) * Specgrav[SFUME];
---
>     /***
>     *    See if ettringite is soluble yet:
>     *        (a) Gypsum 75% consumed (changed 09.09.01 from 80% to 75%),
>     *        (b) or system temperature exceeds 70 C
>     ***/
6127,6132c5782
<   /***
<    *    ASSUME 0.8 kJ/g S for slag reaction
<    *
<    *    Seems consistent with measurements made by
<    *    Biernacki and Richardson
<    ***/
---
>     if (((Ncsbar + Anhinit + Heminit) > 0.0) || (Temp_cur_b >= 70.0)) {
6134c5784
<   heat4 += 0.8 * ((float)Nslagr) * Specgrav[SLAG];
---
>         /* Account for all sulfate sources and forms */
6136,6141c5786,5793
<   /***
<    *    ASSUME 0.8 kJ/g AS for stratlingite formation (DeLarrard)
<    *
<    *    Each unit of AS consumes 1.3267 units of CH,
<    *    so divide Nasr by 1.3267 to get ASG which has reacted
<    ***/
---
>         fact = (double)Count[GYPSUM]
>                     + 1.42 * (double)Count[ANHYDRITE]
>                     + 1.4 * (double)Count[HEMIHYD]
>                     + 1.13 * (double)Count[K2SO4]
>                     + 1.4 * (double)Count[NA2SO4]
>                     + (double)Count[GYPSUMS];
>         fact /= ((double)Ncsbar + 1.42 * (double)Anhinit + 1.13 * (double)Ksulfinit
>                 + 1.4 * (double)Nasulfinit + 1.4 * (double)Heminit + ((double)Netbar / 3.30));
6143c5795,5798
<   heat4 += 0.8 * ((float)Nasr / 1.3267) * Specgrav[ASG];
---
>         if ((!Soluble[ETTR])
>                 && ((Temp_cur_b >= 70.0)
>                     || (Count[AFM] > 0)
>                     || (fact < 0.25)) ) {
6145,6149c5800,5801
<   /***
<    *    Should be additional code here for heat release
<    *    due to CAS2 --> stratlingite conversion, but data
<    *    are unavailable at this time
<    ***/
---
>             Soluble[ETTR] = 1;
>             if (Verbose) printf("Ettringite is soluble beginning at cycle %d \n",cycle);
6151,6166c5803
<   /***
<    *    Adjust heat sum for water left in system...
<    *    The addition of 0.5 ensures that we round to the
<    *    nearest integer
<    *
<    *    h2oinit is the initial MOLES of water in the system
<    *    Molesh2o is the number of MOLES of water consumed by all hydration
<    *        reactions over all cycles. It is set to zero at the
<    *        beginning of each dissolve cycle and
<    *        recalculated
<    *
<    *    Water_left is the VOLUME of liquid water remaining in the system,
<    *    which should include water in capillary pores AND water in
<    *    CSH gel pores.
<    *
<    ***/
---
>             /* Identify all new soluble ettringite */
6168,6171c5805,5807
<   Water_left = (h2oinit - Molesh2o) * Molarv[POROSITY] + 0.5;
<   Water_left += Count[CRACKP];
<   Countkeep = Count[POROSITY] + Count[CRACKP];
<   Heatsum += ((h2oinit - Molesh2o - molesdh2o) * Heatf[POROSITY]);
---
>             passone(ETTR,ETTR,2,0);
>         }
>     }            /* end of soluble ettringite test */
6173,6196c5809,5823
<   if (Cyccnt == 0) {
<     Datafile = filehandler("disrealnew", Datafilename, "WRITE");
<     if (!Datafile) {
<       freeallmem();
<       exit(1);
<     }
<     fprintf(Datafile, "Cycle,time(h),Alpha_mass,");
<     fprintf(Datafile, "Alpha_fa_mass,heat(kJ/kg_cem),");
<     fprintf(Datafile, "Temperature(C),Gsratio,");
<     fprintf(Datafile, "Wno(g/g),Wni(g/g),ChemShrink(mL/g),pH,");
<     fprintf(Datafile, "Conductivity(S/m),[Na+](M),[K+](M),[Ca++](M),");
<     fprintf(Datafile, "[SO4--](M),{K+},{Ca++},{OH-},{SO4--},");
<     fprintf(Datafile, "Vfpore,Poreconnx,Poreconny,Poreconnz,Poreconnave,");
<     fprintf(Datafile, "Solidconnx,Solidconny,Solidconnz,Solidconnave,");
<     fprintf(Datafile, "VfC3S,VfC2S,VfC3A,VfOC3A,");
<     fprintf(Datafile, "VfC4AF,VfK2SO4,VfNA2SO4,VfGYPSUM,");
<     fprintf(Datafile, "VfHEMIHYD,VfANHYDRITE,VfCACO3,");
<     fprintf(Datafile, "VfFREELIME,VfSFUME,VfINERT,");
<     fprintf(Datafile, "VfSLAG,VfASG,VfCAS2,VfAMSIL,");
<     fprintf(Datafile, "VfCH,VfCSH,VfPOZZCSH,VfSLAGCSH,");
<     fprintf(Datafile, "VfC3AH6,VfETTR,VfAFM,VfFH3,");
<     fprintf(Datafile, "VfCACL2,VfFRIEDEL,VfSTRAT,VfGYPSUMS,");
<     fprintf(Datafile, "VfABSGYP,VfAFMC,VfINERTAGG,VfEMPTYP\n");
<     fclose(Datafile);
---
>     /***
>     *    Calculate the volume fraction of saturated porosity
>     *    relative to the reference volume fraction for a system
>     *    with initial w/c of 0.4.  That is, Vfpores is 1.0 when
>     *    the porosity is equal to the initial porosity for a system
>     *    with w/c of 0.4
>     *
>     *    18 April 2003
>     *
>     *    Currently, we do NOT include water in saturated cracks
>     *    formed during hydration as part of the volume fraction of
>     *    porosity.  Modify the line below to change this.
>     *
>     *    24 May 2004
>     ***/
6198,6206c5825,5863
<     if ((fpout01 = fopen("SfumeEffect.csv", "w")) == NULL) {
<       if (Verbose_flag > 0) {
<         fprintf(Logfile,
<                 "\nWARNING:  Could not open SfumeEffect.csv to write header\n");
<       }
<     } else {
<       fprintf(fpout01,
<               "CSH,TOTCSH,Cs_acc,Psfume,dface,Cshscale,Disprob[C3S]\n");
<       fclose(fpout01);
---
>     Relvfpores = ((double)Count[POROSITY])/((double)Syspix);
> 
>     /***
>     *    Normalize to that for w/c = 0.4 (= WCSCALE)
>     ***/
> 
>     refporefrac = 1.0 / (1.0 + (Specgrav[POROSITY]/(Meancemdens * WCSCALE)));
>     Relvfpores /= refporefrac;
> 
>     /***
>     *    The following are all maximum or critical numbers
>     *    of diffusing pixels.  For example, DETTRMAX is an
>     *    absolute number of pixels, which must be modified
>     *    to reflect increases in system size and changes
>     *    in the volume fraction of porosity
>     *
>     *    Change made 4 April 2003
>     ***/
> 
>     Dk2so4max = (int)(((double)DK2SO4MAX) * Sizemag * Relvfpores);
>     Dna2so4max = (int)(((double)DNA2SO4MAX) * Sizemag * Relvfpores);
>     Dettrmax = (int)(((double)DETTRMAX) * Sizemag * Relvfpores);
>     Dgypmax = (int)(((double)DGYPMAX) * Sizemag * Relvfpores);
>     Dcaco3max = (int)(((double)DCACO3MAX) * Sizemag * Relvfpores);
>     Dcacl2max = (int)(((double)DCACL2MAX) * Sizemag * Relvfpores);
>     Dcas2max = (int)(((double)DCAS2MAX) * Sizemag * Relvfpores);
>     Dasmax = (int)(((double)DASMAX) * Sizemag * Relvfpores);
> 
>     Chcrit = CHCRIT * Sizemag * Relvfpores;
> 
>     /***
>     *    Adjust Chcrit higher if pozzolanic material is
>     *    available in the system (4 April 2003)
>     *
>     *    Disabled on 9 April 2003
>     ***/
> 
>     if ((((double)(Count[SFUME]+Count[AMSIL]))/((double)Syspix)) > 0.01) {
>         Chcrit *= 10.0;
6208d5864
<   }
6210,6213c5866
<   /***
<    *    Use heat4 for all adiabatic calculations
<    *    due to best agreement with calorimetry data
<    ***/
---
>     C3ah6crit = C3AH6CRIT * Sizemag * Relvfpores;
6215c5868,5871
<   Heat_new = heat4;
---
>     /***
>     *    Adjust ettringite solubility
>     *    if too many ettringites already in solution
>     ***/
6217,6221c5873,5877
<   /***
<    *    Should we include water in saturated CRACKP in the
<    *    calculations for chemical shrinkage?  Currently, no.
<    *    (24 May 2004)
<    ***/
---
>     if (Count[DIFFETTR] > Dettrmax) {
>         Disprob[ETTR] = 0.0;
>     } else {
>         Disprob[ETTR]= Disbase[ETTR];
>     }
6223,6224c5879,5882
<   Chs_new = ((double)(Count[EMPTYP] + Count[POROSITY] - Water_left) * Heat_cf /
<              1000.0);
---
>     /***
>     *    Adjust CaCl2 solubility
>     *    if too many CaCl2 already in solution
>     ***/
6226,6235c5884,5888
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "\nChs_new = %f\n", Chs_new);
<   if (((Water_left + Water_off) < 0) && (Sealed == 1)) {
<     if (Verbose_flag > 1)
<       fprintf(Logfile, "All water consumed at cycle %d \n", Cyccnt);
<     fflush(Logfile);
<     freeallmem();
<     bailout("dissolve", "Normal exit");
<     exit(1);
<   }
---
>     if (Count[DIFFCACL2] > Dcacl2max) {
>         Disprob[CACL2]=0.0;
>     } else {
>         Disprob[CACL2] = Disbase[CACL2];
>     }
6237,6278c5890,5893
<   /***
<    *    Attempt to create empty porosity to account
<    *    for self-desiccation
<    *
<    *    Water_left is the total volume of LIQUID water in the system,
<    *    which can occupy both capillary pores, (POROSITY) voxels, and
<    *    also part of the CSH voxels depending on the internal
<    *    gel porosity.
<    *
<    *    Water_off is the volume of LIQUID water that was in the
<    *    system at the moment the pore space depercolated, otherwise
<    *    it is zero.
<    *
<    *   See H.F.W. Taylor, Mater. Res. Soc. Proc.
<    * 	Vol. 85, p. 47 (1987) for information on
<    * 	stoichiometry at 105 C
<    *
<    *   In that paper, Taylor proposes that the molar
<    *   ratio of BOUND H2O to Ca is 1.4. So if C-S-H
<    *   is defined as 1 mol CSH = 1 mol Si, then 1 mol
<    *   of CSH has 1.7 mol Ca and therefore 2.38 moles
<    *   of bound water per mole of CSH.
<    *
<    *   So Waterc[CSH] of 4.0 assumes
<    *   1.62 moles of free water per mole of CSH.
<    *   Using the Molarv[CSH] value of 107.81 cm3
<    *   below, and the fact that 1.62 moles of free water
<    *   occupies a volume of 29.16 cm3, this implies that
<    *   CSH has an internal free-water pore volume
<    *   of 29.16 cm3/mole or a free water volume
<    *   fraction of 0.27.
<    *
<    *   Therefore, the condition below was changed to account
<    *   for the free water in CSH.
<    *
<    *   @TODO Change the hard-wired 0.27 factor below to account
<    *   for changes in free water volume fraction due to
<    *   temperature change.
<    *
<    *	18 Dec 2020
<    *
<    ***/
---
>     /***
>     *    Adjust CaCO3 solubility
>     *    if too many CaCO3 already in solution
>     ***/
6280,6288c5895,5900
<   if ((Sealed == 1) && ((Count[POROSITY] + Count[CRACKP] + (0.27 * Count[CSH]) -
<                          Water_left) > 0)) {
<     Poretodo =
<         (Count[POROSITY] + Count[CRACKP] + (0.27 * Count[CSH]) - Pore_off) -
<         (Water_left - Water_off) - Slagemptyp;
< 
<     if (Poretodo > 0) {
<       makeinert(Poretodo);
<       Poregone += Poretodo;
---
>     if ((Count[DIFFCACO3] > Dcaco3max) && (!Soluble[ETTR])) {
>         Disprob[CACO3] = 0.0;
>     } else if (Count[DIFFCACO3] > (4 * Dcaco3max)) {
>         Disprob[CACO3] = 0.0;
>     } else {
>         Disprob[CACO3] = Disbase[CACO3];
6290d5901
<   }
6292,6298c5903,5909
<   /***
<    *    The following is an adjusted pH to compensate
<    *    for the water/c ratio, relative to a w/c
<    *    of 0.4.  This appears to be necessary only for
<    *    flyash reactions.  Eventually should be eliminated
<    *    in favor of something more realistic.
<    ***/
---
>     /***
>     *    Adjust solubility of CH based on amount of CH
>     *    currently diffusing
>     *
>     *    Note that CH is always soluble to allow some
>     *    Ostwald ripening of the CH crystals
>     ***/
6300,6301c5911,5915
<   ohadj = log10(pow((W_to_c / 0.503130), 0.75) * pow(10.0, (PH_cur - 14.0)));
<   ohadj += 14.0;
---
>     if ((double)Count[DIFFCH] >= Chcrit) {
>         Disprob[CH] = Disbase[CH] * Chcrit / (double)Count[DIFFCH];
>     } else {
>         Disprob[CH] = Disbase[CH];
>     }
6303,6306c5917,5927
<   /***
<    *    Output phase counts
<    *    phfile for reactant and product phases
<    ***/
---
>     /***
>     *    Adjust solubility of CH for temperature 
>     *
>     *    Fit to data provided in
>     *
>     *        H.F.W. Taylor, "Cement Chemistry", 2nd Edition,
>     *        Telford Publishing, London, 1997
>     *
>     *    Scale to a reference temperature of 25 C
>     *    and adjust based on availability of pozzolan
>     ***/
6308,6310c5929,5932
<   if (cycle == 0) {
<     return;
<   }
---
>     if (Verbose) printf("Count[DIFFCH] = %d, Chcrit = %f, Disbase[CH] = %f\n", Count[DIFFCH],Chcrit,Disbase[CH]);
>     if (Verbose) printf("CH dissolution probability changes from %f ",Disprob[CH]);
>     Disprob[CH] *= ((A0_CHSOL - (A1_CHSOL * Temp_cur_b))
>                 / (A0_CHSOL - (A1_CHSOL * 25.0)));
6312c5934,5942
<   Cyccnt++;
---
>     if ((((double)Count[SFUME])/((double)Syspix)) > 0.01) {
>         if (PHfactor[SFUME] * Psfume > 0.0) {
>             Disprob[CH] *= PHfactor[SFUME] * (Psfume / PSFUME);
>         }
>     } else if ((((double)Count[AMSIL])/((double)Syspix)) > 0.01) {
>         if (PHfactor[AMSIL] * Pamsil > 0.0) {
>             Disprob[CH] *= PHfactor[AMSIL] * (Pamsil / PAMSIL);
>         }
>     }
6314,6316c5944
<   /* Update current volume count for CH */
<   Chold = Chnew;
<   Chnew = Count[CH];
---
>     if (Verbose) printf("to %f \n",Disprob[CH]);
6318,6322c5946,5952
<   /***
<    *    See if ettringite is soluble yet:
<    *        (a) Gypsum 75% consumed (changed 09.09.01 from 80% to 75%),
<    *        (b) or system temperature exceeds 70 C
<    ***/
---
>     /***
>     *    Adjust solubility of ASG and CAS2 phases
>     *    based on pH rise during hydration
>     *
>     *     This is now handled later in this function
>     *     with PHfactors for ASG, CAS2, and AMSIL
>     ***/
6324c5954,5955
<   if (((Ncsbar + Anhinit + Heminit) > 0.0) || (Temp_cur_b >= 70.0)) {
---
>     Disprob[ASG] = Disbase[ASG];
>     Disprob[CAS2] = Disbase[CAS2];
6326c5957,5963
<     /* Account for all sulfate sources and forms */
---
>     /***
>     *    Address solubility of C3AH6 (hydrogarnet)
>     *
>     *    If lots of gypsum or reactive ettringite,
>     *    allow C3AH6 to dissolve to generate diffusing
>     *    C3A species
>     ***/
6328,6333c5965,5968
<     fact = (double)Count[GYPSUM] + 1.42 * (double)Count[ANHYDRITE] +
<            1.4 * (double)Count[HEMIHYD] + 1.13 * (double)Count[K2SO4] +
<            1.4 * (double)Count[NA2SO4] + (double)Count[GYPSUMS];
<     fact /= ((double)Ncsbar + 1.42 * (double)Anhinit +
<              1.13 * (double)Ksulfinit + 1.4 * (double)Nasulfinit +
<              1.4 * (double)Heminit + ((double)Netbar / 3.30));
---
>     fact = ((double)Ncsbar + 1.42 * (double)Anhinit
>             + 1.4 * (double)Heminit) * 0.05;
>     if (((Count[GYPSUM] + Count[GYPSUMS]) > (int)(fact))
>             ||(Count[ETTR] > 500)) {
6335,6336c5970
<     if ((!Soluble[ETTR]) &&
<         ((Temp_cur_b >= 70.0) || (Count[AFM] > 0) || (fact < 0.25))) {
---
>         Soluble[C3AH6] = 1;
6338,6341c5972,5973
<       Soluble[ETTR] = 1;
<       if (Verbose_flag > 1)
<         fprintf(Logfile, "Ettringite is soluble beginning at cycle %d \n",
<                 cycle);
---
>         /* Identify all new soluble C3AH6 */
>         passone(C3AH6,C3AH6,2,0);
6343c5975,5982
<       /* Identify all new soluble ettringite */
---
>         /***
>         *    C3AH6 is soluble, so we must determine Disprob for it.
>         *    Base C3AH6 solubility on maximum sulfate in solution
>         *    from gypsum or ettringite available for dissolution
>         *
>         *    The more the sulfate, the higher this solubility
>         *    should be
>         ***/
6345,6347c5984,5987
<       passone(ETTR, ETTR, 2, 0);
<     }
<   } /* end of soluble ettringite test */
---
>         maxsulfate = Count[DIFFGYP];
>         if ((maxsulfate < Count[DIFFETTR]) && (Soluble[ETTR] == 1)) {
>             maxsulfate = Count[DIFFETTR];
>         }
6349,6363c5989,5992
<   /***
<    *    Calculate the volume fraction of saturated porosity
<    *    relative to the reference volume fraction for a system
<    *    with initial w/c of 0.4.  That is, Vfpores is 1.0 when
<    *    the porosity is equal to the initial porosity for a system
<    *    with w/c of 0.4
<    *
<    *    18 April 2003
<    *
<    *    Currently, we do NOT include water in saturated cracks
<    *    formed during hydration as part of the volume fraction of
<    *    porosity.  Modify the line below to change this.
<    *
<    *    24 May 2004
<    ***/
---
>         /***
>         *    Adjust C3AH6 solubility based on potential
>         *    gypsum which will dissolve
>         ***/
6365c5994,5996
<   Relvfpores = ((double)Count[POROSITY]) / ((double)Syspix);
---
>         maxallowed = (int)( (double)Gypready*Disprob[GYPSUM]
>                                 * (double)Count[POROSITY]
>                                 / ((double)(Syspix)) );
6367,6369c5998
<   /***
<    *    Normalize to that for w/c = 0.4 (= WCSCALE)
<    ***/
---
>         if (maxsulfate < maxallowed) maxsulfate = maxallowed;
6371,6372c6000,6006
<   refporefrac = 1.0 / (1.0 + (Specgrav[POROSITY] / (Meancemdens * WCSCALE)));
<   Relvfpores /= refporefrac;
---
>         if (maxsulfate > 0) {
>             Disprob[C3AH6] = Disbase[C3AH6]
>                                 * (double)maxsulfate / C3ah6crit;
>             if (Disprob[C3AH6] > 0.5) Disprob[C3AH6] = 0.5;
>         } else {
>             Disprob[C3AH6]=Disbase[C3AH6];
>         }
6374,6382c6008
<   /***
<    *    The following are all maximum or critical numbers
<    *    of diffusing pixels.  For example, DETTRMAX is an
<    *    absolute number of pixels, which must be modified
<    *    to reflect increases in system size and changes
<    *    in the volume fraction of porosity
<    *
<    *    Change made 4 April 2003
<    ***/
---
>     } else {
6384,6391c6010
<   Dk2so4max = (int)(((double)DK2SO4MAX) * Sizemag * Relvfpores);
<   Dna2so4max = (int)(((double)DNA2SO4MAX) * Sizemag * Relvfpores);
<   Dettrmax = (int)(((double)DETTRMAX) * Sizemag * Relvfpores);
<   Dgypmax = (int)(((double)DGYPMAX) * Sizemag * Relvfpores);
<   Dcaco3max = (int)(((double)DCACO3MAX) * Sizemag * Relvfpores);
<   Dcacl2max = (int)(((double)DCACL2MAX) * Sizemag * Relvfpores);
<   Dcas2max = (int)(((double)DCAS2MAX) * Sizemag * Relvfpores);
<   Dasmax = (int)(((double)DASMAX) * Sizemag * Relvfpores);
---
>         Soluble[C3AH6] = 0;
6393c6012
<   Chcrit = CHCRIT * Sizemag * Relvfpores;
---
>     } /* end of soluble C3AH6 test */
6395,6400c6014
<   /***
<    *    Adjust Chcrit higher if pozzolanic material is
<    *    available in the system (4 April 2003)
<    *
<    *    Disabled on 9 April 2003
<    ***/
---
>     /* See if silicates are soluble yet */
6402,6404c6016,6018
<   if ((((double)(Count[SFUME] + Count[AMSIL])) / ((double)Syspix)) > 0.01) {
<     Chcrit *= 10.0;
<   }
---
>     if ((!Soluble[C3S])
>             && ( (cycle > 1) || (Count[ETTR] > 0)
>                 || (Count[AFM] > 0) || (Count[ETTRC4AF] > 0) )) {
6406c6020,6021
<   C3ah6crit = C3AH6CRIT * Sizemag * Relvfpores;
---
>         Soluble[C2S] = 1;
>         Soluble[C3S] = 1;
6408,6411c6023,6024
<   /***
<    *    Adjust ettringite solubility
<    *    if too many ettringites already in solution
<    ***/
---
>         /* Identify all new soluble silicates */
>         passone(C3S,C2S,2,0);
6413,6417c6026
<   if (Count[DIFFETTR] > Dettrmax) {
<     Disprob[ETTR] = 0.0;
<   } else {
<     Disprob[ETTR] = Disbase[ETTR];
<   }
---
>     } /* end of soluble silicate test */
6419,6422c6028,6032
<   /***
<    *    Adjust CaCl2 solubility
<    *    if too many CaCl2 already in solution
<    ***/
---
>     /***
>     *    Adjust solubility of C3S and C2S with
>     *    CSH concentration for simulation of
>     *    induction period
>     ***/
6424,6428c6034
<   if (Count[DIFFCACL2] > Dcacl2max) {
<     Disprob[CACL2] = 0.0;
<   } else {
<     Disprob[CACL2] = Disbase[CACL2];
<   }
---
>     tdisfact = A0_CHSOL - (Temp_cur_b * A1_CHSOL);
6430,6433c6036,6042
<   /***
<    *    Adjust CaCO3 solubility
<    *    if too many CaCO3 already in solution
<    ***/
---
>     /***
>     *    Calculation of Cs_acc; acceleration of C3S and C2S
>     *        reaction by CaSO4
>     *
>     *    Calculation of Ca_acc; acceleration of C3A and C4AF
>     *        reaction by CaSO4
>     ***/
6435,6449c6044,6068
<   if ((Count[DIFFCACO3] > Dcaco3max) && (!Soluble[ETTR])) {
<     Disprob[CACO3] = 0.0;
<   } else if (Count[DIFFCACO3] > (4 * Dcaco3max)) {
<     Disprob[CACO3] = 0.0;
<   } else {
<     Disprob[CACO3] = Disbase[CACO3];
<   }
< 
<   /***
<    *    Adjust solubility of CH based on amount of CH
<    *    currently diffusing
<    *
<    *    Note that CH is always soluble to allow some
<    *    Ostwald ripening of the CH crystals
<    ***/
---
>     if ((Ncsbar + Anhinit + Heminit) == 0) {
>         Cs_acc = 1.0;
>         Ca_acc = 1.0;
>         Dismin_c3a = resfact * 5.0 * DISMIN_C3A_0;
>         Dismin_c4af = resfact * 5.0 * DISMIN_C4AF_0; 
>     } else {
>         Pfract = ((float)Count[POROSITY])/((float)Syspix);
>         Sulf_conc = Sulf_cur * Tfractw05 * Pfractw05 / Totfract / Pfract;
>         if ((double)Sulf_conc < 10.0) {
>             Cs_acc = 1.0;
>             Ca_acc = 1.0;
>             Dismin_c3a = resfact * DISMIN_C3A_0;
>             Dismin_c4af = resfact * DISMIN_C4AF_0;
>         } else if ((double)Sulf_conc < 20.0) {
>             Cs_acc = 1.0 + ((double)Sulf_conc - (10.0)) / 10.0;
>             Ca_acc = 1.0;
>             Dismin_c3a = resfact * DISMIN_C3A_0;
>             Dismin_c4af = resfact * DISMIN_C4AF_0;
>         } else {
>             Cs_acc = 1.0 + (float)log10((double)Sulf_conc);
>             Ca_acc = 1.0;
>             Dismin_c3a = (6.0 - (float)log10((double)Sulf_conc))
>                             * resfact * DISMIN_C3A_0;
>             Dismin_c4af = (6.0 - (float)log10((double)Sulf_conc))
>                             * resfact * DISMIN_C4AF_0;
6451,6455c6070,6077
<   if ((double)Count[DIFFCH] >= Chcrit) {
<     Disprob[CH] = Disbase[CH] * Chcrit / (double)Count[DIFFCH];
<   } else {
<     Disprob[CH] = Disbase[CH];
<   }
---
>             if (Dismin_c3a < resfact * DISMIN_C3A_0) {
>                 Dismin_c3a = resfact * DISMIN_C3A_0;
>             }
>             if (Dismin_c4af < resfact * DISMIN_C4AF_0) {
>                 Dismin_c4af = resfact * DISMIN_C4AF_0;
>             }
>         }
>     }
6457,6467c6079,6081
<   /***
<    *    Adjust solubility of CH for temperature
<    *
<    *    Fit to data provided in
<    *
<    *        H.F.W. Taylor, "Cement Chemistry", 2nd Edition,
<    *        Telford Publishing, London, 1997
<    *
<    *    Scale to a reference temperature of 25 C
<    *    and adjust based on availability of pozzolan
<    ***/
---
>     factCSH = (double)(Count[CSH])/(double)(Cshscale);
>     factPOZZCSH = (double)(Count[POZZCSH])/(double)(Pozzcshscale);
>     factTfract = Tfractw04/(Surffract*Totfract);
6469,6476c6083
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "Count[DIFFCH] = %d, Chcrit = %f, Disbase[CH] = %f\n",
<             Count[DIFFCH], Chcrit, Disbase[CH]);
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "CH dissolution probability changes from %f ",
<             Disprob[CH]);
<   Disprob[CH] *=
<       ((A0_CHSOL - (A1_CHSOL * Temp_cur_b)) / (A0_CHSOL - (A1_CHSOL * 25.0)));
---
>     fact = (factCSH + factPOZZCSH) * factTfract;
6478,6480c6085,6087
<   if ((((double)Count[SFUME]) / ((double)Syspix)) > 0.01) {
<     if (PHfactor[SFUME] * Psfume > 0.0) {
<       Disprob[CH] *= PHfactor[SFUME] * (Psfume / PSFUME);
---
>     dfact = tdisfact * fact * fact * Cs_acc;
>     if (Count[SFUME] >= (0.05 * (double)(Syspix))) {
>         dfact /= LOI_factor;
6482,6484c6089,6103
<   } else if ((((double)Count[AMSIL]) / ((double)Syspix)) > 0.01) {
<     if (PHfactor[AMSIL] * Pamsil > 0.0) {
<       Disprob[CH] *= PHfactor[AMSIL] * (Pamsil / PAMSIL);
---
>     if (Verbose) {
>         printf("\n****Modifying dissolution probabilities : ");
>         printf("\n    tdisfact = %f and Cs_acc = %f",tdisfact,Cs_acc);
>         printf("\n    Psfume = %f",Psfume);
>         printf("\n    fact = %f",fact);
>         printf("\n        Count[CSH] = %d",Count[CSH]);
>         printf(" Tfractw04 = %f",Tfractw04);
>         printf(" Cshscale = %f",Cshscale);
>         printf("\n        Surffract = %f",Surffract);
>         printf(" Totfract = %f\n",Totfract);
>         printf("\n        resfact = %f dfact = %f\n",resfact,dfact);
>         printf("\n        A0_CHSOL = %f",A0_CHSOL);
>         printf(" A1_CHSOL = %f",A1_CHSOL);
>         printf(" Temp_cur_b = %f\n\n",Temp_cur_b);
>         fflush(stdout);
6486d6104
<   }
6488,6489c6106,6108
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "to %f \n", Disprob[CH]);
---
>     
>     Disprob[C3S] = (resfact * DISMIN) + (dfact * Disbase[C3S]);
>     Disprob[C2S] = (resfact * DISMIN2) + (dfact * Disbase[C2S]);
6491,6497c6110,6112
<   /***
<    *    Adjust solubility of ASG and CAS2 phases
<    *    based on pH rise during hydration
<    *
<    *     This is now handled later in this function
<    *     with PHfactors for ASG, CAS2, and AMSIL
<    ***/
---
>     if (Disprob[C3S] > (1.0 * Disbase[C3S])) {
>         Disprob[C3S] = (1.0 * Disbase[C3S]);
>     }
6499,6500c6114,6116
<   Disprob[ASG] = Disbase[ASG];
<   Disprob[CAS2] = Disbase[CAS2];
---
>     if (Disprob[C2S] > (1.0 * Disbase[C2S])) {
>         Disprob[C2S] = (1.0 * Disbase[C2S]);
>     }
6502,6508c6118,6126
<   /***
<    *    Address solubility of C3AH6 (hydrogarnet)
<    *
<    *    If lots of gypsum or reactive ettringite,
<    *    allow C3AH6 to dissolve to generate diffusing
<    *    C3A species
<    ***/
---
>     if ((fpout01 = fopen("SfumeEffect.csv","a")) == NULL) {
>         printf("\nWARNING:  Could not open");
>         printf(" SfumeEffect.csv for writing\n");
>     } else {
>         fprintf(fpout01,"\n%f,%f,%f,%f,%f,%f,%f",
>                 (double)Count[CSH],(double)(Count[CSH]+Count[POZZCSH]),
>                 Cs_acc,Psfume,dfact,Cshscale,Disprob[C3S]);
>         fclose(fpout01);
>     }
6510,6512c6128,6130
<   fact =
<       ((double)Ncsbar + 1.42 * (double)Anhinit + 1.4 * (double)Heminit) * 0.05;
<   if (((Count[GYPSUM] + Count[GYPSUMS]) > (int)(fact)) || (Count[ETTR] > 500)) {
---
>     /***
>     *    THIS NEXT LINE IS FOR TESTING ONLY
>     ***/
6514c6132
<     Soluble[C3AH6] = 1;
---
>     /* Disprob[C3S] = Disbase[C3S]; */
6516,6517d6133
<     /* Identify all new soluble C3AH6 */
<     passone(C3AH6, C3AH6, 2, 0);
6518a6135,6136
>     /***************************************/
> 
6520,6526c6138,6143
<      *    C3AH6 is soluble, so we must determine Disprob for it.
<      *    Base C3AH6 solubility on maximum sulfate in solution
<      *    from gypsum or ettringite available for dissolution
<      *
<      *    The more the sulfate, the higher this solubility
<      *    should be
<      ***/
---
>     *    Also adjust slag and fly ash dissolution rates here.
>     *
>     *    Really slow down initial slag and fly ash dissolutions.
>     *    Ultimately should be linked to pH of pore solution,
>     *    most likely
>     ***/
6528,6530c6145,6150
<     maxsulfate = Count[DIFFGYP];
<     if ((maxsulfate < Count[DIFFETTR]) && (Soluble[ETTR] == 1)) {
<       maxsulfate = Count[DIFFETTR];
---
>     Disprob[SLAG] = Slagreact * ((resfact * DISMINSLAG)
>                                   + dfact * Disbase[SLAG]
>                                 ) / 10.0;
> 
>     if (Disprob[SLAG] > (Slagreact * Disbase[SLAG])) {
>         Disprob[SLAG] = (Slagreact * Disbase[SLAG]);
6533,6536c6153,6155
<     /***
<      *    Adjust C3AH6 solubility based on potential
<      *    gypsum which will dissolve
<      ***/
---
>     if (Disprob[C3S] == Disbase[C3S]){
>         Disprob[SLAG] = Slagreact * Disbase[SLAG];
>     }
6538,6539c6157
<     maxallowed = (int)((double)Gypready * Disprob[GYPSUM] *
<                        (double)Count[POROSITY] / ((double)(Syspix)));
---
>     Disprob[ASG] = (resfact * DISMINASG) + (dfact * Disbase[ASG] / 5.0);
6541,6542c6159,6161
<     if (maxsulfate < maxallowed)
<       maxsulfate = maxallowed;
---
>     if (Disprob[ASG] > (1.0 * Disbase[ASG])) {
>         Disprob[ASG] = (1.0 * Disbase[ASG]);
>     }
6544,6549c6163,6164
<     if (maxsulfate > 0) {
<       Disprob[C3AH6] = Disbase[C3AH6] * (double)maxsulfate / C3ah6crit;
<       if (Disprob[C3AH6] > 0.5)
<         Disprob[C3AH6] = 0.5;
<     } else {
<       Disprob[C3AH6] = Disbase[C3AH6];
---
>     if (Disprob[C3S] == Disbase[C3S]) {
>         Disprob[ASG] = Disbase[ASG];
6552c6167
<   } else {
---
>     Disprob[CAS2] = (resfact * DISMINCAS2) + (dfact * Disbase[CAS2] / 5.0);
6554c6169,6171
<     Soluble[C3AH6] = 0;
---
>     if (Disprob[CAS2] > (1.0 * Disbase[CAS2])) {
>         Disprob[CAS2] = (1.0 * Disbase[CAS2]);
>     }
6556c6173,6175
<   } /* end of soluble C3AH6 test */
---
>     if (Disprob[C3S] == Disbase[C3S]) {
>         Disprob[CAS2] = Disbase[CAS2];
>     }
6558c6177,6180
<   /* See if silicates are soluble yet */
---
>     /***
>     *    Adjust CAS2 solubility
>     *    if too many CAS2 already in solution
>     ***/
6560,6561c6182,6184
<   if ((!Soluble[C3S]) && ((cycle > 1) || (Count[ETTR] > 0) ||
<                           (Count[AFM] > 0) || (Count[ETTRC4AF] > 0))) {
---
>     if (Count[DIFFCAS2] > Dcas2max) {
>         Disprob[CAS2] *= pow((Dcas2max/((double)Count[DIFFCAS2])),2.0);
>     }
6563,6564c6186,6189
<     Soluble[C2S] = 1;
<     Soluble[C3S] = 1;
---
>     /***
>     *    Adjust ASG solubility
>     *    if too many ASG already in solution
>     ***/
6566,6567c6191,6193
<     /* Identify all new soluble silicates */
<     passone(C3S, C2S, 2, 0);
---
>     if (Count[DIFFAS] > Dasmax) {
>         Disprob[ASG] *= pow((Dasmax/((double)Count[DIFFAS])),2.0);
>     }
6569c6195,6196
<   } /* end of soluble silicate test */
---
>     if (Verbose) printf("Silicate probabilities: %f %f\n",
>                          Disprob[C3S],Disprob[C2S]);
6571,6575c6198,6202
<   /***
<    *    Adjust solubility of C3S and C2S with
<    *    CSH concentration for simulation of
<    *    induction period
<    ***/
---
>     /***
>     *    ASSUME that aluminate dissolution controlled by formation
>     *    of impermeable layer proportional to CSH concentration
>     *    if sulfates are present in the system
>     ***/
6577c6204
<   tdisfact = A0_CHSOL - (Temp_cur_b * A1_CHSOL);
---
>     if ((Ncsbar + Heminit + Anhinit) > (1000*Isizemag)) {
6579,6585c6206
<   /***
<    *    Calculation of Cs_acc; acceleration of C3S and C2S
<    *        reaction by CaSO4
<    *
<    *    Calculation of Ca_acc; acceleration of C3A and C4AF
<    *        reaction by CaSO4
<    ***/
---
>         dfact1 = tdisfact * fact * fact * Ca_acc;
6587,6611c6208,6210
<   if ((Ncsbar + Anhinit + Heminit) == 0) {
<     Cs_acc = 1.0;
<     Ca_acc = 1.0;
<     Dismin_c3a = resfact * 5.0 * DISMIN_C3A_0;
<     Dismin_c4af = resfact * 5.0 * DISMIN_C4AF_0;
<   } else {
<     Pfract = ((float)Count[POROSITY]) / ((float)Syspix);
<     Sulf_conc = Sulf_cur * Tfractw05 * Pfractw05 / Totfract / Pfract;
<     if ((double)Sulf_conc < 10.0) {
<       Cs_acc = 1.0;
<       Ca_acc = 1.0;
<       Dismin_c3a = resfact * DISMIN_C3A_0;
<       Dismin_c4af = resfact * DISMIN_C4AF_0;
<     } else if ((double)Sulf_conc < 20.0) {
<       Cs_acc = 1.0 + ((double)Sulf_conc - (10.0)) / 10.0;
<       Ca_acc = 1.0;
<       Dismin_c3a = resfact * DISMIN_C3A_0;
<       Dismin_c4af = resfact * DISMIN_C4AF_0;
<     } else {
<       Cs_acc = 1.0 + (float)log10((double)Sulf_conc);
<       Ca_acc = 1.0;
<       Dismin_c3a =
<           (6.0 - (float)log10((double)Sulf_conc)) * resfact * DISMIN_C3A_0;
<       Dismin_c4af =
<           (6.0 - (float)log10((double)Sulf_conc)) * resfact * DISMIN_C4AF_0;
---
>         Disprob[C3A] = Dismin_c3a + (dfact1 * Disbase[C3A]);
>         Disprob[OC3A] = Dismin_c3a + (dfact1 * Disbase[OC3A]);
>         Disprob[C4AF] = Dismin_c4af + (dfact1 * Disbase[C4AF]);
6613,6620c6212,6214
<       if (Dismin_c3a < resfact * DISMIN_C3A_0) {
<         Dismin_c3a = resfact * DISMIN_C3A_0;
<       }
<       if (Dismin_c4af < resfact * DISMIN_C4AF_0) {
<         Dismin_c4af = resfact * DISMIN_C4AF_0;
<       }
<     }
<   }
---
>         if (Disprob[C3A] > (1.0 * Disbase[C3A])) {
>             Disprob[C3A] = (1.0 * Disbase[C3A]);
>         }
6622,6624c6216,6218
<   factCSH = (double)(Count[CSH]) / (double)(Cshscale);
<   factPOZZCSH = (double)(Count[POZZCSH]) / (double)(Pozzcshscale);
<   factTfract = Tfractw04 / (Surffract * Totfract);
---
>         if (Disprob[OC3A] > (1.0 * Disbase[OC3A])) {
>             Disprob[OC3A] = (1.0 * Disbase[OC3A]);
>         }
6626c6220,6222
<   fact = (factCSH + factPOZZCSH) * factTfract;
---
>         if (Disprob[C4AF] > (1.0 * Disbase[C4AF])) {
>             Disprob[C4AF] = (1.0 * Disbase[C4AF]);
>         }
6628,6647c6224,6227
<   dfact = tdisfact * fact * fact * Cs_acc;
<   if (Count[SFUME] >= (0.05 * (double)(Syspix))) {
<     dfact /= LOI_factor;
<   }
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "\n****Modifying dissolution probabilities : ");
<     fprintf(Logfile, "\n    tdisfact = %f and Cs_acc = %f", tdisfact, Cs_acc);
<     fprintf(Logfile, "\n    Psfume = %f", Psfume);
<     fprintf(Logfile, "\n    fact = %f", fact);
<     fprintf(Logfile, "\n        Count[CSH] = %d", Count[CSH]);
<     fprintf(Logfile, " Tfractw04 = %f", Tfractw04);
<     fprintf(Logfile, " Cshscale = %f", Cshscale);
<     fprintf(Logfile, "\n        Surffract = %f", Surffract);
<     fprintf(Logfile, " Totfract = %f\n", Totfract);
<     fprintf(Logfile, "\n        resfact = %f dfact = %f\n", resfact, dfact);
<     fprintf(Logfile, "\n        A0_CHSOL = %f", A0_CHSOL);
<     fprintf(Logfile, " A1_CHSOL = %f", A1_CHSOL);
<     fprintf(Logfile, " Temp_cur_b = %f\n\n", Temp_cur_b);
<     fflush(Logfile);
<   }
---
>         /***
>         *    Location to add in dissolution reduction in
>         *    calcium sulfate phases if needed
>         ***/
6649,6650c6229,6230
<   Disprob[C3S] = (resfact * DISMIN) + (dfact * Disbase[C3S]);
<   Disprob[C2S] = (resfact * DISMIN2) + (dfact * Disbase[C2S]);
---
>         Disprob[GYPSUM] = (Disbase[GYPSUM] / 15.0)
>                             + (dfact1 * Disbase[GYPSUM]);
6652,6654c6232,6234
<   if (Disprob[C3S] > (1.0 * Disbase[C3S])) {
<     Disprob[C3S] = (1.0 * Disbase[C3S]);
<   }
---
>         if (Disprob[GYPSUM] > Disbase[GYPSUM]) {
>             Disprob[GYPSUM] = Disbase[GYPSUM];
>         }
6656,6658c6236,6237
<   if (Disprob[C2S] > (1.0 * Disbase[C2S])) {
<     Disprob[C2S] = (1.0 * Disbase[C2S]);
<   }
---
>         Disprob[GYPSUMS] = (Disbase[GYPSUMS] / 15.0)
>                             + (dfact1 * Disbase[GYPSUMS]);
6660,6670c6239,6241
<   if ((fpout01 = fopen("SfumeEffect.csv", "a")) == NULL) {
<     if (Verbose_flag > 0) {
<       fprintf(Logfile, "\nWARNING:  Could not open");
<       fprintf(Logfile, " SfumeEffect.csv for writing\n");
<     }
<   } else {
<     fprintf(fpout01, "\n%f,%f,%f,%f,%f,%f,%f", (double)Count[CSH],
<             (double)(Count[CSH] + Count[POZZCSH]), Cs_acc, Psfume, dfact,
<             Cshscale, Disprob[C3S]);
<     fclose(fpout01);
<   }
---
>         if (Disprob[GYPSUMS] > Disbase[GYPSUMS]) {
>             Disprob[GYPSUMS] = Disbase[GYPSUMS];
>         }
6672,6674c6243,6246
<   /***
<    *    THIS NEXT LINE IS FOR TESTING ONLY
<    ***/
---
>         /***
>         *    Adjust gypsum solubility if too many diffusing
>         *    gypsums already in solution
>         ***/
6676c6248,6250
<   /* Disprob[C3S] = Disbase[C3S]; */
---
>         if (Count[DIFFGYP] > Dgypmax) {
>             Disprob[GYPSUM] = Disprob[GYPSUMS] = 0.0;
>         }
6678c6252,6253
<   /***************************************/
---
>         Disprob[HEMIHYD] = (Disbase[HEMIHYD] / 15.0)
>                             + (dfact1 * Disbase[HEMIHYD]);
6680,6686c6255,6257
<   /***
<    *    Also adjust slag and fly ash dissolution rates here.
<    *
<    *    Really slow down initial slag and fly ash dissolutions.
<    *    Ultimately should be linked to pH of pore solution,
<    *    most likely
<    ***/
---
>         if (Disprob[HEMIHYD] > Disbase[HEMIHYD]) {
>             Disprob[HEMIHYD] = Disbase[HEMIHYD];
>         }
6688,6689c6259,6260
<   Disprob[SLAG] =
<       Slagreact * ((resfact * DISMINSLAG) + dfact * Disbase[SLAG]) / 10.0;
---
>         Disprob[ANHYDRITE] = (Disbase[ANHYDRITE] / 15.0)
>                             +(dfact1 * Disbase[ANHYDRITE]);
6691,6693c6262,6264
<   if (Disprob[SLAG] > (Slagreact * Disbase[SLAG])) {
<     Disprob[SLAG] = (Slagreact * Disbase[SLAG]);
<   }
---
>         if (Disprob[ANHYDRITE] > Disbase[ANHYDRITE]) {
>             Disprob[ANHYDRITE] = Disbase[ANHYDRITE];
>         }
6695,6697c6266
<   if (Disprob[C3S] == Disbase[C3S]) {
<     Disprob[SLAG] = Slagreact * Disbase[SLAG];
<   }
---
>     } else {
6699c6268,6271
<   Disprob[ASG] = (resfact * DISMINASG) + (dfact * Disbase[ASG] / 5.0);
---
>         /***
>         *    Cause flash set by increasing dissolution rates
>         *    of C3A and C4AF each by a factor of four
>         ***/
6701,6703c6273,6279
<   if (Disprob[ASG] > (1.0 * Disbase[ASG])) {
<     Disprob[ASG] = (1.0 * Disbase[ASG]);
<   }
---
>         Disprob[C3A] = 4.0 * Disbase[C3A];
>         Disprob[OC3A] = 4.0 * Disbase[OC3A];
>         Disprob[C4AF] = 4.0 * Disbase[C4AF];
>         Disprob[GYPSUM] = Disbase[GYPSUM];
>         Disprob[HEMIHYD] = Disbase[HEMIHYD];
>         Disprob[ANHYDRITE] = Disbase[ANHYDRITE];
>     }
6705,6707c6281,6284
<   if (Disprob[C3S] == Disbase[C3S]) {
<     Disprob[ASG] = Disbase[ASG];
<   }
---
>     /***
>     *    Reduce dissolution probabilities based on
>     *    saturation of system
>     ***/
6709c6286
<   Disprob[CAS2] = (resfact * DISMINCAS2) + (dfact * Disbase[CAS2] / 5.0);
---
>     /* fact is 22% of the system volume */
6711,6713c6288
<   if (Disprob[CAS2] > (1.0 * Disbase[CAS2])) {
<     Disprob[CAS2] = (1.0 * Disbase[CAS2]);
<   }
---
>     fact = 0.22 * (double)Syspix;
6715,6717c6290
<   if (Disprob[C3S] == Disbase[C3S]) {
<     Disprob[CAS2] = Disbase[CAS2];
<   }
---
>     if ((Count[EMPTYP] > 0) && ((Count[POROSITY] + Count[EMPTYP]) < fact)) {
6719,6722c6292
<   /***
<    *    Adjust CAS2 solubility
<    *    if too many CAS2 already in solution
<    ***/
---
>         if (Countpore == 0) Countpore = Count[EMPTYP];
6724,6726c6294,6297
<   if (Count[DIFFCAS2] > Dcas2max) {
<     Disprob[CAS2] *= pow((Dcas2max / ((double)Count[DIFFCAS2])), 2.0);
<   }
---
>         Saturation = (double)(Count[POROSITY])
>                         / (double)(Count[POROSITY]
>                                     + Count[EMPTYP]
>                                     - Countpore);
6728,6731c6299,6311
<   /***
<    *    Adjust ASG solubility
<    *    if too many ASG already in solution
<    ***/
---
>         /***
>         *    Roughly according to results of Jensen, powers for
>         *    RH sensitivity are:
>         *        C3S --> -19
>         *        C2S --> -29
>         *        C3A --> -6
>         *        OC3A --> -6, but this is just a guess based on C3A
>         *        C4AF--> -6
>         *
>         *    Adjust fly ash silicates (ASG and CAS2) and
>         *    pozzolanic reactivity by same factor as
>         *    C3S (also CH)
>         ***/
6733,6735c6313,6324
<   if (Count[DIFFAS] > Dasmax) {
<     Disprob[ASG] *= pow((Dasmax / ((double)Count[DIFFAS])), 2.0);
<   }
---
>         satsquared = Saturation * Saturation;
>         if (Verbose) printf("\nsaturation = %f\n",Saturation);
>         Disprob[C3S] *= satsquared;
>         Disprob[C3S] *= satsquared;
>         Disprob[C3S] *= satsquared;
>         Disprob[C3S] *= satsquared;
>         Disprob[C3S] *= satsquared;
>         Disprob[C3S] *= satsquared;
>         Disprob[C3S] *= satsquared;
>         Disprob[C3S] *= satsquared;
>         Disprob[C3S] *= satsquared;
>         Disprob[C3S] *= (Saturation);
6737,6739c6326,6335
<   if (Verbose_flag > 1)
<     fprintf(Logfile, "Silicate probabilities: %f %f\n", Disprob[C3S],
<             Disprob[C2S]);
---
>         Disprob[SLAG] *= satsquared;
>         Disprob[SLAG] *= satsquared;
>         Disprob[SLAG] *= satsquared;
>         Disprob[SLAG] *= satsquared;
>         Disprob[SLAG] *= satsquared;
>         Disprob[SLAG] *= satsquared;
>         Disprob[SLAG] *= satsquared;
>         Disprob[SLAG] *= satsquared;
>         Disprob[SLAG] *= satsquared;
>         Disprob[SLAG] *= (Saturation);
6741,6745c6337,6346
<   /***
<    *    ASSUME that aluminate dissolution controlled by formation
<    *    of impermeable layer proportional to CSH concentration
<    *    if sulfates are present in the system
<    ***/
---
>         Disprob[CH] *= satsquared;
>         Disprob[CH] *= satsquared;
>         Disprob[CH] *= satsquared;
>         Disprob[CH] *= satsquared;
>         Disprob[CH] *= satsquared;
>         Disprob[CH] *= satsquared;
>         Disprob[CH] *= satsquared;
>         Disprob[CH] *= satsquared;
>         Disprob[CH] *= satsquared;
>         Disprob[CH] *= (Saturation);
6747c6348,6357
<   if ((Ncsbar + Heminit + Anhinit) > (1000 * Isizemag)) {
---
>         /***
>         *    Removed dependence on RH of flyash silicate
>         *    dissolution    probabilities and pozzolanic
>         *    reaction rate on RH,to better fit recent
>         *    experimental data on flyash consumption
>         *    under sealed conditions    (Garboczi and Feng,
>         *    unpublished).
>         *
>         *    April 18 2003
>         ***/
6749c6359,6369
<     dfact1 = tdisfact * fact * fact * Ca_acc;
---
>         /*
>         Disprob[ASG] *= satsquared;
>         Disprob[ASG] *= satsquared;
>         Disprob[ASG] *= satsquared;
>         Disprob[ASG] *= satsquared;
>         Disprob[ASG] *= satsquared;
>         Disprob[ASG] *= satsquared;
>         Disprob[ASG] *= satsquared;
>         Disprob[ASG] *= satsquared;
>         Disprob[ASG] *= satsquared;
>         Disprob[ASG] *= (Saturation);
6751,6753c6371,6380
<     Disprob[C3A] = Dismin_c3a + (dfact1 * Disbase[C3A]);
<     Disprob[OC3A] = Dismin_c3a + (dfact1 * Disbase[OC3A]);
<     Disprob[C4AF] = Dismin_c4af + (dfact1 * Disbase[C4AF]);
---
>         Disprob[CAS2] *= satsquared;
>         Disprob[CAS2] *= satsquared;
>         Disprob[CAS2] *= satsquared;
>         Disprob[CAS2] *= satsquared;
>         Disprob[CAS2] *= satsquared;
>         Disprob[CAS2] *= satsquared;
>         Disprob[CAS2] *= satsquared;
>         Disprob[CAS2] *= satsquared;
>         Disprob[CAS2] *= satsquared;
>         Disprob[CAS2] *= (Saturation);
6755,6757c6382,6392
<     if (Disprob[C3A] > (1.0 * Disbase[C3A])) {
<       Disprob[C3A] = (1.0 * Disbase[C3A]);
<     }
---
>         Ppozz *= satsquared;
>         Ppozz *= satsquared;
>         Ppozz *= satsquared;
>         Ppozz *= satsquared;
>         Ppozz *= satsquared;
>         Ppozz *= satsquared;
>         Ppozz *= satsquared;
>         Ppozz *= satsquared;
>         Ppozz *= satsquared;
>         Ppozz *= (Saturation);
>         */
6759,6761c6394,6408
<     if (Disprob[OC3A] > (1.0 * Disbase[OC3A])) {
<       Disprob[OC3A] = (1.0 * Disbase[OC3A]);
<     }
---
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= satsquared;
>         Disprob[C2S] *= (Saturation);
6763,6765c6410,6412
<     if (Disprob[C4AF] > (1.0 * Disbase[C4AF])) {
<       Disprob[C4AF] = (1.0 * Disbase[C4AF]);
<     }
---
>         Disprob[C3A] *= satsquared;
>         Disprob[C3A] *= satsquared;
>         Disprob[C3A] *= satsquared;
6767,6770c6414,6416
<     /***
<      *    Location to add in dissolution reduction in
<      *    calcium sulfate phases if needed
<      ***/
---
>         Disprob[OC3A] *= satsquared;
>         Disprob[OC3A] *= satsquared;
>         Disprob[OC3A] *= satsquared;
6772c6418,6420
<     Disprob[GYPSUM] = (Disbase[GYPSUM] / 15.0) + (dfact1 * Disbase[GYPSUM]);
---
>         Disprob[C4AF] *= satsquared;
>         Disprob[C4AF] *= satsquared;
>         Disprob[C4AF] *= satsquared;
6774,6776c6422
<     if (Disprob[GYPSUM] > Disbase[GYPSUM]) {
<       Disprob[GYPSUM] = Disbase[GYPSUM];
<     }
---
>     }    /* Done reducing dissolutions based on saturation */
6778,6781c6424,6429
<     Disprob[GYPSUMS] = (Disbase[GYPSUMS] / 15.0) + (dfact1 * Disbase[GYPSUMS]);
< 
<     if (Disprob[GYPSUMS] > Disbase[GYPSUMS]) {
<       Disprob[GYPSUMS] = Disbase[GYPSUMS];
---
>     if (Verbose) {
>         printf("Silicate and aluminate probabilities: ");
>         printf("%f %f ",Disprob[C3S],Disprob[C2S]);
>         printf("%f %f %f %f %f\n",Disprob[C3A],Disprob[OC3A],Disprob[C4AF],Disprob[GYPSUM],Disprob[HEMIHYD]);
>         printf("Cs_acc is %f and Ca_acc is %f Sulf_cur is %d Sulf_conc is %f\n",Cs_acc,Ca_acc,Sulf_cur,Sulf_conc);
>         printf("Pfract is %f and Totfract is %f and Tfractw05 is %f and Pfractw05 is %f\n",Pfract,Totfract,Tfractw05,Pfractw05);
6785,6787c6433,6457
<      *    Adjust gypsum solubility if too many diffusing
<      *    gypsums already in solution
<      ***/
---
>     *    PASS TWO:  Perform the dissolution of species
>     *
>     *    Determine the pH factor to use.  Only use pH
>     *    influence if user asked for it AND hydration
>     *    has proceeded beyond the induction period
>     *
>     *    Set possibility of topochemical conversion of silicates
>     *    to CSH if pH effect is active, and also set the proximity
>     *    within which dissolved silicates are placed relative to the
>     *    dissolution source, to simulate the higher-density CSH
>     *    that is thought to form in the presence of alkalies
>     *    (see Juenger and Jennings, ACI Materials Journal,
>     *    Vol. 98, No. 3, pp. 251-255 (2001).
>     *
>     *    pH influences the proximity of location of
>     *    dissolved silicates to the dissolution source,
>     *    to simulate the higher-density CSH reported in
>     *    the presence of alkalies.  Assume this happens
>     *    from the very beginning of hydration.
>     *
>     *    pH also "turns on" the possibility of direct
>     *    topochemical conversion of anhydrous silicates
>     *    to CSH.  Assume this happens from the very beginning
>     *    of hydration
>     ***/
6789,6790c6459,6471
<     if (Count[DIFFGYP] > Dgypmax) {
<       Disprob[GYPSUM] = Disprob[GYPSUMS] = 0.0;
---
>     Distloccsh = DISTLOCCSH;
>     Pdirectcsh = 0.0;
>     if (PHactive == 1) {
>         if (PH_cur > 13.75) {
>             Distloccsh = 0.5 * DISTLOCCSH;
>             Pdirectcsh = 0.001;
>         } else if (PH_cur > 13.25) {
>             Distloccsh = 0.75 * DISTLOCCSH;
>             Pdirectcsh = 0.0005;
>         } else if (PH_cur > 13.00) {
>             Distloccsh = 0.85 * DISTLOCCSH;
>             Pdirectcsh = 0.00025;
>         }
6793c6474,6480
<     Disprob[HEMIHYD] = (Disbase[HEMIHYD] / 15.0) + (dfact1 * Disbase[HEMIHYD]);
---
>     if ((PHactive == 1) && (Count[CSH] >
>                             ( (Cshscale * (Surffract*Totfract)
>                                 * (Surffract*Totfract)
>                                 / (Tfractw04)
>                                 / (Tfractw04) )
>                                 / 8.0
>                             ) )) {
6795,6797c6482,6484
<     if (Disprob[HEMIHYD] > Disbase[HEMIHYD]) {
<       Disprob[HEMIHYD] = Disbase[HEMIHYD];
<     }
---
>         /***
>         *    Calculate pH factor for each phase
>         ***/
6799,6800c6486
<     Disprob[ANHYDRITE] =
<         (Disbase[ANHYDRITE] / 15.0) + (dfact1 * Disbase[ANHYDRITE]);
---
>         for (k = C3S; k <= NSPHASES; k++) {
6802,6804c6488,6493
<     if (Disprob[ANHYDRITE] > Disbase[ANHYDRITE]) {
<       Disprob[ANHYDRITE] = Disbase[ANHYDRITE];
<     }
---
>             if ((k != SFUME) && (k != AMSIL) && (k != ASG) && (k != CAS2)) {
>             
>                 PHfactor[k] = PHcoeff[k][2] * pow(PH_cur,2.0);
>                 PHfactor[k] += PHcoeff[k][1] * PH_cur;
>                 PHfactor[k] += PHcoeff[k][0];
>                 PHfactor[k] -= (PHsulfcoeff[k] * Concsulfate);
6806c6495
<   } else {
---
>             } else {
6808,6811c6497,6498
<     /***
<      *    Cause flash set by increasing dissolution rates
<      *    of C3A and C4AF each by a factor of four
<      ***/
---
>                 x = 0;
>                 y = 1;
6813,6819c6500,6502
<     Disprob[C3A] = 4.0 * Disbase[C3A];
<     Disprob[OC3A] = 4.0 * Disbase[OC3A];
<     Disprob[C4AF] = 4.0 * Disbase[C4AF];
<     Disprob[GYPSUM] = Disbase[GYPSUM];
<     Disprob[HEMIHYD] = Disbase[HEMIHYD];
<     Disprob[ANHYDRITE] = Disbase[ANHYDRITE];
<   }
---
>                 xv1 = FitpH[k][x][0];
>                 yv1 = FitpH[k][y][0];
>                 yv3 = FitpH[k][y][2];
6821,6824c6504,6507
<   /***
<    *    Reduce dissolution probabilities based on
<    *    saturation of system
<    ***/
---
>                 PHfactor[k] = PHcoeff[k][2] * pow(ohadj,2.0);
>                 PHfactor[k] += PHcoeff[k][1] * ohadj;
>                 PHfactor[k] += PHcoeff[k][0];
>                 PHfactor[k] -= (PHsulfcoeff[k] * Concsulfate);
6826c6509,6510
<   /* fact is 22% of the system volume */
---
>                 if (PHfactor[k] < yv1 || ohadj < xv1) PHfactor[k] = yv1;
>                 if (PHfactor[k] > yv3) PHfactor[k] = yv3;
6828c6512,6519
<   fact = 0.22 * (double)Syspix;
---
>                 /***
>                 *    Just for these fly ash phases, we adjust the
>                 *    PHfactor by the relative w/c ratio once again,
>                 *    to agree with experimental data, obtained by
>                 *    Feng and Garboczi, showing that the extent of
>                 *    reaction as a function of doh is basically
>                 *    independent of w/c
>                 ***/
6830c6521
<   if ((Count[EMPTYP] > 0) && ((Count[POROSITY] + Count[EMPTYP]) < fact)) {
---
>                 PHfactor[k] *= pow((0.50313/W_to_c),3.0);
6832,6833c6523,6524
<     if (Countpore == 0)
<       Countpore = Count[EMPTYP];
---
>             }
>         }
6835,6836c6526,6527
<     Saturation = (double)(Count[POROSITY]) /
<                  (double)(Count[POROSITY] + Count[EMPTYP] - Countpore);
---
>         /* 2/02:  PHfactor = 0.30*(((14.1-PH_cur)/0.3)-1.0); */
>         /* 3/02:  PHfactor = 0.60*(((14.1-PH_cur)/0.5)-1.0); */
6838,6850c6529,6533
<     /***
<      *    Roughly according to results of Jensen, powers for
<      *    RH sensitivity are:
<      *        C3S --> -19
<      *        C2S --> -29
<      *        C3A --> -6
<      *        OC3A --> -6, but this is just a guess based on C3A
<      *        C4AF--> -6
<      *
<      *    Adjust fly ash silicates (ASG and CAS2) and
<      *    pozzolanic reactivity by same factor as
<      *    C3S (also CH)
<      ***/
---
>         /***
>         *    Molar volume of CSH depends on pH according to
>         *    observations compiled in Jawed and Skalny,
>         *    Cem. Concr. Res., Vol. 8 pp. 37-52 (1978).
>         ***/
6852,6864c6535,6538
<     satsquared = Saturation * Saturation;
<     if (Verbose_flag > 1)
<       fprintf(Logfile, "\nsaturation = %f\n", Saturation);
<     Disprob[C3S] *= satsquared;
<     Disprob[C3S] *= satsquared;
<     Disprob[C3S] *= satsquared;
<     Disprob[C3S] *= satsquared;
<     Disprob[C3S] *= satsquared;
<     Disprob[C3S] *= satsquared;
<     Disprob[C3S] *= satsquared;
<     Disprob[C3S] *= satsquared;
<     Disprob[C3S] *= satsquared;
<     Disprob[C3S] *= (Saturation);
---
>         Molarvcsh[Icyc] += Molarvcshcoeff_pH * ( PHfactor[C3S] +
>                             (PHsulfcoeff[C3S] * Concsulfate) );
>         Watercsh[Icyc] += Watercshcoeff_pH * ( PHfactor[C3S] +
>                             (PHsulfcoeff[C3S] * Concsulfate) );
6866,6875c6540
<     Disprob[SLAG] *= satsquared;
<     Disprob[SLAG] *= satsquared;
<     Disprob[SLAG] *= satsquared;
<     Disprob[SLAG] *= satsquared;
<     Disprob[SLAG] *= satsquared;
<     Disprob[SLAG] *= satsquared;
<     Disprob[SLAG] *= satsquared;
<     Disprob[SLAG] *= satsquared;
<     Disprob[SLAG] *= satsquared;
<     Disprob[SLAG] *= (Saturation);
---
>     }
6877,6886c6542
<     Disprob[CH] *= satsquared;
<     Disprob[CH] *= satsquared;
<     Disprob[CH] *= satsquared;
<     Disprob[CH] *= satsquared;
<     Disprob[CH] *= satsquared;
<     Disprob[CH] *= satsquared;
<     Disprob[CH] *= satsquared;
<     Disprob[CH] *= satsquared;
<     Disprob[CH] *= satsquared;
<     Disprob[CH] *= (Saturation);
---
>     nhgd = 0;
6888,6897c6544
<     /***
<      *    Removed dependence on RH of flyash silicate
<      *    dissolution    probabilities and pozzolanic
<      *    reaction rate on RH,to better fit recent
<      *    experimental data on flyash consumption
<      *    under sealed conditions    (Garboczi and Feng,
<      *    unpublished).
<      *
<      *    April 18 2003
<      ***/
---
>     /* Update molar volume ratios for CSH formation */
6899,6909c6546,6547
<     /*
<     Disprob[ASG] *= satsquared;
<     Disprob[ASG] *= satsquared;
<     Disprob[ASG] *= satsquared;
<     Disprob[ASG] *= satsquared;
<     Disprob[ASG] *= satsquared;
<     Disprob[ASG] *= satsquared;
<     Disprob[ASG] *= satsquared;
<     Disprob[ASG] *= satsquared;
<     Disprob[ASG] *= satsquared;
<     Disprob[ASG] *= (Saturation);
---
>     pc3scsh = (Molarvcsh[Cyccnt] / Molarv[C3S]) - 1.0;
>     pc2scsh = (Molarvcsh[Cyccnt] / Molarv[C2S]) - 1.0;
6911,6920c6549
<     Disprob[CAS2] *= satsquared;
<     Disprob[CAS2] *= satsquared;
<     Disprob[CAS2] *= satsquared;
<     Disprob[CAS2] *= satsquared;
<     Disprob[CAS2] *= satsquared;
<     Disprob[CAS2] *= satsquared;
<     Disprob[CAS2] *= satsquared;
<     Disprob[CAS2] *= satsquared;
<     Disprob[CAS2] *= satsquared;
<     Disprob[CAS2] *= (Saturation);
---
>     /* Once again, scan all pixels in microstructure */
6922,6932c6551
<     Ppozz *= satsquared;
<     Ppozz *= satsquared;
<     Ppozz *= satsquared;
<     Ppozz *= satsquared;
<     Ppozz *= satsquared;
<     Ppozz *= satsquared;
<     Ppozz *= satsquared;
<     Ppozz *= satsquared;
<     Ppozz *= satsquared;
<     Ppozz *= (Saturation);
<     */
---
>     Slagemptyp = 0;
6934,6948c6553,6562
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= satsquared;
<     Disprob[C2S] *= (Saturation);
---
>     /*
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (iii = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
>     }
6950,6952c6564,6566
<     Disprob[C3A] *= satsquared;
<     Disprob[C3A] *= satsquared;
<     Disprob[C3A] *= satsquared;
---
>     if (Verbose) printf("\nEntering Main dissolve loop, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>     fflush(stdout);
>     */
6954,6956c6568,6570
<     Disprob[OC3A] *= satsquared;
<     Disprob[OC3A] *= satsquared;
<     Disprob[OC3A] *= satsquared;
---
>     for (zl = 0; zl < Zsyssize; zl++) {
>         for (yl = 0; yl < Ysyssize; yl++) {
>             for (xl = 0; xl < Xsyssize; xl++) {
6958,6960d6571
<     Disprob[C4AF] *= satsquared;
<     Disprob[C4AF] *= satsquared;
<     Disprob[C4AF] *= satsquared;
6962c6573,6580
<   } /* Done reducing dissolutions based on saturation */
---
>                 /***
>                 *    Work only with pixels that are marked for
>                 *     dissolution.  Convert them back to their
>                 *     original ID before doing anything else
>                 *
>                 *     Note that K2SO4 and NA2SO4 are handled
>                 *     differently below this loop (7 June 2004)
>                 ***/
6964,6976c6582,6584
<   if (Verbose_flag > 2) {
<     fprintf(Logfile, "Silicate and aluminate probabilities: ");
<     fprintf(Logfile, "%f %f ", Disprob[C3S], Disprob[C2S]);
<     fprintf(Logfile, "%f %f %f %f %f\n", Disprob[C3A], Disprob[OC3A],
<             Disprob[C4AF], Disprob[GYPSUM], Disprob[HEMIHYD]);
<     fprintf(Logfile,
<             "Cs_acc is %f and Ca_acc is %f Sulf_cur is %d Sulf_conc is %f\n",
<             Cs_acc, Ca_acc, Sulf_cur, Sulf_conc);
<     fprintf(Logfile,
<             "Pfract is %f and Totfract is %f and Tfractw05 is %f and Pfractw05 "
<             "is %f\n",
<             Pfract, Totfract, Tfractw05, Pfractw05);
<   }
---
>                 if (Mic[xl][yl][zl] > OFFSET
>                     && (Mic[xl][yl][zl] - (OFFSET)) != (K2SO4)
>                     && (Mic[xl][yl][zl] - (OFFSET)) != (NA2SO4)) {
6978,7003c6586,6587
<   /***
<    *    PASS TWO:  Perform the dissolution of species
<    *
<    *    Determine the pH factor to use.  Only use pH
<    *    influence if user asked for it AND hydration
<    *    has proceeded beyond the induction period
<    *
<    *    Set possibility of topochemical conversion of silicates
<    *    to CSH if pH effect is active, and also set the proximity
<    *    within which dissolved silicates are placed relative to the
<    *    dissolution source, to simulate the higher-density CSH
<    *    that is thought to form in the presence of alkalies
<    *    (see Juenger and Jennings, ACI Materials Journal,
<    *    Vol. 98, No. 3, pp. 251-255 (2001).
<    *
<    *    pH influences the proximity of location of
<    *    dissolved silicates to the dissolution source,
<    *    to simulate the higher-density CSH reported in
<    *    the presence of alkalies.  Assume this happens
<    *    from the very beginning of hydration.
<    *
<    *    pH also "turns on" the possibility of direct
<    *    topochemical conversion of anhydrous silicates
<    *    to CSH.  Assume this happens from the very beginning
<    *    of hydration
<    ***/
---
>                     phid = (int)Mic[xl][yl][zl] - (OFFSET);
>                     if (phid == GYPSUM) gct++;
7005,7018c6589
<   Distloccsh = DISTLOCCSH;
<   Pdirectcsh = 0.0;
<   if (PHactive == 1) {
<     if (PH_cur > 13.75) {
<       Distloccsh = 0.5 * DISTLOCCSH;
<       Pdirectcsh = 0.001;
<     } else if (PH_cur > 13.25) {
<       Distloccsh = 0.75 * DISTLOCCSH;
<       Pdirectcsh = 0.0005;
<     } else if (PH_cur > 13.00) {
<       Distloccsh = 0.85 * DISTLOCCSH;
<       Pdirectcsh = 0.00025;
<     }
<   }
---
>                     /* Attempt a one-step random walk to dissolve */
7020,7023c6591,6594
<   if ((PHactive == 1) &&
<       (Count[CSH] > ((Cshscale * (Surffract * Totfract) *
<                       (Surffract * Totfract) / (Tfractw04) / (Tfractw04)) /
<                      8.0))) {
---
>                     plnew = (int)((float)NEIGHBORS * ran1(Seed));
>                     if ((plnew < 0) || (plnew >= NEIGHBORS)) {
>                         plnew = NEIGHBORS - 1;
>                     }
7025,7027c6596,6602
<     /***
<      *    Calculate pH factor for each phase
<      ***/
---
>                     xc = xl + Xoff[plnew];
>                     yc = yl + Yoff[plnew];
>                     zc = zl + Zoff[plnew];
>                 
>                     xc += checkbc(xc,Xsyssize);
>                     yc += checkbc(yc,Ysyssize);
>                     zc += checkbc(zc,Zsyssize);
7029c6604,6606
<     for (k = C3S; k <= NSPHASES; k++) {
---
>                     pixdeact = 0;
>                     if ((Xoff[plnew] == (-1))
>                         && (Deactivated[xl][yl][zl]%Primevalues[1] == 0)) {
7031c6608,6609
<       if ((k != SFUME) && (k != AMSIL) && (k != ASG) && (k != CAS2)) {
---
>                         pixdeact = 1;
>                     }
7033,7036c6611,6612
<         PHfactor[k] = PHcoeff[k][2] * pow(PH_cur, 2.0);
<         PHfactor[k] += PHcoeff[k][1] * PH_cur;
<         PHfactor[k] += PHcoeff[k][0];
<         PHfactor[k] -= (PHsulfcoeff[k] * Concsulfate);
---
>                     if ((!pixdeact) && (Xoff[plnew] == 1)
>                         && (Deactivated[xl][yl][zl]%Primevalues[0] == 0)) {
7038c6614,6615
<       } else {
---
>                         pixdeact = 1;
>                     }
7040,7041c6617,6618
<         x = 0;
<         y = 1;
---
>                     if ((!pixdeact) && (Yoff[plnew] == (-1))
>                         && (Deactivated[xl][yl][zl]%Primevalues[3] == 0)) {
7043,7045c6620,6621
<         xv1 = FitpH[k][x][0];
<         yv1 = FitpH[k][y][0];
<         yv3 = FitpH[k][y][2];
---
>                         pixdeact = 1;
>                     }
7047,7050c6623,6624
<         PHfactor[k] = PHcoeff[k][2] * pow(ohadj, 2.0);
<         PHfactor[k] += PHcoeff[k][1] * ohadj;
<         PHfactor[k] += PHcoeff[k][0];
<         PHfactor[k] -= (PHsulfcoeff[k] * Concsulfate);
---
>                     if ((!pixdeact) && (Yoff[plnew] == 1)
>                         && (Deactivated[xl][yl][zl]%Primevalues[2] == 0)) {
7052,7055c6626,6627
<         if (PHfactor[k] < yv1 || ohadj < xv1)
<           PHfactor[k] = yv1;
<         if (PHfactor[k] > yv3)
<           PHfactor[k] = yv3;
---
>                         pixdeact = 1;
>                     }
7057,7064c6629,6630
<         /***
<          *    Just for these fly ash phases, we adjust the
<          *    PHfactor by the relative w/c ratio once again,
<          *    to agree with experimental data, obtained by
<          *    Feng and Garboczi, showing that the extent of
<          *    reaction as a function of doh is basically
<          *    independent of w/c
<          ***/
---
>                     if ((!pixdeact) && (Zoff[plnew] == (-1))
>                         && (Deactivated[xl][yl][zl]%Primevalues[5] == 0)) {
7066,7068c6632,6633
<         PHfactor[k] *= pow((0.50313 / W_to_c), 3.0);
<       }
<     }
---
>                         pixdeact = 1;
>                     }
7070,7071c6635,6636
<     /* 2/02:  PHfactor = 0.30*(((14.1-PH_cur)/0.3)-1.0); */
<     /* 3/02:  PHfactor = 0.60*(((14.1-PH_cur)/0.5)-1.0); */
---
>                     if ((!pixdeact) && (Zoff[plnew] == 1)
>                         && (Deactivated[xl][yl][zl]%Primevalues[4] == 0)) {
7073,7077c6638,6641
<     /***
<      *    Molar volume of CSH depends on pH according to
<      *    observations compiled in Jawed and Skalny,
<      *    Cem. Concr. Res., Vol. 8 pp. 37-52 (1978).
<      ***/
---
>                         pixdeact = 1;
>                     }
>                        
>                     /* Generate probability for dissolution */
7079,7083c6643
<     Molarvcsh[Icyc] +=
<         Molarvcshcoeff_pH * (PHfactor[C3S] + (PHsulfcoeff[C3S] * Concsulfate));
<     Watercsh[Icyc] +=
<         Watercshcoeff_pH * (PHfactor[C3S] + (PHsulfcoeff[C3S] * Concsulfate));
<   }
---
>                     pdis = ran1(Seed);
7085c6645,6659
<   nhgd = 0;
---
>                     /***
>                     *    Bias dissolution for one pixel particles as 
>                     *    indicated by a pixel value of zero in the 
>                     *    particle microstructure image
>                     *
>                     *    We do allow dissolution of unhydrated material
>                     *    into water in saturated crack pores formed during
>                     *    the hydration process (24 May 2004)
>                     ***/
>                 
>                     if ( ((pdis <= (PHfactor[phid] * Disprob[phid]))
>                             || ((pdis <= (Onepixelbias[phid] * PHfactor[phid] * Disprob[phid]))
>                                     && (Micpart[xl][yl][zl] == 0) ))
>                         && (Mic[xc][yc][zc] == POROSITY || Mic[xc][yc][zc] == CRACKP)
>                         && (!pixdeact) ) {
7087,7094c6661,6707
<   /* Update molar volume ratios for CSH formation */
< 
<   pc3scsh = (Molarvcsh[Cyccnt] / Molarv[C3S]) - 1.0;
<   pc2scsh = (Molarvcsh[Cyccnt] / Molarv[C2S]) - 1.0;
< 
<   /* Once again, scan all pixels in microstructure */
< 
<   Slagemptyp = 0;
---
>                         /***
>                         *    Special case of possible topochemical
>                         *    transformation of C3S to CSH without
>                         *    dissolution (NOT YET ENABLED, 24 April 2003)
>                         ***/
>                         
>                         /*
>                         if (Verbose) {
>                             if (phid == C3S) {
>                                 printf("\nDissolving C3S: pdis = %f\tdisprob = ",pdis);
>                                 if (Micpart[xl][yl][zl] == 0) {
>                                     printf("%f",Onepixelbias[phid] * PHfactor[phid] * Disprob[phid]);
>                                 } else {
>                                     printf("%f",PHfactor[phid] * Disprob[phid]);
>                                 }
>                             } else if (phid == C2S) {
>                                 printf("\nDissolving C2S: pdis = %f\tdisprob = ",pdis);
>                                 if (Micpart[xl][yl][zl] == 0) {
>                                     printf("%f",Onepixelbias[phid] * PHfactor[phid] * Disprob[phid]);
>                                 } else {
>                                     printf("%f",PHfactor[phid] * Disprob[phid]);
>                                 }
>                             } else if (phid == C3A) {
>                                 printf("\nDissolving C3A: pdis = %f\tdisprob = ",pdis);
>                                 if (Micpart[xl][yl][zl] == 0) {
>                                     printf("%f",Onepixelbias[phid] * PHfactor[phid] * Disprob[phid]);
>                                 } else {
>                                     printf("%f",PHfactor[phid] * Disprob[phid]);
>                                 }
>                             } else if (phid == C4AF) {
>                                 printf("\nDissolving C4AF: pdis = %f\tdisprob = ",pdis);
>                                 if (Micpart[xl][yl][zl] == 0) {
>                                     printf("%f",Onepixelbias[phid] * PHfactor[phid] * Disprob[phid]);
>                                 } else {
>                                     printf("%f",PHfactor[phid] * Disprob[phid]);
>                                 }
>                             } else if (phid == GYPSUM) {
>                                 printf("\nDissolving GYPSUM: pdis = %f\tdisprob = ",pdis);
>                                 if (Micpart[xl][yl][zl] == 0) {
>                                     printf("%f",Onepixelbias[phid] * PHfactor[phid] * Disprob[phid]);
>                                 } else {
>                                     printf("%f",PHfactor[phid] * Disprob[phid]);
>                                 }
>                             }
>                             fflush(stdout);
>                         }
>                         */
7096,7105c6709,6711
<   /*
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (iii = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
---
>                         Discount[phid]++;
>                         cread = Creates[phid];
>                         Count[phid]--;
7107,7110c6713,6717
<   if (Verbose_flag > 1) fprintf(Logfile,"\nEntering Main dissolve loop,
<   Count[DIFFSO4] = %d, Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]); fflush(Logfile);
<   */
---
>                         /***
>                         *     The space formerly occupied by the unhydrated pixel now
>                         *     becomes filled with whatever solvent was used to dissolve
>                         *     it (POROSITY or CRACKP) (24 May 2004)
>                         ***/
7112,7114c6719,6720
<   for (zl = 0; zl < Zsyssize; zl++) {
<     for (yl = 0; yl < Ysyssize; yl++) {
<       for (xl = 0; xl < Xsyssize; xl++) {
---
>                         sourcepore = Mic[xc][yc][zc];
>                         Mic[xl][yl][zl] = sourcepore;
7116,7123c6722
<         /***
<          *    Work only with pixels that are marked for
<          *     dissolution.  Convert them back to their
<          *     original ID before doing anything else
<          *
<          *     Note that K2SO4 and NA2SO4 are handled
<          *     differently below this loop (7 June 2004)
<          ***/
---
>                         if (phid == C3AH6) nhgd++;
7125,7127c6724
<         if (Mic[xl][yl][zl] > OFFSET &&
<             (Mic[xl][yl][zl] - (OFFSET)) != (K2SO4) &&
<             (Mic[xl][yl][zl] - (OFFSET)) != (NA2SO4)) {
---
>                         /* Special dissolution for C4AF */
7129,7131c6726,6728
<           phid = (int)Mic[xl][yl][zl] - (OFFSET);
<           if (phid == GYPSUM)
<             gct++;
---
>                         if (phid == C4AF) {
>                             plfh3 = ran1(Seed);
>                             if ((plfh3 < 0.0) || (plfh3 > 1.0)) plfh3=1.0;
7133c6730,6733
<           /* Attempt a one-step random walk to dissolve */
---
>                             /***
>                             *    For every C4AF that dissolves, 0.5453 
>                             *    diffusing FH3 species should be created
>                             ***/
7135,7138c6735,6738
<           plnew = (int)((float)NEIGHBORS * ran1(Seed));
<           if ((plnew < 0) || (plnew >= NEIGHBORS)) {
<             plnew = NEIGHBORS - 1;
<           }
---
>                             if (plfh3 <= 0.5453) {
>                                 cread = DIFFFH3;
>                             }
>                         }
7140,7142c6740
<           xc = xl + Xoff[plnew];
<           yc = yl + Yoff[plnew];
<           zc = zl + Zoff[plnew];
---
>                         if (cread == POROSITY) {
7144,7146c6742,6746
<           xc += checkbc(xc, Xsyssize);
<           yc += checkbc(yc, Ysyssize);
<           zc += checkbc(zc, Zsyssize);
---
>                             /***
>                             *    Increment count of POROSITY or CRACKP, depending
>                             *    on which was used in the dissolution of the solid
>                             *    (24 May 2004)
>                             ***/
7148,7150c6748
<           pixdeact = 0;
<           if ((Xoff[plnew] == (-1)) &&
<               (Deactivated[xl][yl][zl] % Primevalues[1] == 0)) {
---
>                             Count[sourcepore]++;
7152,7153c6750,6755
<             pixdeact = 1;
<           }
---
>                         } else {
>                             Nmade++;
>                             Ngoing++;
>                             phnew = cread;
>                             Count[phnew]++;
>                             Mic[xc][yc][zc] = phnew;
7155,7156c6757
<           if ((!pixdeact) && (Xoff[plnew] == 1) &&
<               (Deactivated[xl][yl][zl] % Primevalues[0] == 0)) {
---
>                             /* Add an ant for this diffusing pixel */
7158,7159c6759,6764
<             pixdeact = 1;
<           }
---
>                             antadd = (struct Ants *)malloc(Antsize);
>                             antadd->x = xc;
>                             antadd->y = yc;
>                             antadd->z = zc;
>                             antadd->id = phnew;
>                             antadd->cycbirth = Cyccnt;
7161,7162c6766,6769
<           if ((!pixdeact) && (Yoff[plnew] == (-1)) &&
<               (Deactivated[xl][yl][zl] % Primevalues[3] == 0)) {
---
>                             /***
>                             *    Connect this ant structure to end
>                             *    of linked list
>                             ***/
7164,7165c6771,6775
<             pixdeact = 1;
<           }
---
>                             antadd->prevant = Tailant;
>                             Tailant->nextant = antadd;
>                             antadd->nextant = NULL;
>                             Tailant = antadd;
>                         }
7167,7168c6777,6780
<           if ((!pixdeact) && (Yoff[plnew] == 1) &&
<               (Deactivated[xl][yl][zl] % Primevalues[2] == 0)) {
---
>                         /***
>                         *    Extra CSH diffusing species based
>                         *    on current temperature
>                         ***/
7170,7171c6782
<             pixdeact = 1;
<           }
---
>                         if ((phid == C3S) || (phid == C2S)) {
7173,7174c6784,6786
<           if ((!pixdeact) && (Zoff[plnew] == (-1)) &&
<               (Deactivated[xl][yl][zl] % Primevalues[5] == 0)) {
---
>                             plfh3 = ran1(Seed);
>                             if (((phid == C2S) && (plfh3 <= pc2scsh))
>                                 || (plfh3 <= pc3scsh)) {
7176,7177c6788,6796
<             pixdeact = 1;
<           }
---
>                                 placed = loccsh(xc,yc,zc,sourcepore);
>                                 if (placed) {
>                                     Count[DIFFCSH]++;
>                                     Count[sourcepore]--;
>                                 } else {
>                                     cshrand++;
>                                 }
>                             }
>                         }
7179,7180c6798,6809
<           if ((!pixdeact) && (Zoff[plnew] == 1) &&
<               (Deactivated[xl][yl][zl] % Primevalues[4] == 0)) {
---
>                         if ((phid == C2S) && (pc2scsh > 1.0)) {
>                             plfh3 = ran1(Seed);
>                             if (plfh3 <= (pc2scsh - 1.0)) {
>                                 placed = loccsh(xc,yc,zc,sourcepore);
>                                 if (placed) {
>                                     Count[DIFFCSH]++;
>                                     Count[sourcepore]--;
>                                 } else {
>                                     cshrand++;
>                                 }
>                             }
>                         }
7182,7183c6811
<             pixdeact = 1;
<           }
---
>                     } else {
7185c6813,6816
<           /* Generate probability for dissolution */
---
>                         /***
>                         *    Pixel does NOT dissolve, just reset its phase
>                         *    ID back to its original value
>                         ***/
7187c6818
<           pdis = ran1(Seed);
---
>                         Mic[xl][yl][zl] -= OFFSET;
7189,7197c6820
<           /***
<            *    Bias dissolution for one pixel particles as
<            *    indicated by a pixel value of zero in the
<            *    particle microstructure image
<            *
<            *    We do allow dissolution of unhydrated material
<            *    into water in saturated crack pores formed during
<            *    the hydration process (24 May 2004)
<            ***/
---
>                     }
7199,7204c6822
<           if (((pdis <= (PHfactor[phid] * Disprob[phid])) ||
<                ((pdis <=
<                  (Onepixelbias[phid] * PHfactor[phid] * Disprob[phid])) &&
<                 (Micpart[xl][yl][zl] == 0))) &&
<               (Mic[xc][yc][zc] == POROSITY || Mic[xc][yc][zc] == CRACKP) &&
<               (!pixdeact)) {
---
>                 } /* end of if edge block */
7206,7210d6823
<             /***
<              *    Special case of possible topochemical
<              *    transformation of C3S to CSH without
<              *    dissolution (NOT YET ENABLED, 24 April 2003)
<              ***/
7212,7257c6825,6851
<             /*
<             if (Verbose_flag > 2) {
<                 if (phid == C3S) {
<                     fprintf(Logfile,"\nDissolving C3S: pdis = %f\tdisprob =
<             ",pdis); if (Micpart[xl][yl][zl] == 0) {
<                         fprintf(Logfile,"%f",Onepixelbias[phid] *
<             PHfactor[phid]
<             * Disprob[phid]); } else { fprintf(Logfile,"%f",PHfactor[phid] *
<             Disprob[phid]);
<                     }
<                 } else if (phid == C2S) {
<                     fprintf(Logfile,"\nDissolving C2S: pdis = %f\tdisprob =
<             ",pdis); if (Micpart[xl][yl][zl] == 0) {
<                         fprintf(Logfile,"%f",Onepixelbias[phid] *
<             PHfactor[phid]
<             * Disprob[phid]); } else { fprintf(Logfile,"%f",PHfactor[phid] *
<             Disprob[phid]);
<                     }
<                 } else if (phid == C3A) {
<                     fprintf(Logfile,"\nDissolving C3A: pdis = %f\tdisprob =
<             ",pdis); if (Micpart[xl][yl][zl] == 0) {
<                         fprintf(Logfile,"%f",Onepixelbias[phid] *
<             PHfactor[phid]
<             * Disprob[phid]); } else { fprintf(Logfile,"%f",PHfactor[phid] *
<             Disprob[phid]);
<                     }
<                 } else if (phid == C4AF) {
<                     fprintf(Logfile,"\nDissolving C4AF: pdis = %f\tdisprob =
<             ",pdis); if (Micpart[xl][yl][zl] == 0) {
<                         fprintf(Logfile,"%f",Onepixelbias[phid] *
<             PHfactor[phid]
<             * Disprob[phid]); } else { fprintf(Logfile,"%f",PHfactor[phid] *
<             Disprob[phid]);
<                     }
<                 } else if (phid == GYPSUM) {
<                     fprintf(Logfile,"\nDissolving GYPSUM: pdis = %f\tdisprob =
<             ",pdis); if (Micpart[xl][yl][zl] == 0) {
<                         fprintf(Logfile,"%f",Onepixelbias[phid] *
<             PHfactor[phid]
<             * Disprob[phid]); } else { fprintf(Logfile,"%f",PHfactor[phid] *
<             Disprob[phid]);
<                     }
<                 }
<                 fflush(Logfile);
<             }
<             */
---
>                 /***
>                 *    Now check if CSH to pozzolanic CSH conversion is
>                 *    possible:
>                 *
>                 *        (1) Only if CH is less than 30% in volume,
>                 *        (2) Only if CSH is in contact with at
>                 *            least one porosity, AND
>                 *        (3) User wishes to implement this option
>                 ***/
> 
>                 if (((Count[SFUME]+Count[AMSIL])
>                             >= (0.013 * (double)(Syspix)))
>                     && (Chnew < (0.30 * (double)(Syspix)))
>                     && (Csh2flag == 1)) {
> 
>                     if (Mic[xl][yl][zl] == CSH) {
>                         if ((countbox(3,xl,yl,zl)) >= 1) {
>                             pconvert = ran1(Seed);
>                             if (pconvert < PCSH2CSH) {
>                                 Count[CSH]--;
>                                 plfh3=ran1(Seed);
> 
>                                 /***
>                                 *    Molarvcsh units of C1.7SHx goes to
>                                 *    101.81 units of C1.1SH3.9 with 19.86
>                                 *    units of CH so p=calcy
>                                 ***/
7259,7261c6853,6866
<             Discount[phid]++;
<             cread = Creates[phid];
<             Count[phid]--;
---
>                                 calcz = 0.0;
>                                 cycnew = Cshage[xl][yl][zl];
>                                 calcy = Molarv[POZZCSH] / Molarvcsh[cycnew];
>                                 if (calcy > 1.0) {
>                                     calcz = calcy - 1.0;
>                                     calcy = 1.0;
>                                     if (Verbose) {
>                                         printf("WARNING:  Problem of not ");
>                                         printf("creating enough pozzolanic ");
>                                         printf("CSH during CSH conversion");
>                                         printf("\nCurrent binder temperature");
>                                         printf("is %f C\n",Temp_cur_b);
>                                     }
>                                 }
7263,7267c6868,6876
<             /***
<              *     The space formerly occupied by the unhydrated pixel now
<              *     becomes filled with whatever solvent was used to dissolve
<              *     it (POROSITY or CRACKP) (24 May 2004)
<              ***/
---
>                                 if (plfh3 <= calcy) {
>                                     Mic[xl][yl][zl] = POZZCSH;
>                                     Count[POZZCSH]++;
>                                 } else {
>                                     Mic[xl][yl][zl] = DIFFCH;
>                                     Nmade++;
>                                     ncshgo++;
>                                     Ngoing++;
>                                     Count[DIFFCH]++;
7269,7270c6878,6881
<             sourcepore = Mic[xc][yc][zc];
<             Mic[xl][yl][zl] = sourcepore;
---
>                                     /***
>                                     *    Allocate memory for the new
>                                     *    diffusing species in the linked list
>                                     ***/
7272,7273c6883,6888
<             if (phid == C3AH6)
<               nhgd++;
---
>                                     antadd = (struct Ants *)malloc(Antsize);
>                                     antadd->x = xl;
>                                     antadd->y = yl;
>                                     antadd->z = zl;
>                                     antadd->id = DIFFCH;
>                                     antadd->cycbirth = Cyccnt;
7275c6890,6893
<             /* Special dissolution for C4AF */
---
>                                     /***
>                                     *    Now connect this ant structure
>                                     *    to end of linked list
>                                     ***/
7277,7280c6895,6899
<             if (phid == C4AF) {
<               plfh3 = ran1(Seed);
<               if ((plfh3 < 0.0) || (plfh3 > 1.0))
<                 plfh3 = 1.0;
---
>                                     antadd->prevant = Tailant;
>                                     Tailant->nextant = antadd;
>                                     antadd->nextant = NULL;
>                                     Tailant = antadd;
>                                 }
7282,7285c6901,6906
<               /***
<                *    For every C4AF that dissolves, 0.5453
<                *    diffusing FH3 species should be created
<                ***/
---
>                                 /***
>                                 *    Possibly need even more pozzolanic CSH
>                                 *
>                                 *    Would need a diffusing pozzolanic
>                                 *    CSH species???
>                                 ***/
7287,7290c6908,6915
<               if (plfh3 <= 0.5453) {
<                 cread = DIFFFH3;
<               }
<             }
---
>                                 /*
>                                 if (calcz > 0.0) {
>                                     plfh3 = ran1(Seed);
>                                     if (plfh3 <= calcz) {
>                                         cshrand++;
>                                     }
>                                 }
>                                 */
7292c6917,6919
<             if (cread == POROSITY) {
---
>                                 plfh3 = ran1(Seed);
>                                 calcx = (19.86 / Molarvcsh[cycnew])
>                                             - (1.0 - calcy);
7294,7298c6921
<               /***
<                *    Increment count of POROSITY or CRACKP, depending
<                *    on which was used in the dissolution of the solid
<                *    (24 May 2004)
<                ***/
---
>                                 /* Ex. 0.12658=(19.86/108.)-(1.-0.94269) */
7300c6923,6927
<               Count[sourcepore]++;
---
>                                 if (plfh3 < calcx) npchext++;
>                             }
>                         }
>                     }
>                 }
7302,7307c6929,6932
<             } else {
<               Nmade++;
<               Ngoing++;
<               phnew = cread;
<               Count[phnew]++;
<               Mic[xc][yc][zc] = phnew;
---
>                 /***
>                 *    See if slag can react --- must be
>                 *    in contact with at least one porosity pixel
>                 ***/
7309c6934
<               /* Add an ant for this diffusing pixel */
---
>                 if (Mic[xl][yl][zl] == SLAG) {
7311,7316c6936,6938
<               antadd = (struct Ants *)malloc(Antsize);
<               antadd->x = xc;
<               antadd->y = yc;
<               antadd->z = zc;
<               antadd->id = phnew;
<               antadd->cycbirth = Cyccnt;
---
>                     if ((countbox(3,xl,yl,zl)) >= 1) {
>                         pconvert = ran1(Seed);
>                         if (pconvert < (PHfactor[SLAG] * Disprob[SLAG])) {
7318,7321c6940,6942
<               /***
<                *    Connect this ant structure to end
<                *    of linked list
<                ***/
---
>                             Nslagr++;
>                             Count[SLAG]--;
>                             Discount[SLAG]++;
7323,7327c6944
<               antadd->prevant = Tailant;
<               Tailant->nextant = antadd;
<               antadd->nextant = NULL;
<               Tailant = antadd;
<             }
---
>                             /* Check on extra C3A generation */
7329,7332c6946,6947
<             /***
<              *    Extra CSH diffusing species based
<              *    on current temperature
<              ***/
---
>                             plfh3 = ran1(Seed);
>                             if (plfh3 < P5slag) nslagc3a++;
7334c6949
<             if ((phid == C3S) || (phid == C2S)) {
---
>                             /* Convert slag to reaction products */
7336,7337c6951,6956
<               plfh3 = ran1(Seed);
<               if (((phid == C2S) && (plfh3 <= pc2scsh)) || (plfh3 <= pc3scsh)) {
---
>                             plfh3 = ran1(Seed);
>                             if (plfh3 < P1slag) {
>                                 Mic[xl][yl][zl] = SLAGCSH;
>                                 Count[SLAGCSH]++;
>                             } else {
>                                 if (Sealed == 1) {
7339,7347c6958,6962
<                 placed = loccsh(xc, yc, zc, sourcepore);
<                 if (placed) {
<                   Count[DIFFCSH]++;
<                   Count[sourcepore]--;
<                 } else {
<                   cshrand++;
<                 }
<               }
<             }
---
>                                     /* Create empty porosity at slag site */
>                                     Slagemptyp++;
>                                     Mic[xl][yl][zl] = EMPTYP;
>                                     Count[EMPTYP]++;
>                                 } else {
7349,7360c6964,6968
<             if ((phid == C2S) && (pc2scsh > 1.0)) {
<               plfh3 = ran1(Seed);
<               if (plfh3 <= (pc2scsh - 1.0)) {
<                 placed = loccsh(xc, yc, zc, sourcepore);
<                 if (placed) {
<                   Count[DIFFCSH]++;
<                   Count[sourcepore]--;
<                 } else {
<                   cshrand++;
<                 }
<               }
<             }
---
>                                     /***
>                                     *    We do not distinguish between saturated
>                                     *    porosity and saturated crack porosity
>                                     *    here (24 May 2004)
>                                     ***/
7362c6970,6973
<           } else {
---
>                                     Mic[xl][yl][zl] = POROSITY;
>                                     Count[POROSITY]++;
>                                 }
>                             }
7364,7367c6975
<             /***
<              *    Pixel does NOT dissolve, just reset its phase
<              *    ID back to its original value
<              ***/
---
>                             /* Add in extra SLAGCSH as needed */
7369,7370c6977,6981
<             Mic[xl][yl][zl] -= OFFSET;
<           }
---
>                             p3init = P3slag;
>                             while (p3init > 1.0) {
>                                 extslagcsh(xl,yl,zl);
>                                 p3init -= 1.0;
>                             }
7372c6983,6984
<         } /* end of if edge block */
---
>                             plfh3 = ran1(Seed);
>                             if (plfh3 < p3init) extslagcsh(xl,yl,zl);
7374,7385c6986,6988
<         /***
<          *    Now check if CSH to pozzolanic CSH conversion is
<          *    possible:
<          *
<          *        (1) Only if CH is less than 30% in volume,
<          *        (2) Only if CSH is in contact with at
<          *            least one porosity, AND
<          *        (3) User wishes to implement this option
<          ***/
< 
<         if (((Count[SFUME] + Count[AMSIL]) >= (0.013 * (double)(Syspix))) &&
<             (Chnew < (0.30 * (double)(Syspix))) && (Csh2flag == 1)) {
---
>                         }
>                     }
>                 }
7387,7392c6990,6992
<           if (Mic[xl][yl][zl] == CSH) {
<             if ((countbox(3, xl, yl, zl)) >= 1) {
<               pconvert = ran1(Seed);
<               if (pconvert < PCSH2CSH) {
<                 Count[CSH]--;
<                 plfh3 = ran1(Seed);
---
>             }    /* end of zl loop */
>         }        /* end of yl loop */
>     }            /* end of xl loop */
7394,7398c6994,7003
<                 /***
<                  *    Molarvcsh units of C1.7SHx goes to
<                  *    101.81 units of C1.1SH3.9 with 19.86
<                  *    units of CH so p=calcy
<                  ***/
---
>     /*
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
>     }
7400,7413c7005,7007
<                 calcz = 0.0;
<                 cycnew = Cshage[xl][yl][zl];
<                 calcy = Molarv[POZZCSH] / Molarvcsh[cycnew];
<                 if (calcy > 1.0) {
<                   calcz = calcy - 1.0;
<                   calcy = 1.0;
<                   if (Verbose_flag > 0) {
<                     fprintf(Logfile, "WARNING:  Problem of not ");
<                     fprintf(Logfile, "creating enough pozzolanic ");
<                     fprintf(Logfile, "CSH during CSH conversion");
<                     fprintf(Logfile, "\nCurrent binder temperature");
<                     fprintf(Logfile, "is %f C\n", Temp_cur_b);
<                   }
<                 }
---
>     if (Verbose) printf("\nLeaving Main dissolve loop, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>     fflush(stdout);
>     */
7415,7423c7009,7031
<                 if (plfh3 <= calcy) {
<                   Mic[xl][yl][zl] = POZZCSH;
<                   Count[POZZCSH]++;
<                 } else {
<                   Mic[xl][yl][zl] = DIFFCH;
<                   Nmade++;
<                   ncshgo++;
<                   Ngoing++;
<                   Count[DIFFCH]++;
---
>     /***
>     *    Next, dissolve the necessary number of sodium sulfate
>     *    and potassium sulfate pixels.  nkspix and nnaspix are
>     *    the total number of pixels of K2SO4 and NA2SO4 that
>     *    need to be dissolved during this cycle
>     *
>     *    This is a dissolution proportional to the amount that
>     *    pHpred function predicts should be dissolved of the
>     *    the readily soluble species in the cement.
>     *
>     *    Eventually may want to make this microstructure based;
>     *    that is, may want to treat NA2SO4 and K2SO4 like any other
>     *    pixel that has a probability of dissolving, and then let 
>     *    the number dissolved be input to pHpred, rather than
>     *    letting pHpred dictate the amount of pixels to be
>     *    dissolved.  However, currently our measurements of
>     *    total and readily soluble alkalies appear to be more
>     *    accurate than the SEM/X-ray analysis measurements.
>     *
>     *    Note that currently the dissolution probability
>     *    is unity.  That is, as soon as each eligible
>     *    alkali sulfate is found, it dissolves.
>     ***/
7425,7428c7033,7036
<                   /***
<                    *    Allocate memory for the new
<                    *    diffusing species in the linked list
<                    ***/
---
>     /* Cumulative pixels of Pot. Sulf. that need to dissolve */
>     nkspix = Ksulfinit * (Releasedk / (Totpotassium/MMK2O));
>     /* Subtract from this the number dissolved in previous cycles */
>     nkspix -= (Ksulfinit - Count[K2SO4]);
7430,7435d7037
<                   antadd = (struct Ants *)malloc(Antsize);
<                   antadd->x = xl;
<                   antadd->y = yl;
<                   antadd->z = zl;
<                   antadd->id = DIFFCH;
<                   antadd->cycbirth = Cyccnt;
7437,7440c7039,7054
<                   /***
<                    *    Now connect this ant structure
<                    *    to end of linked list
<                    ***/
---
>     /* Cumulative pixels of Sod. Sulf. that need to dissolve */
>     nnaspix = Nasulfinit * (Releasedna / (Totsodium/MMNa2O));
>     /* Subtract from this the number dissolved in previous cycles */
>     nnaspix -= (Nasulfinit - Count[NA2SO4]);
>     
>     /*
>     if (Verbose) {
>           printf("\n***Ksulfinit = %d Count[K2SO4] = %d",Ksulfinit,Count[K2SO4]);
>         printf("\n***Releasedk = %f Totpotassium = %f",Releasedk,Totpotassium);
>         printf("\n***nkspix = %d",nkspix);
>         printf("\n***Nasulfinit = %d Count[NA2SO4] = %d",Nasulfinit,Count[NA2SO4]);
>         printf("\n***Releasedna = %f Totsodium = %f",Releasedna,Totsodium);
>         printf("\n***nnaspix = %d",nnaspix);
>         fflush(stdout);
>     }
>     */
7442,7446c7056,7059
<                   antadd->prevant = Tailant;
<                   Tailant->nextant = antadd;
<                   antadd->nextant = NULL;
<                   Tailant = antadd;
<                 }
---
>     /***
>     *    Determine number of potassium sulfates eligible
>     *    for dissolution and put them in a linked list
>     ***/
7448,7453c7061,7062
<                 /***
<                  *    Possibly need even more pozzolanic CSH
<                  *
<                  *    Would need a diffusing pozzolanic
<                  *    CSH species???
<                  ***/
---
>         totks = totnas = 0;
>     if (Ksulfinit > 0 && Count[K2SO4] > 0) {
7455,7462c7064
<                 /*
<                 if (calcz > 0.0) {
<                     plfh3 = ran1(Seed);
<                     if (plfh3 <= calcz) {
<                         cshrand++;
<                     }
<                 }
<                 */
---
>         /* delete the pot sulf linked list */
7464,7465c7066,7072
<                 plfh3 = ran1(Seed);
<                 calcx = (19.86 / Molarvcsh[cycnew]) - (1.0 - calcy);
---
>         while (Headks != Tailks) {
>             if (Tailks->prevas == NULL) {
>                 Tailks = Headks;
>             } else {
>                 Tailks = Tailks->prevas;
>             }
>         }
7467c7074,7078
<                 /* Ex. 0.12658=(19.86/108.)-(1.-0.94269) */
---
>         Headks->prevas = NULL;
>         Headks->nextas = NULL;
>         Headks->x = 0;
>         Headks->y = 0;
>         Headks->z = 0;
7469,7471c7080,7089
<                 if (plfh3 < calcx)
<                   npchext++;
<               }
---
>     }
> 
>     if (Nasulfinit > 0 && Count[NA2SO4] > 0) {
>         /* delete the sod sulf linked list */
> 
>         while (Headnas != Tailnas) {
>             if (Tailnas->prevas == NULL) {
>                 Tailnas = Headnas;
>             } else {
>                 Tailnas = Tailnas->prevas;
7473d7090
<           }
7476,7479c7093,7097
<         /***
<          *    See if slag can react --- must be
<          *    in contact with at least one porosity pixel
<          ***/
---
>         Headnas->prevas = NULL;
>         Headnas->nextas = NULL;
>         Headnas->x = 0;
>         Headnas->y = 0;
>         Headnas->z = 0;
7481c7099,7100
<         if (Mic[xl][yl][zl] == SLAG) {
---
>     }
>     
7483,7485c7102,7111
<           if ((countbox(3, xl, yl, zl)) >= 1) {
<             pconvert = ran1(Seed);
<             if (pconvert < (PHfactor[SLAG] * Disprob[SLAG])) {
---
>     /*
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
>     }
7487,7489c7113,7114
<               Nslagr++;
<               Count[SLAG]--;
<               Discount[SLAG]++;
---
>     if (Verbose) printf("\nEntering loop for ksulf list, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>     */
7491c7116,7118
<               /* Check on extra C3A generation */
---
>     /***
>     *    This next line turns off dissolution of NA2SO4 and K2SO4 completely
>     ***/
7493,7495c7120
<               plfh3 = ran1(Seed);
<               if (plfh3 < P5slag)
<                 nslagc3a++;
---
>     nkspix = nnaspix = 0;
7497c7122
<               /* Convert slag to reaction products */
---
>     /**************************/
7499,7504c7124,7129
<               plfh3 = ran1(Seed);
<               if (plfh3 < P1slag) {
<                 Mic[xl][yl][zl] = SLAGCSH;
<                 Count[SLAGCSH]++;
<               } else {
<                 if (Sealed == 1) {
---
>     if (nkspix < Count[K2SO4] && nkspix > 0) {
>         totks = 0;
>         for (zl = 0; zl < Zsyssize; zl++) {
>             for (yl = 0; yl < Ysyssize; yl++) {
>                 for (xl = 0; xl < Xsyssize; xl++) {
>                     if (Mic[xl][yl][zl] == ((int)(K2SO4) + (int)(OFFSET))) {
7506,7510c7131,7134
<                   /* Create empty porosity at slag site */
<                   Slagemptyp++;
<                   Mic[xl][yl][zl] = EMPTYP;
<                   Count[EMPTYP]++;
<                 } else {
---
>                     /***
>                     *    Uncomment above and comment below to query
>                     *    only SURFACE pixels of K2SO4
>                     ***/
7512,7516c7136,7143
<                   /***
<                    *    We do not distinguish between saturated
<                    *    porosity and saturated crack porosity
<                    *    here (24 May 2004)
<                    ***/
---
>                     /*
>                     if (Mic[xl][yl][zl] == ((int)(K2SO4)))
>                     */
>                         totks++;
>                         curas = (struct Alksulf *)malloc(Alksulfsize);
>                         curas->x = xl;
>                         curas->y = yl;
>                         curas->z = zl;
7518,7519c7145,7154
<                   Mic[xl][yl][zl] = POROSITY;
<                   Count[POROSITY]++;
---
>                         /***
>                         *    Now connect this node to
>                         *    end of linked list
>                         ***/
> 
>                         curas->prevas = Tailks;
>                         Tailks->nextas = curas;
>                         curas->nextas = NULL;
>                         Tailks = curas;
>                     }
7521c7156,7158
<               }
---
>             }
>         }
>     } else if (nkspix > 0) {
7523c7160
<               /* Add in extra SLAGCSH as needed */
---
>         /* Dissolve all the K2SO4 pixels in this cycle */
7525,7533c7162,7171
<               p3init = P3slag;
<               while (p3init > 1.0) {
<                 extslagcsh(xl, yl, zl);
<                 p3init -= 1.0;
<               }
< 
<               plfh3 = ran1(Seed);
<               if (plfh3 < p3init)
<                 extslagcsh(xl, yl, zl);
---
>         for (zl = 0; zl < Zsyssize; zl++) {
>             for (yl = 0; yl < Ysyssize; yl++) {
>                 for (xl = 0; xl < Xsyssize; xl++) {
>                     if (Mic[xl][yl][zl] == (K2SO4)) {
>                         Mic[xl][yl][zl] = POROSITY;
>                         Discount[K2SO4]++;
>                         Count[K2SO4]--;
>                         nkspix--;
>                     }
>                 }
7535d7172
<           }
7538,7540c7175,7176
<       } /* end of zl loop */
<     } /* end of yl loop */
<   } /* end of xl loop */
---
>         totks = 0;
>     }
7542,7551d7177
<   /*
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
7553,7556c7179,7188
<   if (Verbose_flag > 1) fprintf(Logfile,"\nLeaving Main dissolve loop,
<   Count[DIFFSO4] = %d, Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]); fflush(Logfile);
<   */
---
>     /*
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
>     }
7558,7580c7190,7191
<   /***
<    *    Next, dissolve the necessary number of sodium sulfate
<    *    and potassium sulfate pixels.  nkspix and nnaspix are
<    *    the total number of pixels of K2SO4 and NA2SO4 that
<    *    need to be dissolved during this cycle
<    *
<    *    This is a dissolution proportional to the amount that
<    *    pHpred function predicts should be dissolved of the
<    *    the readily soluble species in the cement.
<    *
<    *    Eventually may want to make this microstructure based;
<    *    that is, may want to treat NA2SO4 and K2SO4 like any other
<    *    pixel that has a probability of dissolving, and then let
<    *    the number dissolved be input to pHpred, rather than
<    *    letting pHpred dictate the amount of pixels to be
<    *    dissolved.  However, currently our measurements of
<    *    total and readily soluble alkalies appear to be more
<    *    accurate than the SEM/X-ray analysis measurements.
<    *
<    *    Note that currently the dissolution probability
<    *    is unity.  That is, as soon as each eligible
<    *    alkali sulfate is found, it dissolves.
<    ***/
---
>     if (Verbose) printf("\nEntering loop for nasulf list, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>     */
7582,7585c7193,7198
<   /* Cumulative pixels of Pot. Sulf. that need to dissolve */
<   nkspix = Ksulfinit * (Releasedk / (Totpotassium / MMK2O));
<   /* Subtract from this the number dissolved in previous cycles */
<   nkspix -= (Ksulfinit - Count[K2SO4]);
---
>     if (nnaspix < Count[NA2SO4] && nnaspix > 0) {
>         totnas = 0;
>         for (zl = 0; zl < Zsyssize; zl++) {
>             for (yl = 0; yl < Ysyssize; yl++) {
>                 for (xl = 0; xl < Xsyssize; xl++) {
>                     if (Mic[xl][yl][zl] == ((int)(NA2SO4) + (int)(OFFSET))) {
7587,7590c7200,7203
<   /* Cumulative pixels of Sod. Sulf. that need to dissolve */
<   nnaspix = Nasulfinit * (Releasedna / (Totsodium / MMNa2O));
<   /* Subtract from this the number dissolved in previous cycles */
<   nnaspix -= (Nasulfinit - Count[NA2SO4]);
---
>                     /***
>                     *    Uncomment above and comment below to query
>                     *    only SURFACE pixels of NA2SO4
>                     ***/
7592,7602c7205,7212
<   /*
<   if (Verbose_flag > 2) {
<         fprintf(Logfile,"\n***Ksulfinit = %d Count[K2SO4] =
<   %d",Ksulfinit,Count[K2SO4]); fprintf(Logfile,"\n***Releasedk = %f
<   Totpotassium = %f",Releasedk,Totpotassium); fprintf(Logfile,"\n***nkspix =
<   %d",nkspix); fprintf(Logfile,"\n***Nasulfinit = %d Count[NA2SO4] =
<   %d",Nasulfinit,Count[NA2SO4]); fprintf(Logfile,"\n***Releasedna = %f
<   Totsodium = %f",Releasedna,Totsodium); fprintf(Logfile,"\n***nnaspix =
<   %d",nnaspix); fflush(Logfile);
<   }
<   */
---
>                     /*
>                     if (Mic[xl][yl][zl] == ((int)(NA2SO4))) 
>                     */
>                         totnas++;
>                         curas = (struct Alksulf *)malloc(Alksulfsize);
>                         curas->x = xl;
>                         curas->y = yl;
>                         curas->z = zl;
7604,7607c7214,7217
<   /***
<    *    Determine number of potassium sulfates eligible
<    *    for dissolution and put them in a linked list
<    ***/
---
>                         /***
>                         *    Now connect this node to
>                         *    end of linked list
>                         ***/
7609,7610c7219,7227
<   totks = totnas = 0;
<   if (Ksulfinit > 0 && Count[K2SO4] > 0) {
---
>                         curas->prevas = Tailnas;
>                         Tailnas->nextas = curas;
>                         curas->nextas = NULL;
>                         Tailnas = curas;
>                     }
>                 }
>             }
>         }
>     } else if (nnaspix > 0) {
7612c7229
<     /* delete the pot sulf linked list */
---
>         /* Dissolve all NA2SO4 pixels in this cycle */
7614,7619c7231,7243
<     while (Headks != Tailks) {
<       if (Tailks->prevas == NULL) {
<         Tailks = Headks;
<       } else {
<         Tailks = Tailks->prevas;
<       }
---
>         for (zl = 0; zl < Zsyssize; zl++) {
>             for (yl = 0; yl < Ysyssize; yl++) {
>                 for (xl = 0; xl < Xsyssize; xl++) {
>                     if (Mic[xl][yl][zl] == (NA2SO4)) {
>                         Mic[xl][yl][zl] = POROSITY;
>                         Discount[NA2SO4]++;
>                         Count[NA2SO4]--;
>                         nnaspix--;
>                     }
>                 }
>             }
>         }
>         totnas = 0;
7622,7637c7246,7254
<     Headks->prevas = NULL;
<     Headks->nextas = NULL;
<     Headks->x = 0;
<     Headks->y = 0;
<     Headks->z = 0;
<   }
< 
<   if (Nasulfinit > 0 && Count[NA2SO4] > 0) {
<     /* delete the sod sulf linked list */
< 
<     while (Headnas != Tailnas) {
<       if (Tailnas->prevas == NULL) {
<         Tailnas = Headnas;
<       } else {
<         Tailnas = Tailnas->prevas;
<       }
---
>     /*
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
7640,7645c7257,7258
<     Headnas->prevas = NULL;
<     Headnas->nextas = NULL;
<     Headnas->x = 0;
<     Headnas->y = 0;
<     Headnas->z = 0;
<   }
---
>     if (Verbose) printf("\nLeaving loop for nasulf list, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>     */
7647,7656c7260,7262
<   /*
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
---
>     /***
>     *    Linked lists are established, now process
>     ***/
7658,7661c7264,7272
<   if (Verbose_flag > 2) fprintf(Logfile,"\nEntering loop for ksulf list,
<   Count[DIFFSO4] = %d, Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]);
<   */
---
>     /*
>     if (Verbose) printf("\ntotks = %d",totks);
>     */
>     while (nkspix > 0 && totks > 0) {
>         skipnodes = (int)((float)totks * ran1(Seed));
>         curas = Headks;
>         for (i = 0; i < skipnodes; i++) {
>             curas = curas->nextas;
>         }
7663,7665c7274,7277
<   /***
<    *    This next line turns off dissolution of NA2SO4 and K2SO4 completely
<    ***/
---
>         /***
>         *    Now we are positioned randomly within the list
>         *    Remove this element from the list
>         ***/
7667c7279,7281
<   nkspix = nnaspix = 0;
---
>         curx = curas->x;
>         cury = curas->y;
>         curz = curas->z;
7669c7283,7287
<   /**************************/
---
>         if (curas->prevas == NULL) {
>             Headks = curas->nextas;
>         } else {
>             curas->prevas->nextas = curas->nextas;
>         }
7671,7676c7289,7293
<   if (nkspix < Count[K2SO4] && nkspix > 0) {
<     totks = 0;
<     for (zl = 0; zl < Zsyssize; zl++) {
<       for (yl = 0; yl < Ysyssize; yl++) {
<         for (xl = 0; xl < Xsyssize; xl++) {
<           if (Mic[xl][yl][zl] == ((int)(K2SO4) + (int)(OFFSET))) {
---
>         if (curas->nextas == NULL) {
>             Tailks = curas->prevas;
>         } else {
>             curas->nextas->prevas = curas->prevas;
>         }
7678,7681c7295,7299
<             /***
<              *    Uncomment above and comment below to query
<              *    only SURFACE pixels of K2SO4
<              ***/
---
>         Mic[curx][cury][curz] = POROSITY;
>         Discount[K2SO4]++;
>         Count[K2SO4]--;
>         nkspix--;
>         totks--;
7683,7690c7301,7304
<             /*
<             if (Mic[xl][yl][zl] == ((int)(K2SO4)))
<             */
<             totks++;
<             curas = (struct Alksulf *)malloc(Alksulfsize);
<             curas->x = xl;
<             curas->y = yl;
<             curas->z = zl;
---
>         /***
>         *    Now look for other soluble K2SO4 that may have been
>         *    uncovered by this dissolution event
>         ***/
7692,7695c7306,7335
<             /***
<              *    Now connect this node to
<              *    end of linked list
<              ***/
---
>         for (i = 0; i < 6; i++) {
>             xl = curx;
>             yl = cury;
>             zl = curz;
>             switch (i) {
>                 case 0:
>                     xl++;
>                     xl += checkbc(xl,Xsyssize);
>                     break;
>                 case 1:
>                     xl--;
>                     xl += checkbc(xl,Xsyssize);
>                     break;
>                 case 2:
>                     yl++;
>                     yl += checkbc(yl,Ysyssize);
>                     break;
>                 case 3:
>                     yl--;
>                     yl += checkbc(yl,Ysyssize);
>                     break;
>                 case 4:
>                     zl++;
>                     zl += checkbc(zl,Zsyssize);
>                     break;
>                 case 5:
>                     zl--;
>                     zl += checkbc(zl,Zsyssize);
>                     break;
>             }
7697,7701c7337,7357
<             curas->prevas = Tailks;
<             Tailks->nextas = curas;
<             curas->nextas = NULL;
<             Tailks = curas;
<           }
---
>             if (Mic[xl][yl][zl] == (int)(K2SO4)) {
> 
>                 /* add to end of linked list */
> 
>                 totks++;
>                 Mic[xl][yl][zl] += (OFFSET);
>                 curas = (struct Alksulf *)malloc(Alksulfsize);
>                 curas->x = xl;
>                 curas->y = yl;
>                 curas->z = zl;
> 
>                 /***
>                 *    Now connect this node to
>                 *    end of linked list
>                 ***/
> 
>                 curas->prevas = Tailks;
>                 Tailks->nextas = curas;
>                 curas->nextas = NULL;
>                 Tailks = curas;
>             }
7703d7358
<       }
7705d7359
<   } else if (nkspix > 0) {
7707,7717c7361,7368
<     /* Dissolve all the K2SO4 pixels in this cycle */
< 
<     for (zl = 0; zl < Zsyssize; zl++) {
<       for (yl = 0; yl < Ysyssize; yl++) {
<         for (xl = 0; xl < Xsyssize; xl++) {
<           if (Mic[xl][yl][zl] == (K2SO4)) {
<             Mic[xl][yl][zl] = POROSITY;
<             Discount[K2SO4]++;
<             Count[K2SO4]--;
<             nkspix--;
<           }
---
>     /*
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
7719d7369
<       }
7722,7723c7372,7373
<     totks = 0;
<   }
---
>     if (Verbose) printf("\nFinished processing ksulf list, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>     */
7725,7734c7375,7378
<   /*
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
---
>     /***
>     *    Now go through remainder of linked list and
>     *    reset the phase ids
>     ***/
7736,7739c7380,7389
<   if (Verbose_flag > 2) fprintf(Logfile,"\nEntering loop for nasulf list,
<   Count[DIFFSO4] = %d, Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]);
<   */
---
>     if (Headnas != Tailnas) {
>         curas = Headks;
>         while (curas != NULL) {
>             curx = curas->x;
>             cury = curas->y;
>             curz = curas->z;
>             Mic[curx][cury][curz] = (K2SO4);
>             curas = curas->nextas;
>         }
>     }
7741,7746c7391,7393
<   if (nnaspix < Count[NA2SO4] && nnaspix > 0) {
<     totnas = 0;
<     for (zl = 0; zl < Zsyssize; zl++) {
<       for (yl = 0; yl < Ysyssize; yl++) {
<         for (xl = 0; xl < Xsyssize; xl++) {
<           if (Mic[xl][yl][zl] == ((int)(NA2SO4) + (int)(OFFSET))) {
---
>     /*
>     if (Verbose) printf("\nFinished processing ksulf ants, step 2, in dissolve...\nnnaspix = %d, totnas = %d\n",nnaspix,totnas);
>     */
7748,7751c7395,7400
<             /***
<              *    Uncomment above and comment below to query
<              *    only SURFACE pixels of NA2SO4
<              ***/
---
>     while (nnaspix > 0 && totnas > 0) {
>         skipnodes = (int)((float)totnas * ran1(Seed));
>         curas = Headnas;
>         for (i = 0; i < skipnodes; i++) {
>             curas = curas->nextas;
>         }
7753,7760c7402,7405
<             /*
<             if (Mic[xl][yl][zl] == ((int)(NA2SO4)))
<             */
<             totnas++;
<             curas = (struct Alksulf *)malloc(Alksulfsize);
<             curas->x = xl;
<             curas->y = yl;
<             curas->z = zl;
---
>         /***
>         *    Now we are positioned randomly within the list
>         *    Remove this element from the list
>         ***/
7762,7765c7407,7409
<             /***
<              *    Now connect this node to
<              *    end of linked list
<              ***/
---
>         curx = curas->x;
>         cury = curas->y;
>         curz = curas->z;
7767,7771c7411,7414
<             curas->prevas = Tailnas;
<             Tailnas->nextas = curas;
<             curas->nextas = NULL;
<             Tailnas = curas;
<           }
---
>         if (curas->prevas == NULL) {
>             Headnas = curas->nextas;
>         } else {
>             curas->prevas->nextas = curas->nextas;
7773,7775d7415
<       }
<     }
<   } else if (nnaspix > 0) {
7777,7787c7417,7420
<     /* Dissolve all NA2SO4 pixels in this cycle */
< 
<     for (zl = 0; zl < Zsyssize; zl++) {
<       for (yl = 0; yl < Ysyssize; yl++) {
<         for (xl = 0; xl < Xsyssize; xl++) {
<           if (Mic[xl][yl][zl] == (NA2SO4)) {
<             Mic[xl][yl][zl] = POROSITY;
<             Discount[NA2SO4]++;
<             Count[NA2SO4]--;
<             nnaspix--;
<           }
---
>         if (curas->nextas == NULL) {
>             Tailnas = curas->prevas;
>         } else {
>             curas->nextas->prevas = curas->prevas;
7789,7792d7421
<       }
<     }
<     totnas = 0;
<   }
7794,7803c7423,7427
<   /*
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
---
>         Mic[curx][cury][curz] = POROSITY;
>         Discount[NA2SO4]++;
>         Count[NA2SO4]--;
>         nnaspix--;
>         totnas--;
7805,7808c7429,7463
<   if (Verbose_flag > 2) fprintf(Logfile,"\nLeaving loop for nasulf list,
<   Count[DIFFSO4] = %d, Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]);
<   */
---
>         /***
>         *    Now look for other soluble NA2SO4 that may have been
>         *    uncovered by this dissolution event
>         ***/
>     
>         for (i = 0; i < 6; i++) {
>             xl = curx;
>             yl = cury;
>             zl = curz;
>             switch (i) {
>                 case 0:
>                     xl++;
>                     xl += checkbc(xl,Xsyssize);
>                     break;
>                 case 1:
>                     xl--;
>                     xl += checkbc(xl,Xsyssize);
>                     break;
>                 case 2:
>                     yl++;
>                     yl += checkbc(yl,Ysyssize);
>                     break;
>                 case 3:
>                     yl--;
>                     yl += checkbc(yl,Ysyssize);
>                     break;
>                 case 4:
>                     zl++;
>                     zl += checkbc(zl,Zsyssize);
>                     break;
>                 case 5:
>                     zl--;
>                     zl += checkbc(zl,Zsyssize);
>                     break;
>             }
7810,7812c7465
<   /***
<    *    Linked lists are established, now process
<    ***/
---
>             if (Mic[xl][yl][zl] == (int)(NA2SO4)) {
7814,7822c7467,7474
<   /*
<   if (Verbose_flag > 2) fprintf(Logfile,"\ntotks = %d",totks);
<   */
<   while (nkspix > 0 && totks > 0) {
<     skipnodes = (int)((float)totks * ran1(Seed));
<     curas = Headks;
<     for (i = 0; i < skipnodes; i++) {
<       curas = curas->nextas;
<     }
---
>                 /* add to end of linked list */
> 
>                 totnas++;
>                 Mic[xl][yl][zl] += (OFFSET);
>                 curas = (struct Alksulf *)malloc(Alksulfsize);
>                 curas->x = xl;
>                 curas->y = yl;
>                 curas->z = zl;
7824,7827c7476,7479
<     /***
<      *    Now we are positioned randomly within the list
<      *    Remove this element from the list
<      ***/
---
>                 /***
>                 *    Now connect this node to
>                 *    end of linked list
>                 ***/
7829,7831c7481,7486
<     curx = curas->x;
<     cury = curas->y;
<     curz = curas->z;
---
>                 curas->prevas = Tailnas;
>                 Tailnas->nextas = curas;
>                 curas->nextas = NULL;
>                 Tailnas = curas;
>             }
>         }
7833,7836d7487
<     if (curas->prevas == NULL) {
<       Headks = curas->nextas;
<     } else {
<       curas->prevas->nextas = curas->nextas;
7839,7842c7490,7498
<     if (curas->nextas == NULL) {
<       Tailks = curas->prevas;
<     } else {
<       curas->nextas->prevas = curas->prevas;
---
>     /*
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
7845,7849c7501,7502
<     Mic[curx][cury][curz] = POROSITY;
<     Discount[K2SO4]++;
<     Count[K2SO4]--;
<     nkspix--;
<     totks--;
---
>     if (Verbose) printf("\nFinished processing nasulf list, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>     */
7852,7854c7505,7507
<      *    Now look for other soluble K2SO4 that may have been
<      *    uncovered by this dissolution event
<      ***/
---
>     *    Now go through remainder of linked list and
>     *    reset the phase ids
>     ***/
7856,7885c7509,7518
<     for (i = 0; i < 6; i++) {
<       xl = curx;
<       yl = cury;
<       zl = curz;
<       switch (i) {
<       case 0:
<         xl++;
<         xl += checkbc(xl, Xsyssize);
<         break;
<       case 1:
<         xl--;
<         xl += checkbc(xl, Xsyssize);
<         break;
<       case 2:
<         yl++;
<         yl += checkbc(yl, Ysyssize);
<         break;
<       case 3:
<         yl--;
<         yl += checkbc(yl, Ysyssize);
<         break;
<       case 4:
<         zl++;
<         zl += checkbc(zl, Zsyssize);
<         break;
<       case 5:
<         zl--;
<         zl += checkbc(zl, Zsyssize);
<         break;
<       }
---
>     if (Headnas != Tailnas) {
>         curas = Headnas;
>         while (curas != NULL) {
>             curx = curas->x;
>             cury = curas->y;
>             curz = curas->z;
>             Mic[curx][cury][curz] = (NA2SO4);
>             curas = curas->nextas;
>         }
>     }
7887c7520,7529
<       if (Mic[xl][yl][zl] == (int)(K2SO4)) {
---
>     /*
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
>     }
7889c7531,7535
<         /* add to end of linked list */
---
>     if (Verbose) {
>         printf("\nFinished resetting nasulf ids, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>         printf("\nEligible gypsum count = %d\n",gct);
>     }
>     */
7891,7896c7537
<         totks++;
<         Mic[xl][yl][zl] += (OFFSET);
<         curas = (struct Alksulf *)malloc(Alksulfsize);
<         curas->x = xl;
<         curas->y = yl;
<         curas->z = zl;
---
>     if ((ncshgo != 0) && (Verbose == 1)) printf("CSH dissolved is %d \n",ncshgo);
7898,7901c7539
<         /***
<          *    Now connect this node to
<          *    end of linked list
<          ***/
---
>     if ((npchext > 0) && (Verbose == 1)) printf("Extra CH required is %d at cycle %d \n",npchext,cycle);
7903,7909c7541,7546
<         curas->prevas = Tailks;
<         Tailks->nextas = curas;
<         curas->nextas = NULL;
<         Tailks = curas;
<       }
<     }
<   }
---
>     /***
>     *    Now add in the extra diffusing species for dissolution
>     *
>     *    Expansion factors from Young and Hansen and Mindess and
>     *    Young (Concrete)
>     ***/
7911,7920c7548,7549
<   /*
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
---
>     ncshext = cshrand;
>     if ((cshrand != 0) && (Verbose == 1)) printf("cshrand is %d \n",cshrand);
7922,7925c7551,7554
<   if (Verbose_flag > 2) fprintf(Logfile,"\nFinished processing ksulf list,
<   Count[DIFFSO4] = %d, Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]);
<   */
---
>     /***
>     *    Extra diffusing CH, Gypsum, C3A, and SO4 are added at totally random
>     *    locations, rather than at the dissolution site
>     ***/
7927,7930c7556,7559
<   /***
<    *    Now go through remainder of linked list and
<    *    reset the phase ids
<    ***/
---
>     fchext = (0.61 * (double)Discount[C3S])
>                 + (0.191 * (double)Discount[C2S])
>                 + (0.2584 * (double)Discount[C4AF])
>                 + (0.954 * (double)Discount[FREELIME]);
7932,7939c7561,7564
<   if (Headnas != Tailnas) {
<     curas = Headks;
<     while (curas != NULL) {
<       curx = curas->x;
<       cury = curas->y;
<       curz = curas->z;
<       Mic[curx][cury][curz] = (K2SO4);
<       curas = curas->nextas;
---
>     nchext = fchext;
>     if (fchext > (double)nchext) {
>         pdis = ran1(Seed);
>         if ((fchext - (double)nchext) > pdis) nchext++;
7941d7565
<   }
7943,7946c7567
<   /*
<   if (Verbose_flag > 2) fprintf(Logfile,"\nFinished processing ksulf ants,
<   step 2, in dissolve...\nnnaspix = %d, totnas = %d\n",nnaspix,totnas);
<   */
---
>     nchext += npchext;
7948,7954d7568
<   while (nnaspix > 0 && totnas > 0) {
<     skipnodes = (int)((float)totnas * ran1(Seed));
<     curas = Headnas;
<     for (i = 0; i < skipnodes; i++) {
<       curas = curas->nextas;
<     }
< 
7956,7958c7570,7573
<      *    Now we are positioned randomly within the list
<      *    Remove this element from the list
<      ***/
---
>     *    Adjust CH addition for slag consumption and
>     *    nucleation of secondary gypsum from dissolved
>     *    alkali sulfates (8 June 2004)
>     ***/
7960,7962c7575,7590
<     curx = curas->x;
<     cury = curas->y;
<     curz = curas->z;
---
>     Slagcum += Discount[SLAG];
>     Chgone = (int)(P4slag * (float)Slagcum);
>     Slagcum -= (int)((float)Chgone / P4slag);
>     savechgone = Chgone;
>     Chgone = 0;
>     sulfavemolarv = (float)(Discount[K2SO4])*Molarv[K2SO4];
>     sulfavemolarv += (float)(Discount[NA2SO4])*Molarv[NA2SO4];
>     if (sulfavemolarv > 0.0) {
>         sulfavemolarv /= ((float)(Discount[K2SO4] + Discount[NA2SO4]));
>         Chgone = (int)((float)(Nucsulf2gyps) * Molarv[CH] / sulfavemolarv);
>         Nucsulf2gyps -= (int)(((float)Chgone) * sulfavemolarv / Molarv[CH]);
>     }
>     Chgone += savechgone;
>     nchext -= Chgone;
>     nchext -= DIFFCHdeficit;
>     DIFFCHdeficit = 0;
7964,7967c7592,7594
<     if (curas->prevas == NULL) {
<       Headnas = curas->nextas;
<     } else {
<       curas->prevas->nextas = curas->nextas;
---
>     if (nchext < 0) {
>         DIFFCHdeficit -= nchext;
>         nchext = 0;
7970,7973c7597,7602
<     if (curas->nextas == NULL) {
<       Tailnas = curas->prevas;
<     } else {
<       curas->nextas->prevas = curas->prevas;
---
>     fc3aext = (double)Discount[C3A] + (double)Discount[OC3A];
>     fc3aext += (0.5917 * (double)Discount[C3AH6]);
>     nc3aext = fc3aext + nslagc3a;
>     if (fc3aext > (double)nc3aext) {
>         pdis=ran1(Seed);
>         if ((fc3aext - (double)nc3aext) > pdis) nc3aext++;
7976,7980c7605,7610
<     Mic[curx][cury][curz] = POROSITY;
<     Discount[NA2SO4]++;
<     Count[NA2SO4]--;
<     nnaspix--;
<     totnas--;
---
>     fc4aext = 0.696 * (double)Discount[C4AF];
>     nc4aext = fc4aext;
>     if (fc4aext > (double)nc4aext) {
>         pdis = ran1(Seed);
>         if ((fc4aext - (double)nc4aext) > pdis) nc4aext++;
>     }
7981a7612,7615
>     /* Both forms of GYPSUM form same DIFFGYP species */
> 
>     ngypext = Discount[GYPSUM] + Discount[GYPSUMS];
> 
7983,7985c7617,7624
<      *    Now look for other soluble NA2SO4 that may have been
<      *    uncovered by this dissolution event
<      ***/
---
>     *    Convert to diffusing anhydrite at volume
>     *    necessary for final gypsum formation
>     *
>     *    (1 anhydrite --> 1.423 gypsum)
>     *
>     *    Since hemihydrate can now react with C3A, etc.,
>     *    can't do expansion here any longer  7/99
>     ***/
7987,8016c7626
<     for (i = 0; i < 6; i++) {
<       xl = curx;
<       yl = cury;
<       zl = curz;
<       switch (i) {
<       case 0:
<         xl++;
<         xl += checkbc(xl, Xsyssize);
<         break;
<       case 1:
<         xl--;
<         xl += checkbc(xl, Xsyssize);
<         break;
<       case 2:
<         yl++;
<         yl += checkbc(yl, Ysyssize);
<         break;
<       case 3:
<         yl--;
<         yl += checkbc(yl, Ysyssize);
<         break;
<       case 4:
<         zl++;
<         zl += checkbc(zl, Zsyssize);
<         break;
<       case 5:
<         zl--;
<         zl += checkbc(zl, Zsyssize);
<         break;
<       }
---
>     /*    fanhext = 1.423 * (float)Discount[ANHYDRITE]; */
8018c7628,7633
<       if (Mic[xl][yl][zl] == (int)(NA2SO4)) {
---
>     fanhext = (double)Discount[ANHYDRITE];
>     nanhext = fanhext;
>     if (fanhext > (double)nanhext) {
>         pdis = ran1(Seed);
>         if ((fanhext - (double)nanhext) > pdis) nanhext++;
>     }
8020c7635,7643
<         /* add to end of linked list */
---
>     /***
>     *    Convert to diffusing hemiydrate at volume necessary
>     *    for final gypsum formation
>     *
>     *    (1 hemihydrate --> 1.4 gypsum)
>     *
>     *    Since hemihydrate can now react with C3A, etc.,
>     *    can't do expansion here any longer  7/99
>     ***/
8022,8027c7645
<         totnas++;
<         Mic[xl][yl][zl] += (OFFSET);
<         curas = (struct Alksulf *)malloc(Alksulfsize);
<         curas->x = xl;
<         curas->y = yl;
<         curas->z = zl;
---
>     /*    fhemext=1.3955*(float)Discount[HEMIHYD];  */
8029,8032c7647
<         /***
<          *    Now connect this node to
<          *    end of linked list
<          ***/
---
>     fhemext = (double)Discount[HEMIHYD];
8034,8038c7649,7652
<         curas->prevas = Tailnas;
<         Tailnas->nextas = curas;
<         curas->nextas = NULL;
<         Tailnas = curas;
<       }
---
>     nhemext = fhemext;
>     if (fhemext > (double)nhemext) {
>         pdis=ran1(Seed);
>         if ((fhemext - (double)nhemext) > pdis) nhemext++;
8040d7653
<   }
8042,8070c7655,7663
<   /*
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
< 
<   if (Verbose_flag > 2) fprintf(Logfile,"\nFinished processing nasulf list,
<   Count[DIFFSO4] = %d, Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]);
<   */
< 
<   /***
<    *    Now go through remainder of linked list and
<    *    reset the phase ids
<    ***/
< 
<   if (Headnas != Tailnas) {
<     curas = Headnas;
<     while (curas != NULL) {
<       curx = curas->x;
<       cury = curas->y;
<       curz = curas->z;
<       Mic[curx][cury][curz] = (NA2SO4);
<       curas = curas->nextas;
---
>     /*
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
8072d7664
<   }
8074,8083c7666,7667
<   /*
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
---
>     if (Verbose) printf("\nGetting ready to add DIFFSO4, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>     */
8085,8090c7669,7677
<   if (Verbose_flag > 2) {
<       fprintf(Logfile,"\nFinished resetting nasulf ids, Count[DIFFSO4] = %d,
<   Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
<   fprintf(Logfile,"\nEligible gypsum count = %d\n",gct);
<   }
<   */
---
>     nso4ext = (Discount[K2SO4] + Discount[NA2SO4]);
>     Count[DIFFGYP] += ngypext;
>     Count[DIFFANH] += nanhext;
>     Count[DIFFHEM] += nhemext;
>     Count[DIFFCH] += nchext;
>     Count[DIFFCSH] += ncshext;
>     Count[DIFFC3A] += nc3aext;
>     Count[DIFFC4A] += nc4aext;
>     Count[DIFFSO4] += nso4ext;
8092,8093c7679,7685
<   if ((ncshgo != 0) && (Verbose_flag > 2))
<     fprintf(Logfile, "CSH dissolved is %d \n", ncshgo);
---
>     nsum2 = nchext + ncshext;
>     nsum3 = nsum2 + nc3aext;
>     nsum4 = nsum3 + nc4aext;
>     nsum5 = nsum4 + ngypext;
>     nsum6 = nsum5 + nhemext;
>     nsum7 = nsum6 + nanhext;
>     nsum8 = nsum7 + nso4ext;
8095,8096c7687,7695
<   if ((npchext > 0) && (Verbose_flag > 2))
<     fprintf(Logfile, "Extra CH required is %d at cycle %d \n", npchext, cycle);
---
>     for (xext = 1; xext <= nsum8; xext++) {
>         plok = 0;
>         do {
>             xc = (int)((float)Xsyssize * ran1(Seed));
>             yc = (int)((float)Ysyssize * ran1(Seed));
>             zc = (int)((float)Zsyssize * ran1(Seed));
>             if (xc >= Xsyssize) xc = 0;
>             if (yc >= Ysyssize) yc = 0;
>             if (zc >= Zsyssize) zc = 0;
8098,8103c7697,7700
<   /***
<    *    Now add in the extra diffusing species for dissolution
<    *
<    *    Expansion factors from Young and Hansen and Mindess and
<    *    Young (Concrete)
<    ***/
---
>             if (Mic[xc][yc][zc] == POROSITY) {
>                 plok = 1;
>                 phid = DIFFCH;
>                 Count[POROSITY]--;
8105,8107c7702,7716
<   ncshext = cshrand;
<   if ((cshrand != 0) && (Verbose_flag > 2))
<     fprintf(Logfile, "cshrand is %d \n", cshrand);
---
>                 if (xext > nsum7){
>                     phid = DIFFSO4;
>                 } else if (xext > nsum6) {
>                     phid = DIFFANH;
>                 } else if (xext > nsum5) {
>                     phid = DIFFHEM;
>                 } else if (xext > nsum4){
>                     phid = DIFFGYP;
>                 } else if (xext > nsum3) {
>                     phid = DIFFC4A;
>                 } else if (xext > nsum2) {
>                     phid = DIFFC3A;
>                 } else if (xext > nchext) {
>                     phid = DIFFCSH;
>                 }
8109,8112c7718,7720
<   /***
<    *    Extra diffusing CH, Gypsum, C3A, and SO4 are added at totally random
<    *    locations, rather than at the dissolution site
<    ***/
---
>                 Mic[xc][yc][zc] = phid;
>                 Nmade++;
>                 Ngoing++;
8114,8116c7722,7725
<   fchext = (0.61 * (double)Discount[C3S]) + (0.191 * (double)Discount[C2S]) +
<            (0.2584 * (double)Discount[C4AF]) +
<            (0.954 * (double)Discount[FREELIME]);
---
>                 /***
>                 *    Allocate memory for this diffusing
>                 *    element in the doubly linked list
>                 ***/
8118,8123c7727,7732
<   nchext = fchext;
<   if (fchext > (double)nchext) {
<     pdis = ran1(Seed);
<     if ((fchext - (double)nchext) > pdis)
<       nchext++;
<   }
---
>                 antadd = (struct Ants *)malloc(Antsize);
>                 antadd->x = xc;
>                 antadd->y = yc;
>                 antadd->z = zc;
>                 antadd->id = phid;
>                 antadd->cycbirth = Cyccnt;
8125c7734,7737
<   nchext += npchext;
---
>                 /***
>                 *    Now connect this ant structure to end
>                 *    of linked list
>                 ***/
8127,8148c7739,7743
<   /***
<    *    Adjust CH addition for slag consumption and
<    *    nucleation of secondary gypsum from dissolved
<    *    alkali sulfates (8 June 2004)
<    ***/
< 
<   Slagcum += Discount[SLAG];
<   Chgone = (int)(P4slag * (float)Slagcum);
<   Slagcum -= (int)((float)Chgone / P4slag);
<   savechgone = Chgone;
<   Chgone = 0;
<   sulfavemolarv = (float)(Discount[K2SO4]) * Molarv[K2SO4];
<   sulfavemolarv += (float)(Discount[NA2SO4]) * Molarv[NA2SO4];
<   if (sulfavemolarv > 0.0) {
<     sulfavemolarv /= ((float)(Discount[K2SO4] + Discount[NA2SO4]));
<     Chgone = (int)((float)(Nucsulf2gyps)*Molarv[CH] / sulfavemolarv);
<     Nucsulf2gyps -= (int)(((float)Chgone) * sulfavemolarv / Molarv[CH]);
<   }
<   Chgone += savechgone;
<   nchext -= Chgone;
<   nchext -= DIFFCHdeficit;
<   DIFFCHdeficit = 0;
---
>                 antadd->prevant = Tailant;
>                 Tailant->nextant = antadd;
>                 antadd->nextant = NULL;
>                 Tailant = antadd;
>             }
8150,8153c7745
<   if (nchext < 0) {
<     DIFFCHdeficit -= nchext;
<     nchext = 0;
<   }
---
>         } while (!plok);
8155,8162c7747
<   fc3aext = (double)Discount[C3A] + (double)Discount[OC3A];
<   fc3aext += (0.5917 * (double)Discount[C3AH6]);
<   nc3aext = fc3aext + nslagc3a;
<   if (fc3aext > (double)nc3aext) {
<     pdis = ran1(Seed);
<     if ((fc3aext - (double)nc3aext) > pdis)
<       nc3aext++;
<   }
---
>     }        /* end of xext for extra species generation */
8164,8170c7749
<   fc4aext = 0.696 * (double)Discount[C4AF];
<   nc4aext = fc4aext;
<   if (fc4aext > (double)nc4aext) {
<     pdis = ran1(Seed);
<     if ((fc4aext - (double)nc4aext) > pdis)
<       nc4aext++;
<   }
---
>     /* Check that this worked out correctly */
8172c7751,7760
<   /* Both forms of GYPSUM form same DIFFGYP species */
---
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     /*
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
>     }
8174c7762,7763
<   ngypext = Discount[GYPSUM] + Discount[GYPSUMS];
---
>     if (Verbose) printf("\nFinished adding DIFFSO4, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>     */
8176,8184c7765,7776
<   /***
<    *    Convert to diffusing anhydrite at volume
<    *    necessary for final gypsum formation
<    *
<    *    (1 anhydrite --> 1.423 gypsum)
<    *
<    *    Since hemihydrate can now react with C3A, etc.,
<    *    can't do expansion here any longer  7/99
<    ***/
---
>     if (Verbose) {
>         printf("Dissolved- %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
>         Count[DIFFCSH],Count[DIFFCH],Count[DIFFGYP],Count[DIFFC3A],
>         Count[DIFFFH3],Count[DIFFETTR],Count[DIFFAS],
>         Count[DIFFCAS2],Count[DIFFCACL2],Count[DIFFCACO3],
>         Count[DIFFGYP],Count[DIFFHEM],Count[DIFFANH],Count[DIFFSO4]);
>     }
>     
>     /***
>     *    Measure of sulfate anions in solution, so add in DIFFSO4 species
>     *    created by dissolution of alkali sulfates (7 June 2004)
>     ***/
8186c7778
<   /*    fanhext = 1.423 * (float)Discount[ANHYDRITE]; */
---
>     Sulf_cur = Count[DIFFGYP] + Count[DIFFANH] + Count[DIFFHEM] + Count[DIFFSO4];
8188,8194c7780
<   fanhext = (double)Discount[ANHYDRITE];
<   nanhext = fanhext;
<   if (fanhext > (double)nanhext) {
<     pdis = ran1(Seed);
<     if ((fanhext - (double)nanhext) > pdis)
<       nanhext++;
<   }
---
>     /* If too many diffusing gypsums already in solution... */
8196,8204c7782,7792
<   /***
<    *    Convert to diffusing hemiydrate at volume necessary
<    *    for final gypsum formation
<    *
<    *    (1 hemihydrate --> 1.4 gypsum)
<    *
<    *    Since hemihydrate can now react with C3A, etc.,
<    *    can't do expansion here any longer  7/99
<    ***/
---
>     if (Sulf_cur > Dgypmax) {
>         Disprob[GYPSUM] = 0.0;
>         Disprob[ANHYDRITE] = 0.0;
>         Disprob[HEMIHYD] = 0.0;
>         Disprob[GYPSUMS]= 0.0;
>     } else {
>         Disprob[GYPSUM]=Disbase[GYPSUM];
>         Disprob[ANHYDRITE]=Disbase[ANHYDRITE];
>         Disprob[HEMIHYD]=Disbase[HEMIHYD];
>         Disprob[GYPSUMS]=Disbase[GYPSUMS];
>     }
8206c7794,7803
<   /*    fhemext=1.3955*(float)Discount[HEMIHYD];  */
---
>     Count[DIFFSO4] = Count[NA2SO4] = 0;
>     /*
>     for (k = 0; k < Zsyssize; k++) {
>         for (j = 0; j < Ysyssize; j++) {
>             for (i = 0; i < Xsyssize; i++) {
>                 if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
>                 if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
>             }
>         }
>     }
8208c7805,7810
<   fhemext = (double)Discount[HEMIHYD];
---
>     if (Verbose) {
>         printf("\nEnd of dissolve cycle, Count[DIFFSO4] = %d, Count[NA2SO4] = %d ...\n",Count[DIFFSO4],Count[NA2SO4]);
>         printf("C3AH6 dissolved- %d with prob. of %f \n",nhgd,Disprob[C3AH6]);
>     }
>     */
> }
8210,8215c7812,7831
<   nhemext = fhemext;
<   if (fhemext > (double)nhemext) {
<     pdis = ran1(Seed);
<     if ((fhemext - (double)nhemext) > pdis)
<       nhemext++;
<   }
---
> /***
> *    addrand
> *
> *     Add nneed one-pixel elements of phase randid at random
> *     locations in the microstructure
> *
> *     Arguments:    int phase id
> *                 int number to place
> *                 int flocculate (1) or not (0)
> *
> *     Returns:    nothing
> *
> *    Calls:        no other routines
> *    Called by:    main program
> ***/
> void addrand(int randid, int nneed, int onepixfloc)
> {
>     int success,ix,iy,iz,inc,dim,dir,newsite,oldval;
>     int ic;
>     float pc3a;
8217,8226c7833,7836
<   /*
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
---
>     /***
>     *    Add number of requested phase pixels at
>     *    random pore locations
>     ***/
8228,8231c7838,7839
<   if (Verbose_flag > 2) fprintf(Logfile,"\nGetting ready to add DIFFSO4,
<   Count[DIFFSO4] = %d, Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]);
<   */
---
>     for(ic = 1; ic <= nneed; ic++) {
>         success = 0;
8233,8241c7841
<   nso4ext = (Discount[K2SO4] + Discount[NA2SO4]);
<   Count[DIFFGYP] += ngypext;
<   Count[DIFFANH] += nanhext;
<   Count[DIFFHEM] += nhemext;
<   Count[DIFFCH] += nchext;
<   Count[DIFFCSH] += ncshext;
<   Count[DIFFC3A] += nc3aext;
<   Count[DIFFC4A] += nc4aext;
<   Count[DIFFSO4] += nso4ext;
---
>         while (!success) {
8243,8249c7843,7845
<   nsum2 = nchext + ncshext;
<   nsum3 = nsum2 + nc3aext;
<   nsum4 = nsum3 + nc4aext;
<   nsum5 = nsum4 + ngypext;
<   nsum6 = nsum5 + nhemext;
<   nsum7 = nsum6 + nanhext;
<   nsum8 = nsum7 + nso4ext;
---
>             ix=(int)((float)Xsyssize*ran1(Seed));
>             iy=(int)((float)Ysyssize*ran1(Seed));
>             iz=(int)((float)Zsyssize*ran1(Seed));
8251,8262c7847,7849
<   for (xext = 1; xext <= nsum8; xext++) {
<     plok = 0;
<     do {
<       xc = (int)((float)Xsyssize * ran1(Seed));
<       yc = (int)((float)Ysyssize * ran1(Seed));
<       zc = (int)((float)Zsyssize * ran1(Seed));
<       if (xc >= Xsyssize)
<         xc = 0;
<       if (yc >= Ysyssize)
<         yc = 0;
<       if (zc >= Zsyssize)
<         zc = 0;
---
>             if (ix == Xsyssize) ix = 0;
>             if (iy == Ysyssize) iy = 0;
>             if (iz == Zsyssize) iz = 0;
8264,8267c7851,7870
<       if (Mic[xc][yc][zc] == POROSITY) {
<         plok = 1;
<         phid = DIFFCH;
<         Count[POROSITY]--;
---
>             if (Mic[ix][iy][iz] == POROSITY || Mic[ix][iy][iz] == CRACKP) {
>                 oldval = Mic[ix][iy][iz];
>                 Mic[ix][iy][iz] = randid;
>                 Micorig[ix][iy][iz] = randid;
>                 if (randid == C3A) {
>                     pc3a = ran1(Seed);
>                     if (pc3a < Oc3afrac) {
>                         Mic[ix][iy][iz] = OC3A;
>                         Micorig[ix][iy][iz] = OC3A;
>                     }
>                 }
>                 success = 1;
>                 if (onepixfloc == 1) {
>                     /***
>                      * Flocculate this particle to a nearby surface
>                      * Pic a random direction to fly
>                      ***/
>                      dim=(int)(3.0*ran1(Seed));
>                      dir=(int)(2.0*ran1(Seed));
>                      inc = (dir == 0) ? 1 : -1;
8269,8282c7872,7928
<         if (xext > nsum7) {
<           phid = DIFFSO4;
<         } else if (xext > nsum6) {
<           phid = DIFFANH;
<         } else if (xext > nsum5) {
<           phid = DIFFHEM;
<         } else if (xext > nsum4) {
<           phid = DIFFGYP;
<         } else if (xext > nsum3) {
<           phid = DIFFC4A;
<         } else if (xext > nsum2) {
<           phid = DIFFC3A;
<         } else if (xext > nchext) {
<           phid = DIFFCSH;
---
>                      switch (dim) {
>                         case 0:           /* X-direction flight */
>                             newsite = ix + inc;
>                             newsite += checkbc(newsite,Xsyssize);     
>                             while ((newsite != ix) && ((Mic[newsite][iy][iz] == POROSITY)
>                                     || (Mic[newsite][iy][iz] == CRACKP))) {
>                                 newsite += inc;
>                                 newsite += checkbc(newsite,Xsyssize);
>                             }
>                             if (newsite != ix) {
>                                 newsite -= inc;
>                                 newsite += checkbc(newsite,Xsyssize);
>                                 Mic[newsite][iy][iz] = Mic[ix][iy][iz];
>                                 Micorig[newsite][iy][iz] = Micorig[ix][iy][iz];
>                                 Mic[ix][iy][iz] = oldval;
>                                 Micorig[ix][iy][iz] = oldval;
>                             }
>                             break;
>                         case 1:           /* Y-direction flight */
>                             newsite = iy + inc;
>                             newsite += checkbc(newsite,Ysyssize);     
>                             while ((newsite != iy) && ((Mic[ix][newsite][iz] == POROSITY)
>                                     || (Mic[ix][newsite][iz] == CRACKP))) {
>                                 newsite += inc;
>                                 newsite += checkbc(newsite,Ysyssize);
>                             }
>                             if (newsite != iy) {
>                                 newsite -= inc;
>                                 newsite += checkbc(newsite,Ysyssize);
>                                 Mic[ix][newsite][iz] = Mic[ix][iy][iz];
>                                 Micorig[ix][newsite][iz] = Micorig[ix][iy][iz];
>                                 Mic[ix][iy][iz] = oldval;
>                                 Micorig[ix][iy][iz] = oldval;
>                             }
>                             break;
>                         case 2:           /* Z-direction flight */
>                             newsite = iz + inc;
>                             newsite += checkbc(newsite,Zsyssize);     
>                             while ((newsite != iz) && ((Mic[ix][iy][newsite] == POROSITY)
>                                     || (Mic[ix][iy][newsite] == CRACKP))) {
>                                 newsite += inc;
>                                 newsite += checkbc(newsite,Zsyssize);
>                             }
>                             if (newsite != iz) {
>                                 newsite -= inc;
>                                 newsite += checkbc(newsite,Zsyssize);
>                                 Mic[ix][iy][newsite] = Mic[ix][iy][iz];
>                                 Micorig[ix][iy][newsite] = Micorig[ix][iy][iz];
>                                 Mic[ix][iy][iz] = oldval;
>                                 Micorig[ix][iy][iz] = oldval;
>                              }
>                              break;
>                          case 3:         /* Do nothing */
>                             break;
>                     } 
>                 }
>             }
8283a7930,7931
>     }
> }
8285,8287c7933,7951
<         Mic[xc][yc][zc] = phid;
<         Nmade++;
<         Ngoing++;
---
> /***
> *    addseeds
> *
> *     Displace one half of the microstructure a set number
> *     of pixels, leaving a crack-like strip down the 
> *     center of the image
> *     
> *     Arguments:  Phase id of seeds to add
> *                 Probability of a pore pixel converting to a seed
> *
> *     Returns:    nothing
> *
> *    Calls:        no other routines
> *    Called by:    main program
> ***/
> void addseeds(int phid, float prob)
> {
>     register int i,j,k;
>     float pcomp;
8289,8292c7953,7964
<         /***
<          *    Allocate memory for this diffusing
<          *    element in the doubly linked list
<          ***/
---
>     if (prob > 1.0e-10) {
>         for (k = 0; k < Zsyssize; k++) {
>             for (j = 0; j < Ysyssize; j++) {
>                 for (i = 0; i < Xsyssize; i++) {
>                     if (Mic[i][j][k] == POROSITY) {
>                         pcomp = ran1(Seed);
>                         if (pcomp < prob) Mic[i][j][k] = phid;   
>                     }
>                 }
>             }
>         }
>     }
8294,8299c7966,7967
<         antadd = (struct Ants *)malloc(Antsize);
<         antadd->x = xc;
<         antadd->y = yc;
<         antadd->z = zc;
<         antadd->id = phid;
<         antadd->cycbirth = Cyccnt;
---
>     return;
> }
8301,8304c7969,7987
<         /***
<          *    Now connect this ant structure to end
<          *    of linked list
<          ***/
---
> /***
> *    addcrack
> *
> *     Displace one half of the microstructure a set number
> *     of pixels, leaving a crack-like strip down the 
> *     center of the image
> *     
> *     Arguments:    None
> *
> *     Returns:    nothing
> *
> *    Calls:        no other routines
> *    Called by:    main program
> ***/
> void addcrack(void)
> {
>     register int i,j,k;
>     int start;
>     struct Ants *ant;
8306,8310c7989
<         antadd->prevant = Tailant;
<         Tailant->nextant = antadd;
<         antadd->nextant = NULL;
<         Tailant = antadd;
<       }
---
>     ant = Headant;
8312c7991,8002
<     } while (!plok);
---
>     /***
>     *    Two tasks must be performed here.  First of all,
>     *    we must displace all the actual pixels.  Then we must
>     *    update the positions of all the diffusing species
>     *
>     *    All crack space is added as phase CRACKP instead of
>     *    as simply saturated porosity, to allow differentiation
>     *    in the way global properties, like maximum number
>     *    of diffusing species, are computed.
>     *
>     *    (24 May 2004)
>     ***/
8314c8004
<   } /* end of xext for extra species generation */
---
>     switch (Crackorient) {
8316c8006
<   /* Check that this worked out correctly */
---
>         case 1:        /* Crack in x direction (yz plane) */
8318,8327c8008
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   /*
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
---
>             if (Verbose) printf("\n\t\tCracking in yz plane...");
8329,8332c8010
<   if (Verbose_flag > 2) fprintf(Logfile,"\nFinished adding DIFFSO4,
<   Count[DIFFSO4] = %d, Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]);
<   */
---
>             start = (Xsyssize / 2) - 1;
8334,8340c8012,8018
<   if (Verbose_flag > 2) {
<     fprintf(Logfile, "Dissolved- %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
<             Count[DIFFCSH], Count[DIFFCH], Count[DIFFGYP], Count[DIFFC3A],
<             Count[DIFFFH3], Count[DIFFETTR], Count[DIFFAS], Count[DIFFCAS2],
<             Count[DIFFCACL2], Count[DIFFCACO3], Count[DIFFGYP], Count[DIFFHEM],
<             Count[DIFFANH], Count[DIFFSO4]);
<   }
---
>             for (i = Xsyssize - 1; i > start; i--) {
>                 for (j = 0; j < Ysyssize; j++) {
>                     for (k = 0; k < Zsyssize; k++) {
>                         Mic[i + Crackwidth][j][k] = Mic[i][j][k];
>                         Micpart[i + Crackwidth][j][k] = Micpart[i][j][k];
>                         Cshage[i + Crackwidth][j][k] = Cshage[i][j][k];
>                         Deactivated[i + Crackwidth][j][k] = Deactivated[i][j][k];
8342,8345c8020,8029
<   /***
<    *    Measure of sulfate anions in solution, so add in DIFFSO4 species
<    *    created by dissolution of alkali sulfates (7 June 2004)
<    ***/
---
>                         if (i <= start + Crackwidth) {
>                             Mic[i][j][k] = CRACKP;
>                             Count[CRACKP]++;
>                             Micpart[i][j][k] = 0;
>                             Cshage[i][j][k] = 0;
>                             Deactivated[i][j][k] = 1;
>                         }
>                     }
>                 }
>             }
8347c8031,8033
<   Sulf_cur = Count[DIFFGYP] + Count[DIFFANH] + Count[DIFFHEM] + Count[DIFFSO4];
---
>             /***
>             *    Microstructure is displaced, now move all the ants
>             ***/
8349c8035,8038
<   /* If too many diffusing gypsums already in solution... */
---
>             while (ant != NULL) {
>                 if (ant->x > start) ant->x += Crackwidth;
>                 ant = ant->nextant;
>             }
8351,8361c8040
<   if (Sulf_cur > Dgypmax) {
<     Disprob[GYPSUM] = 0.0;
<     Disprob[ANHYDRITE] = 0.0;
<     Disprob[HEMIHYD] = 0.0;
<     Disprob[GYPSUMS] = 0.0;
<   } else {
<     Disprob[GYPSUM] = Disbase[GYPSUM];
<     Disprob[ANHYDRITE] = Disbase[ANHYDRITE];
<     Disprob[HEMIHYD] = Disbase[HEMIHYD];
<     Disprob[GYPSUMS] = Disbase[GYPSUMS];
<   }
---
>             /*** Finally, change the x dimension ***/
8363,8372c8042
<   Count[DIFFSO4] = Count[NA2SO4] = 0;
<   /*
<   for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<           for (i = 0; i < Xsyssize; i++) {
<               if (Mic[i][j][k] == (DIFFSO4)) Count[DIFFSO4]++;
<               if (Mic[i][j][k] == (NA2SO4)) Count[NA2SO4]++;
<           }
<       }
<   }
---
>             Xsyssize += Crackwidth;
8374,8381c8044,8046
<   if (Verbose_flag > 1) {
<       fprintf(Logfile,"\nEnd of dissolve cycle, Count[DIFFSO4] = %d,
<   Count[NA2SO4] = %d
<   ...\n",Count[DIFFSO4],Count[NA2SO4]); fprintf(Logfile,"C3AH6 dissolved- %d
<   with prob. of %f \n",nhgd,Disprob[C3AH6]);
<   }
<   */
< }
---
>             break;
>         
>         case 2:        /* Crack in y direction (xz plane) */
8383,8401c8048
< /***
<  *    addrand
<  *
<  *     Add nneed one-pixel elements of phase randid at random
<  *     locations in the microstructure
<  *
<  *     Arguments:    int phase id
<  *                 int number to place
<  *                 int flocculate (1) or not (0)
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        no other routines
<  *    Called by:    main program
<  ***/
< void addrand(int randid, int nneed, int onepixfloc) {
<   int success, ix, iy, iz, inc, dim, dir, newsite, oldval;
<   int ic;
<   float pc3a;
---
>             if (Verbose) printf("\n\t\tCracking in xz plane...");
8403,8406c8050
<   /***
<    *    Add number of requested phase pixels at
<    *    random pore locations
<    ***/
---
>             start = (Ysyssize / 2) - 1;
8408,8409c8052,8058
<   for (ic = 1; ic <= nneed; ic++) {
<     success = 0;
---
>             for (j = Ysyssize - 1; j > start; j--) {
>                 for (i = 0; i < Xsyssize; i++) {
>                     for (k = 0; k < Zsyssize; k++) {
>                         Mic[i][j + Crackwidth][k] = Mic[i][j][k];
>                         Micpart[i][j + Crackwidth][k] = Micpart[i][j][k];
>                         Cshage[i][j + Crackwidth][k] = Cshage[i][j][k];
>                         Deactivated[i][j + Crackwidth][k] = Deactivated[i][j][k];
8411c8060,8069
<     while (!success) {
---
>                         if (j <= start + Crackwidth) {
>                             Mic[i][j][k] = CRACKP;
>                             Count[CRACKP]++;
>                             Micpart[i][j][k] = 0;
>                             Cshage[i][j][k] = 0;
>                             Deactivated[i][j][k] = 1;
>                         }
>                     }
>                 }
>             }
8413,8422c8071,8073
<       ix = (int)((float)Xsyssize * ran1(Seed));
<       iy = (int)((float)Ysyssize * ran1(Seed));
<       iz = (int)((float)Zsyssize * ran1(Seed));
< 
<       if (ix == Xsyssize)
<         ix = 0;
<       if (iy == Ysyssize)
<         iy = 0;
<       if (iz == Zsyssize)
<         iz = 0;
---
>             /***
>             *    Microstructure is displaced, now move all the ants
>             ***/
8424,8452c8075,8077
<       if (Mic[ix][iy][iz] == POROSITY || Mic[ix][iy][iz] == CRACKP) {
<         oldval = Mic[ix][iy][iz];
<         Mic[ix][iy][iz] = randid;
<         Micorig[ix][iy][iz] = randid;
<         if (randid == C3A) {
<           pc3a = ran1(Seed);
<           if (pc3a < Oc3afrac) {
<             Mic[ix][iy][iz] = OC3A;
<             Micorig[ix][iy][iz] = OC3A;
<           }
<         }
<         success = 1;
<         if (onepixfloc == 1) {
<           /***
<            * Flocculate this particle to a nearby surface
<            * Pic a random direction to fly
<            ***/
<           dim = (int)(3.0 * ran1(Seed));
<           dir = (int)(2.0 * ran1(Seed));
<           inc = (dir == 0) ? 1 : -1;
< 
<           switch (dim) {
<           case 0: /* X-direction flight */
<             newsite = ix + inc;
<             newsite += checkbc(newsite, Xsyssize);
<             while ((newsite != ix) && ((Mic[newsite][iy][iz] == POROSITY) ||
<                                        (Mic[newsite][iy][iz] == CRACKP))) {
<               newsite += inc;
<               newsite += checkbc(newsite, Xsyssize);
---
>             if (Verbose) {
>                 printf("\n\t\t\tPreparing to move ants now ...");
>                 fflush(stdout);
8454,8460c8079,8081
<             if (newsite != ix) {
<               newsite -= inc;
<               newsite += checkbc(newsite, Xsyssize);
<               Mic[newsite][iy][iz] = Mic[ix][iy][iz];
<               Micorig[newsite][iy][iz] = Micorig[ix][iy][iz];
<               Mic[ix][iy][iz] = oldval;
<               Micorig[ix][iy][iz] = oldval;
---
>             while (ant != NULL) {
>                 if (ant->y > start) ant->y += Crackwidth;
>                 ant = ant->nextant;
8462,8469c8083,8085
<             break;
<           case 1: /* Y-direction flight */
<             newsite = iy + inc;
<             newsite += checkbc(newsite, Ysyssize);
<             while ((newsite != iy) && ((Mic[ix][newsite][iz] == POROSITY) ||
<                                        (Mic[ix][newsite][iz] == CRACKP))) {
<               newsite += inc;
<               newsite += checkbc(newsite, Ysyssize);
---
>             if (Verbose) {
>                 printf(" done");
>                 fflush(stdout);
8471,8504d8086
<             if (newsite != iy) {
<               newsite -= inc;
<               newsite += checkbc(newsite, Ysyssize);
<               Mic[ix][newsite][iz] = Mic[ix][iy][iz];
<               Micorig[ix][newsite][iz] = Micorig[ix][iy][iz];
<               Mic[ix][iy][iz] = oldval;
<               Micorig[ix][iy][iz] = oldval;
<             }
<             break;
<           case 2: /* Z-direction flight */
<             newsite = iz + inc;
<             newsite += checkbc(newsite, Zsyssize);
<             while ((newsite != iz) && ((Mic[ix][iy][newsite] == POROSITY) ||
<                                        (Mic[ix][iy][newsite] == CRACKP))) {
<               newsite += inc;
<               newsite += checkbc(newsite, Zsyssize);
<             }
<             if (newsite != iz) {
<               newsite -= inc;
<               newsite += checkbc(newsite, Zsyssize);
<               Mic[ix][iy][newsite] = Mic[ix][iy][iz];
<               Micorig[ix][iy][newsite] = Micorig[ix][iy][iz];
<               Mic[ix][iy][iz] = oldval;
<               Micorig[ix][iy][iz] = oldval;
<             }
<             break;
<           case 3: /* Do nothing */
<             break;
<           }
<         }
<       }
<     }
<   }
< }
8506,8523c8088
< /***
<  *    addseeds
<  *
<  *     Displace one half of the microstructure a set number
<  *     of pixels, leaving a crack-like strip down the
<  *     center of the image
<  *
<  *     Arguments:  Phase id of seeds to add
<  *                 Probability of a pore pixel converting to a seed
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        no other routines
<  *    Called by:    main program
<  ***/
< void addseeds(int phid, float prob) {
<   register int i, j, k;
<   float pcomp;
---
>             /*** Finally, change the y dimension ***/
8525,8537c8090
<   if (prob > 1.0e-10) {
<     for (k = 0; k < Zsyssize; k++) {
<       for (j = 0; j < Ysyssize; j++) {
<         for (i = 0; i < Xsyssize; i++) {
<           if (Mic[i][j][k] == POROSITY) {
<             pcomp = ran1(Seed);
<             if (pcomp < prob)
<               Mic[i][j][k] = phid;
<           }
<         }
<       }
<     }
<   }
---
>             Ysyssize += Crackwidth;
8539,8540c8092,8094
<   return;
< }
---
>             break;
>         
>         case 3:        /* Crack in z direction (xy plane) */
8542,8559c8096
< /***
<  *    addcrack
<  *
<  *     Displace one half of the microstructure a set number
<  *     of pixels, leaving a crack-like strip down the
<  *     center of the image
<  *
<  *     Arguments:    None
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        no other routines
<  *    Called by:    main program
<  ***/
< void addcrack(void) {
<   register int i, j, k;
<   int start;
<   struct Ants *ant;
---
>             if (Verbose) printf("\n\t\tCracking in xy plane...");
8561c8098
<   ant = Headant;
---
>             start = (Zsyssize / 2) - 1;
8563,8574c8100,8106
<   /***
<    *    Two tasks must be performed here.  First of all,
<    *    we must displace all the actual pixels.  Then we must
<    *    update the positions of all the diffusing species
<    *
<    *    All crack space is added as phase CRACKP instead of
<    *    as simply saturated porosity, to allow differentiation
<    *    in the way global properties, like maximum number
<    *    of diffusing species, are computed.
<    *
<    *    (24 May 2004)
<    ***/
---
>             for (k = Zsyssize - 1; k > start; k--) {
>                 for (i = 0; i < Xsyssize; i++) {
>                     for (j = 0; j < Ysyssize; j++) {
>                         Mic[i][j][k + Crackwidth] = Mic[i][j][k];
>                         Micpart[i][j][k + Crackwidth] = Micpart[i][j][k];
>                         Cshage[i][j][k + Crackwidth] = Cshage[i][j][k];
>                         Deactivated[i][j][k + Crackwidth] = Deactivated[i][j][k];
8576c8108,8117
<   switch (Crackorient) {
---
>                         if (k <= start + Crackwidth) {
>                             Mic[i][j][k] = CRACKP;
>                             Count[CRACKP]++;
>                             Micpart[i][j][k] = 0;
>                             Cshage[i][j][k] = 0;
>                             Deactivated[i][j][k] = 1;
>                         }
>                     }
>                 }
>             }
8578c8119,8121
<   case 1: /* Crack in x direction (yz plane) */
---
>             /***
>             *    Microstructure is displaced, now move all the ants
>             ***/
8580,8581c8123,8126
<     if (Verbose_flag > 1)
<       fprintf(Logfile, "\n\t\tCracking in yz plane...");
---
>             while (ant != NULL) {
>                 if (ant->z > start) ant->z += Crackwidth;
>                 ant = ant->nextant;
>             }
8583c8128
<     start = (Xsyssize / 2) - 1;
---
>             /*** Finally, change the z dimension ***/
8585,8591c8130,8131
<     for (i = Xsyssize - 1; i > start; i--) {
<       for (j = 0; j < Ysyssize; j++) {
<         for (k = 0; k < Zsyssize; k++) {
<           Mic[i + Crackwidth][j][k] = Mic[i][j][k];
<           Micpart[i + Crackwidth][j][k] = Micpart[i][j][k];
<           Cshage[i + Crackwidth][j][k] = Cshage[i][j][k];
<           Deactivated[i + Crackwidth][j][k] = Deactivated[i][j][k];
---
>             Zsyssize += Crackwidth;
>             break;
8593,8601c8133,8135
<           if (i <= start + Crackwidth) {
<             Mic[i][j][k] = CRACKP;
<             Count[CRACKP]++;
<             Micpart[i][j][k] = 0;
<             Cshage[i][j][k] = 0;
<             Deactivated[i][j][k] = 1;
<           }
<         }
<       }
---
>         default:
>             break;
>         
8604,8606c8138,8139
<     /***
<      *    Microstructure is displaced, now move all the ants
<      ***/
---
>     return;
> }
8608,8612c8141,8156
<     while (ant != NULL) {
<       if (ant->x > start)
<         ant->x += Crackwidth;
<       ant = ant->nextant;
<     }
---
> /***
> *    calcT
> *
> *     Calculate temperature of binder and aggregate
> *     
> *     Arguments:    double mass of solid
> *
> *     Returns:    nothing
> *
> *    Calls:        no other routines
> *    Called by:    main program
> ***/
> void calcT(double mass)
> {
>     float dg = Heat_cf * (Heat_new - Heat_old);
>     float dTb,dTbam,dTagg,fact,dampen,Tao,Tbo;
8614c8158,8162
<     /*** Finally, change the x dimension ***/
---
>     Tbo = Temp_cur_b;
>     Tao = Temp_cur_agg;
>     dTb = dTagg = 0.0;
>     dampen = 1.0;
>     fact = 1.0;
8616,8641c8164,8178
<     Xsyssize += Crackwidth;
< 
<     break;
< 
<   case 2: /* Crack in y direction (xz plane) */
< 
<     if (Verbose_flag > 1)
<       fprintf(Logfile, "\n\t\tCracking in xz plane...");
< 
<     start = (Ysyssize / 2) - 1;
< 
<     for (j = Ysyssize - 1; j > start; j--) {
<       for (i = 0; i < Xsyssize; i++) {
<         for (k = 0; k < Zsyssize; k++) {
<           Mic[i][j + Crackwidth][k] = Mic[i][j][k];
<           Micpart[i][j + Crackwidth][k] = Micpart[i][j][k];
<           Cshage[i][j + Crackwidth][k] = Cshage[i][j][k];
<           Deactivated[i][j + Crackwidth][k] = Deactivated[i][j][k];
< 
<           if (j <= start + Crackwidth) {
<             Mic[i][j][k] = CRACKP;
<             Count[CRACKP]++;
<             Micpart[i][j][k] = 0;
<             Cshage[i][j][k] = 0;
<             Deactivated[i][j][k] = 1;
<           }
---
>     if (AggTempEffect == 1) {
>         if ((mass * Cp_b) > (Mass_agg * Cp_agg)) {
>             do {
>                 fact = dampen * Time_step * U_coeff_agg / (Mass_agg * Cp_agg);
>                 dTagg = -(Tao - Tbo) * fact;
>                 dTb = -(Mass_agg * Cp_agg * dTagg) / (mass * Cp_b);
>                 dampen *= 0.75;
>             } while ((Tao-Tbo)*((Tao+dTagg)-(Tbo+dTb)) < 0.0);
>         } else {
>             do {
>                 fact = dampen * Time_step * U_coeff_agg / (mass * Cp_b);
>                 dTb = -(Tbo - Tao) * fact;
>                 dTagg = -(mass * Cp_b * dTb) / (Mass_agg * Cp_agg);
>                 dampen *= 0.75;
>             } while ((Tao-Tbo)*((Tao+dTagg)-(Tbo+dTb)) < 0.0);
8643,8644d8179
<       }
<     }
8646,8691c8181,8186
<     /***
<      *    Microstructure is displaced, now move all the ants
<      ***/
< 
<     if (Verbose_flag > 2) {
<       fprintf(Logfile, "\n\t\t\tPreparing to move ants now ...");
<       fflush(Logfile);
<     }
<     while (ant != NULL) {
<       if (ant->y > start)
<         ant->y += Crackwidth;
<       ant = ant->nextant;
<     }
<     if (Verbose_flag > 2) {
<       fprintf(Logfile, " done");
<       fflush(Logfile);
<     }
< 
<     /*** Finally, change the y dimension ***/
< 
<     Ysyssize += Crackwidth;
< 
<     break;
< 
<   case 3: /* Crack in z direction (xy plane) */
< 
<     if (Verbose_flag > 1)
<       fprintf(Logfile, "\n\t\tCracking in xy plane...");
< 
<     start = (Zsyssize / 2) - 1;
< 
<     for (k = Zsyssize - 1; k > start; k--) {
<       for (i = 0; i < Xsyssize; i++) {
<         for (j = 0; j < Ysyssize; j++) {
<           Mic[i][j][k + Crackwidth] = Mic[i][j][k];
<           Micpart[i][j][k + Crackwidth] = Micpart[i][j][k];
<           Cshage[i][j][k + Crackwidth] = Cshage[i][j][k];
<           Deactivated[i][j][k + Crackwidth] = Deactivated[i][j][k];
< 
<           if (k <= start + Crackwidth) {
<             Mic[i][j][k] = CRACKP;
<             Count[CRACKP]++;
<             Micpart[i][j][k] = 0;
<             Cshage[i][j][k] = 0;
<             Deactivated[i][j][k] = 1;
<           }
---
>         Temp_cur_b += (dTb + (mass * dg /Cp_b));
>         dTbam = -((Temp_cur_b - T_ambient) * Time_step * U_coeff / Cp_b);
>         if (fabs(dTbam) >= fabs(Temp_cur_b-T_ambient)) {
>             Temp_cur_b = T_ambient;
>         } else {
>             Temp_cur_b += dTbam;
8693,8694c8188,8191
<       }
<     }
---
>         Temp_cur_agg += dTagg;
>         Temp_0 = Temp_cur_b;
>         Temp_0_agg = Temp_cur_agg;
>         if (fabs(Temp_0 - Temp_0_agg) <= 0.5) AggTempEffect = 0;
8696,8747d8192
<     /***
<      *    Microstructure is displaced, now move all the ants
<      ***/
< 
<     while (ant != NULL) {
<       if (ant->z > start)
<         ant->z += Crackwidth;
<       ant = ant->nextant;
<     }
< 
<     /*** Finally, change the z dimension ***/
< 
<     Zsyssize += Crackwidth;
<     break;
< 
<   default:
<     break;
<   }
< 
<   return;
< }
< 
< /***
<  *    calcT
<  *
<  *     Calculate temperature of binder and aggregate
<  *
<  *     Arguments:    double mass of solid
<  *
<  *     Returns:    nothing
<  *
<  *    Calls:        no other routines
<  *    Called by:    main program
<  ***/
< void calcT(double mass) {
<   float dg = Heat_cf * (Heat_new - Heat_old);
<   float dTb, dTbam, dTagg, fact, dampen, Tao, Tbo;
< 
<   Tbo = Temp_cur_b;
<   Tao = Temp_cur_agg;
<   dTb = dTagg = 0.0;
<   dampen = 1.0;
<   fact = 1.0;
< 
<   if (AggTempEffect == 1) {
<     if ((mass * Cp_b) > (Mass_agg * Cp_agg)) {
<       do {
<         fact = dampen * Time_step * U_coeff_agg / (Mass_agg * Cp_agg);
<         dTagg = -(Tao - Tbo) * fact;
<         dTb = -(Mass_agg * Cp_agg * dTagg) / (mass * Cp_b);
<         dampen *= 0.75;
<       } while ((Tao - Tbo) * ((Tao + dTagg) - (Tbo + dTb)) < 0.0);
8749,8754c8194,8201
<       do {
<         fact = dampen * Time_step * U_coeff_agg / (mass * Cp_b);
<         dTb = -(Tbo - Tao) * fact;
<         dTagg = -(mass * Cp_b * dTb) / (Mass_agg * Cp_agg);
<         dampen *= 0.75;
<       } while ((Tao - Tbo) * ((Tao + dTagg) - (Tbo + dTb)) < 0.0);
---
>         Temp_cur_b += (dTb + (mass * dg /Cp_b));
>         dTbam = -((Temp_cur_b - T_ambient) * Time_step * U_coeff / Cp_b);
>         if (fabs(dTbam) >= fabs(Temp_cur_b-T_ambient)) {
>             Temp_cur_b = T_ambient;
>         } else {
>             Temp_cur_b += dTbam;
>         }
>         Temp_0 = Temp_0_agg = Temp_cur_agg = Temp_cur_b;
8757,8768c8204,8211
<     Temp_cur_b += (dTb + (mass * dg / Cp_b));
<     dTbam = -((Temp_cur_b - T_ambient) * Time_step * U_coeff / Cp_b);
<     if (fabs(dTbam) >= fabs(Temp_cur_b - T_ambient)) {
<       Temp_cur_b = T_ambient;
<     } else {
<       Temp_cur_b += dTbam;
<     }
<     Temp_cur_agg += dTagg;
<     Temp_0 = Temp_cur_b;
<     Temp_0_agg = Temp_cur_agg;
<     if (fabs(Temp_0 - Temp_0_agg) <= 0.5)
<       AggTempEffect = 0;
---
> /*
>     printf("\nIN CALCT:  AggTempEffect = %d",AggTempEffect);
>     printf("\n\tMass = %f\tMass_agg = %f\n\tCp_b = %f\tCp_agg = %f",mass,Mass_agg,Cp_b,Cp_agg);
>     printf("\n\tTbo = %f\tTao = %f\n\tdtime = %f\tfact = %f",Tbo,Tao,Time_step,fact);
>     printf("\n\tdg = %f\tdTagg = %f\tdTb = %f",dg,dTagg,dTb);
>     printf("\n\tTemp_cur_b = %f\tTemp_cur_agg = %f",Temp_cur_b,Temp_cur_agg);
>     printf("\n\tU_coeff = %f\tU_coeff_agg = %f\n",U_coeff,U_coeff_agg);
> */
8770,8792c8213
<   } else {
<     Temp_cur_b += (dTb + (mass * dg / Cp_b));
<     dTbam = -((Temp_cur_b - T_ambient) * Time_step * U_coeff / Cp_b);
<     if (fabs(dTbam) >= fabs(Temp_cur_b - T_ambient)) {
<       Temp_cur_b = T_ambient;
<     } else {
<       Temp_cur_b += dTbam;
<     }
<     Temp_0 = Temp_0_agg = Temp_cur_agg = Temp_cur_b;
<   }
< 
<   /*
<       fprintf(Logfile,"\nIN CALCT:  AggTempEffect = %d",AggTempEffect);
<       fprintf(Logfile,"\n\tMass = %f\tMass_agg = %f\n\tCp_b = %f\tCp_agg =
<      %f",mass,Mass_agg,Cp_b,Cp_agg); fprintf(Logfile,"\n\tTbo = %f\tTao =
<      %f\n\tdtime = %f\tfact = %f",Tbo,Tao,Time_step,fact);
<      fprintf(Logfile,"\n\tdg = %f\tdTagg = %f\tdTb = %f",dg,dTagg,dTb);
<      fprintf(Logfile,"\n\tTemp_cur_b = %f\tTemp_cur_agg =
<      %f",Temp_cur_b,Temp_cur_agg); fprintf(Logfile,"\n\tU_coeff =
<      %f\tU_coeff_agg = %f\n",U_coeff,U_coeff_agg);
<   */
< 
<   return;
---
>     return;
8796,8818c8217,8234
<  *    measuresurf
<  *
<  *    Releases all dynamically allocated memory for this
<  *    program.
<  *
<  *    SHOULD ONLY BE CALLED IF ALL MEMORY HAS ALREADY BEEN
<  *    DYNAMICALLY ALLOCATED
<  *
<  *    Arguments:    None
<  *    Returns:    Nothing
<  *
<  *    Calls:        free_ccube, free_sicube
<  *    Called by:    main,dissolve
<  *
<  ***/
< void measuresurf(void) {
<   int kx, ky, kz, jx, jy, jz, faceid;
< 
<   jx = jy = jz = 0;
<   for (kx = 0; kx < Xsyssize; kx++) {
<     for (ky = 0; ky < Ysyssize; ky++) {
<       for (kz = 0; kz < Zsyssize; kz++) {
<         if (Mic[kx][ky][kz] == POROSITY) {
---
> *    measuresurf
> *
> *    Releases all dynamically allocated memory for this
> *    program.
> *
> *    SHOULD ONLY BE CALLED IF ALL MEMORY HAS ALREADY BEEN
> *    DYNAMICALLY ALLOCATED
> *
> *    Arguments:    None
> *    Returns:    Nothing
> *
> *    Calls:        free_ccube, free_sicube
> *    Called by:    main,dissolve
> *
> ***/
> void measuresurf(void)
> {    
>     int kx,ky,kz,jx,jy,jz,faceid;
8820,8866c8236,8240
<           for (faceid = 0; faceid < 6; faceid++) {
<             switch (faceid) {
<             case 0:
<               jx = kx + 1;
<               if (jx > (Xsyssize - 1))
<                 jx = 0;
<               jy = ky;
<               jz = kz;
<               break;
<             case 1:
<               jx = kx - 1;
<               if (jx < 0)
<                 jx = Xsyssize - 1;
<               jy = ky;
<               jz = kz;
<               break;
<             case 2:
<               jy = ky + 1;
<               if (jy > (Ysyssize - 1))
<                 jy = 0;
<               jx = kx;
<               jz = kz;
<               break;
<             case 3:
<               jy = ky - 1;
<               if (jy < 0)
<                 jy = Ysyssize - 1;
<               jx = kx;
<               jz = kz;
<               break;
<             case 4:
<               jz = ky + 1;
<               if (jz > (Zsyssize - 1))
<                 jz = 0;
<               jx = kx;
<               jy = ky;
<               break;
<             case 5:
<               jz = ky - 1;
<               if (jz < 0)
<                 jz = Zsyssize - 1;
<               jx = kx;
<               jy = ky;
<               break;
<             default:
<               break;
<             }
---
>     jx = jy = jz = 0;
>     for (kx = 0; kx < Xsyssize; kx++) {
>         for (ky = 0; ky < Ysyssize; ky++) {
>             for (kz = 0; kz < Zsyssize; kz++) {
>                 if (Mic[kx][ky][kz] == POROSITY) {
8868,8871c8242,8282
<             if ((Mic[jx][jy][jz] == C3S) || (Mic[jx][jy][jz] == C2S) ||
<                 (Mic[jx][jy][jz] == C3A) || (Mic[jx][jy][jz] == OC3A) ||
<                 (Mic[jx][jy][jz] == C4AF) || (Mic[jx][jy][jz] == INERT) ||
<                 (Mic[jx][jy][jz] == SFUME) || (Mic[jx][jy][jz] == CACO3)) {
---
>                     for(faceid = 0; faceid < 6; faceid++) {
>                         switch (faceid) {
>                             case 0:
>                                 jx=kx+1;
>                                 if (jx > (Xsyssize - 1)) jx = 0;
>                                 jy = ky;
>                                 jz = kz;
>                                 break;
>                             case 1:
>                                 jx = kx - 1;
>                                 if (jx < 0) jx = Xsyssize - 1;
>                                 jy = ky;
>                                 jz = kz;
>                                 break;
>                             case 2:
>                                 jy=ky+1;
>                                 if (jy > (Ysyssize - 1)) jy = 0;
>                                 jx = kx;
>                                 jz = kz;
>                                 break;
>                             case 3:
>                                 jy = ky - 1;
>                                 if (jy < 0) jy = Ysyssize - 1;
>                                 jx = kx;
>                                 jz = kz;
>                                 break;
>                             case 4:
>                                 jz = ky + 1;
>                                 if (jz > (Zsyssize - 1)) jz = 0;
>                                 jx = kx;
>                                 jy = ky;
>                                 break;
>                             case 5:
>                                 jz = ky - 1;
>                                 if (jz < 0) jz = Zsyssize - 1;
>                                 jx = kx;
>                                 jy = ky;
>                                 break;
>                             default:
>                                 break;
>                         }
8873,8876c8284,8291
<               Scnttotal++;
<               if ((Mic[jx][jy][jz] == C3S) || (Mic[jx][jy][jz] == C2S) ||
<                   (Mic[jx][jy][jz] == C3A) || (Mic[jx][jy][jz] == OC3A) ||
<                   (Mic[jx][jy][jz] == C4AF)) {
---
>                         if ((Mic[jx][jy][jz]==C3S)
>                              || (Mic[jx][jy][jz]==C2S)
>                              || (Mic[jx][jy][jz]==C3A)
>                              || (Mic[jx][jy][jz]==OC3A)
>                              || (Mic[jx][jy][jz]==C4AF)
>                              || (Mic[jx][jy][jz]==INERT)
>                              || (Mic[jx][jy][jz]==SFUME)
>                              || (Mic[jx][jy][jz]==CACO3)) {
8878,8879c8293,8305
<                 Scntcement++;
<               }
---
>                              Scnttotal++;
>                              if ((Mic[jx][jy][jz]==C3S)
>                                   ||(Mic[jx][jy][jz]==C2S)
>                                   ||(Mic[jx][jy][jz]==C3A)
>                                   ||(Mic[jx][jy][jz]==OC3A)
>                                   ||(Mic[jx][jy][jz]==C4AF)) {
> 
>                                   Scntcement++;
>                             }
>                         }
>                     }
> 
>                 }
8881d8306
<           }
8883d8307
<       }
8885d8308
<   }
8887,8893c8310,8316
<   Surffract = (float)Scntcement / (float)Scnttotal;
<   if (Verbose_flag > 1) {
<     fprintf(Logfile, "Cement surface count is %d \n", Scntcement);
<     fprintf(Logfile, "Total surface count is %d \n", Scnttotal);
<     fprintf(Logfile, "Surface fraction is %f \n", Surffract);
<     fflush(Logfile);
<   }
---
>     Surffract=(float)Scntcement/(float)Scnttotal;
>     if (Verbose) {
>         printf("Cement surface count is %d \n",Scntcement);
>         printf("Total surface count is %d \n",Scnttotal);
>         printf("Surface fraction is %f \n",Surffract);
>         fflush(stdout);
>     }
8897,8918c8320,8342
<  *    findnewtime
<  *
<  *    Search experimental kinetic data (calorimetric or chemical shrinkage)
<  *for a match to the current time.  If the experimental data end before the
<  *current time is reached, use a generalized quadratic fit procedure to end of
<  *    experimental data and extrapolate to later times
<  *
<  *    Arguments:  float dval is the simulated heat or chemical shrinkage
<  *                float act_nrg is the activation energy for temperature
<  *change effects float *previousUncorrectedTime is a pointer to the address
<  *holding the previous time before any temperature corrections are applied
<  *string *typestring identifies whether the data are calorimetric or chemical
<  *shrinkage Returns:    Nothing
<  *
<  *    Called by:    main
<  *
<  ***/
< void findnewtime(float dval, float act_nrg, float *previousUncorrectedTime,
<                  char *typestring) {
<   register int i;
<   float h_interp_factor = -1.0;
<   float calFileSaysTimeShouldBe, uncorrectedTime_step, recip_Tdiff;
---
> *    findnewtime
> *
> *    Search experimental kinetic data (calorimetric or chemical shrinkage) for
> *    a match to the current time.  If the experimental data end before the current
> *    time is reached, use a generalized quadratic fit procedure to end of 
> *    experimental data and extrapolate to later times
> *
> *    Arguments:  float dval is the simulated heat or chemical shrinkage
> *                float act_nrg is the activation energy for temperature change effects
> *                float *previousUncorrectedTime is a pointer to the address holding the previous time
> *                      before any temperature corrections are applied
> *                string *typestring identifies whether the data are calorimetric
> *                      or chemical shrinkage
> *    Returns:    Nothing
> *
> *    Called by:    main
> *
> ***/
> void findnewtime(float dval, float act_nrg, float *previousUncorrectedTime, char *typestring)
> {
>     register int i;
>     float h_interp_factor = -1.0;
>     float calFileSaysTimeShouldBe,uncorrectedTime_step,recip_Tdiff;
8920,8933c8344,8350
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nCurDataLine = %d, NDataLines = %d\n", CurDataLine,
<             NDataLines);
<   if (CurDataLine < NDataLines) {
<     /* Use linear interpolation of the measured data to get the current time
<      */
<     for (i = CurDataLine; (i < NDataLines) && (h_interp_factor < 0.0); i++) {
<       if (Verbose_flag > 2)
<         fprintf(Logfile,
<                 "\ndval = %f, DataValue[%d] = %f, DataValue[%d] = %f\n", dval,
<                 i - 1, DataValue[i - 1], i, DataValue[i]);
<       if ((dval >= DataValue[i - 1]) && (dval <= DataValue[i])) {
<         h_interp_factor =
<             (dval - DataValue[i - 1]) / (DataValue[i] - DataValue[i - 1]);
---
>     if (Verbose) printf("\nCurDataLine = %d, NDataLines = %d\n",CurDataLine,NDataLines);
>     if (CurDataLine < NDataLines) {
>         /* Use linear interpolation of the measured data to get the current time */
>         for (i = CurDataLine; (i < NDataLines) && (h_interp_factor < 0.0); i++) {
>             /* if (Verbose) */ printf("\ndval = %f, DataValue[%d] = %f, DataValue[%d] = %f\n",dval,i-1,DataValue[i-1],i,DataValue[i]);
>             if ((dval >= DataValue[i-1]) && (dval <= DataValue[i])) {
>                 h_interp_factor = (dval - DataValue[i-1]) / (DataValue[i] - DataValue[i-1]);
8935,8938c8352,8355
<         /* First determine how much time has elapsed since the last cycle */
<         /* according to the calorimetry data, ASSUMING that the temperature */
<         /* is the same as that used to measure the */
<         /* the isothermal calorimetry data */
---
>                 /* First determine how much time has elapsed since the last cycle */
>                 /* according to the calorimetry data, ASSUMING that the temperature */
>                 /* is the same as that used to measure the */
>                 /* the isothermal calorimetry data */
8940,8944c8357,8358
<         calFileSaysTimeShouldBe =
<             DataTime[i - 1] +
<             (h_interp_factor * (DataTime[i] - DataTime[i - 1]));
<         uncorrectedTime_step =
<             calFileSaysTimeShouldBe - *previousUncorrectedTime;
---
>                 calFileSaysTimeShouldBe = DataTime[i-1] + (h_interp_factor * (DataTime[i] - DataTime[i-1]));
>                 uncorrectedTime_step = calFileSaysTimeShouldBe - *previousUncorrectedTime;
8946,8947c8360,8361
<         /* Now we correct the time difference for the actual temperature */
<         /* prevailing during this heat change */
---
>                 /* Now we correct the time difference for the actual temperature */
>                 /* prevailing during this heat change */
8949,8979c8363,8385
<         recip_Tdiff = (1.0 / (Temp_cur_b + 273.15)) -
<                       (1.0 / (DataMeasuredAtTemperature + 273.15));
<         CalKrate = exp(-(act_nrg * recip_Tdiff));
<         Time_step = uncorrectedTime_step / CalKrate;
<         TimeHistory[Cyccnt] = TimeHistory[Cyccnt - 1] + Time_step;
<         Time_cur = TimeHistory[Cyccnt];
<         if (Verbose_flag > 2) {
<           fprintf(Logfile,
<                   "\n**calFileSaysTimeShouldBe = %f, previousUncorrectedTime "
<                   "= %f",
<                   calFileSaysTimeShouldBe, *previousUncorrectedTime);
<           fprintf(Logfile, "\n**uncorrectedTime_step = %f",
<                   uncorrectedTime_step);
<           fprintf(Logfile,
<                   "\n**Temp_cur_b = %f, DataMeasuredAtTemperature = %f",
<                   Temp_cur_b, DataMeasuredAtTemperature);
<           fprintf(Logfile, "\n**recip_Tdiff = %f", recip_Tdiff);
<           fprintf(Logfile, "\n**act_nrg = %f, CalKrate = %f", act_nrg,
<                   CalKrate);
<           fprintf(Logfile, "\n**Time_step = %f, Time_cur = %f\n", Time_step,
<                   Time_cur);
<           fprintf(Logfile, "\n**dval = %f", dval);
<           fprintf(Logfile, "\n**DataValue[%d] = %f, DataValue[%d] = %f", i - 1,
<                   DataValue[i - 1], i, DataValue[i]);
<           fprintf(Logfile, "\n**DataTime[%d] = %f, DataTime[%d] = %f", i - 1,
<                   DataTime[i - 1], i, DataTime[i]);
<           fprintf(Logfile, "\n**h_interp_factor = %f", h_interp_factor);
<           fprintf(Logfile,
<                   "\n**TimeHistory[%d] = %f and TimeHistory[%d] = %f\n", Cyccnt,
<                   TimeHistory[Cyccnt], Cyccnt - 1, TimeHistory[Cyccnt - 1]);
<           fprintf(Logfile, "\n**Time_cur = %f\n", Time_cur);
---
>                 recip_Tdiff = (1.0/(Temp_cur_b + 273.15)) - (1.0/(DataMeasuredAtTemperature + 273.15));
>                 CalKrate = exp(-(act_nrg * recip_Tdiff));
>                 Time_step = uncorrectedTime_step / CalKrate;
>                 TimeHistory[Cyccnt] = TimeHistory[Cyccnt-1] + Time_step;
>                 Time_cur = TimeHistory[Cyccnt];
>                 printf("\n**calFileSaysTimeShouldBe = %f, previousUncorrectedTime = %f",calFileSaysTimeShouldBe,*previousUncorrectedTime);
>                 printf("\n**uncorrectedTime_step = %f",uncorrectedTime_step);
>                 printf("\n**Temp_cur_b = %f, DataMeasuredAtTemperature = %f",Temp_cur_b,DataMeasuredAtTemperature);
>                 printf("\n**recip_Tdiff = %f",recip_Tdiff);
>                 printf("\n**act_nrg = %f, CalKrate = %f",act_nrg,CalKrate);
>                 printf("\n**Time_step = %f, Time_cur = %f\n",Time_step,Time_cur);
>                 /* if (Verbose) { */
>                     printf("\n**dval = %f",dval);
>                     printf("\n**DataValue[%d] = %f, DataValue[%d] = %f",i-1,DataValue[i-1],i,DataValue[i]);
>                     printf("\n**DataTime[%d] = %f, DataTime[%d] = %f",i-1,DataTime[i-1],i,DataTime[i]);
>                     printf("\n**h_interp_factor = %f",h_interp_factor);
>                     printf("\n**TimeHistory[%d] = %f and TimeHistory[%d] = %f\n",Cyccnt,TimeHistory[Cyccnt],Cyccnt-1,TimeHistory[Cyccnt-1]);
>                     printf("\n**Time_cur = %f\n",Time_cur);
>                 /* } */
>                 fflush(stdout);
>                 *previousUncorrectedTime = calFileSaysTimeShouldBe;
>                 CurDataLine = i;
>             }
8981,8985d8386
<         fflush(Logfile);
<         *previousUncorrectedTime = calFileSaysTimeShouldBe;
<         CurDataLine = i;
<       }
<     }
8987,8988c8388
<     if (h_interp_factor < 0.0) { /* h_interp_factor never calculated; < 0 is
<                                     the initialized nonsense value */
---
>         if (h_interp_factor < 0.0) {  /* h_interp_factor never calculated; < 0 is the initialized nonsense value */
8990,8991c8390
<       /*  We have just now run past the useful experimental data for time
<        * calibration */
---
>             /*  We have just now run past the useful experimental data for time calibration */
8993c8392
<       CurDataLine = NDataLines + 1;
---
>             CurDataLine = NDataLines + 1;
8995,8999c8394,8395
<       if (Verbose_flag > 1)
<         fprintf(Logfile, "\nNo more useful %s data for calibration\n",
<                 typestring);
<       fflush(Logfile);
<     }
---
>             /* if (Verbose) */ printf("\nNo more useful %s data for calibration\n",typestring);
>             fflush(stdout);
9001,9003c8397,8399
<     /* Now need to estimate Beta for the remaining iterations   */
<     /* Estimate with the most recent time history data          */
<     /* Use a quadratic regression over the last NTOTAKE points  */
---
>             /* Now need to estimate Beta for the remaining iterations   */
>             /* Estimate with the most recent time history data          */
>             /* Use a quadratic regression over the last NTOTAKE points  */
9005c8401
<     createfittocycles();
---
>             createfittocycles();
9007,9008c8403,8404
<     /* Now, the vector Bvec contains the coefficients of the best-fit */
<     /* quadratic equation for mapping */
---
>             /* Now, the vector Bvec contains the coefficients of the best-fit */
>             /* quadratic equation for mapping */
9010,9013c8406,8409
<     /* We record the simulation temperature at which the calorimetry data */
<     /* ended, because any further adjustments in the quadratic fit due */
<     /* to temperature change should be referenced to the temperature */
<     /* at which the fit was made */
---
>             /* We record the simulation temperature at which the calorimetry data */
>             /* ended, because any further adjustments in the quadratic fit due */
>             /* to temperature change should be referenced to the temperature */
>             /* at which the fit was made */
9015,9037c8411,8425
<     DataFinalTemperature = Temp_cur_b;
<     Time_step = (2.0 * Bvec[0] * (float)((Cyccnt - 1)) + (Bvec[1]));
<     if (Time_step <= 0.0) {
<       fprintf(stderr, "\n\n****\n");
<       fprintf(stderr, "ERROR: Time step is %f at cycle = %d\n", Time_step,
<               Cyccnt);
<       fprintf(Logfile, "\n\n****\n");
<       fprintf(Logfile, "ERROR: Time step is %f at cycle = %d\n", Time_step,
<               Cyccnt);
<       fprintf(Logfile, "       Bvec[0] = %f , Bvec[1] = %f\n", Bvec[0],
<               Bvec[1]);
<       fprintf(stderr, "****\n\n");
<       fprintf(Logfile, "****\n\n");
<       freeallmem();
<       bailout("disrealnew", "Problem with time extrapolation from calorimetry");
<       exit(1);
<     }
<     TimeHistory[Cyccnt] = TimeHistory[Cyccnt - 1] + Time_step;
<     if (Verbose_flag > 2) {
<       fprintf(Logfile, "\nQuadratic fit is %g n*n + %g n + %g\n", Bvec[0],
<               Bvec[1], Bvec[2]);
<     }
<   } else {
---
>             DataFinalTemperature = Temp_cur_b;
>             Time_step = (2.0 * Bvec[0]*(float)((Cyccnt-1)) + (Bvec[1]));
>             if (Time_step <= 0.0) {
>                 printf("\n\n****\n");
>                 printf("ERROR: Time step is %f at cycle = %d\n",Time_step,Cyccnt);
>                 printf("       Bvec[0] = %f , Bvec[1] = %f\n",Bvec[0],Bvec[1]);
>                 printf("****\n\n");
>                 freeallmem();
>                 bailout("disrealnew","Problem with time extrapolation from calorimetry");
>                 exit(1);
>             }
>             TimeHistory[Cyccnt] = TimeHistory[Cyccnt-1] + Time_step;
>             /* if (Verbose) */ printf("\nQuadratic fit is %g n*n + %g n + %g\n",Bvec[0],Bvec[1],Bvec[2]);
>         }
>     } else {
9039,9041c8427,8428
<     /* Any further change in temperature since the calorimetry data ended must
<      * influence */
<     /* the dilation or contraction of the quadratic extrapolation */
---
>         /* Any further change in temperature since the calorimetry data ended must influence */
>         /* the dilation or contraction of the quadratic extrapolation */
9043,9060c8430,8443
<     recip_Tdiff =
<         (1.0 / (Temp_cur_b + 273.15)) - (1.0 / (DataFinalTemperature + 273.15));
<     CalKrate = exp(-(act_nrg * recip_Tdiff));
<     Time_step = (2.0 * Bvec[0] * (float)((Cyccnt - 1)) + (Bvec[1])) / CalKrate;
<     if (Time_step <= 0.0) {
<       fprintf(stderr, "\n\n****\n");
<       fprintf(stderr, "ERROR: Time step is %f at cycle = %d\n", Time_step,
<               Cyccnt);
<       fprintf(Logfile, "\n\n****\n");
<       fprintf(Logfile, "ERROR: Time step is %f at cycle = %d\n", Time_step,
<               Cyccnt);
<       fprintf(Logfile, "       Bvec[0] = %f , Bvec[1] = %f\n", Bvec[0],
<               Bvec[1]);
<       fprintf(stderr, "****\n\n");
<       fprintf(Logfile, "****\n\n");
<       freeallmem();
<       bailout("disrealnew", "Problem with time extrapolation from calorimetry");
<       exit(1);
---
>         recip_Tdiff = (1.0/(Temp_cur_b + 273.15)) - (1.0/(DataFinalTemperature + 273.15));
>         CalKrate = exp(-(act_nrg * recip_Tdiff));
>         Time_step = (2.0 * Bvec[0]*(float)((Cyccnt-1)) + (Bvec[1])) / CalKrate;
>         if (Time_step <= 0.0) {
>             printf("\n\n****\n");
>             printf("ERROR: Time step is %f at cycle = %d\n",Time_step,Cyccnt);
>             printf("       Bvec[0] = %f , Bvec[1] = %f\n",Bvec[0],Bvec[1]);
>             printf("****\n\n");
>             freeallmem();
>             bailout("disrealnew","Problem with time extrapolation from calorimetry");
>             exit(1);
>         }
>         Time_cur += Time_step;
>         TimeHistory[Cyccnt] = Time_cur;
9062,9064d8444
<     Time_cur += Time_step;
<     TimeHistory[Cyccnt] = Time_cur;
<   }
9066c8446
<   return;
---
>     return;
9070,9086c8450,8466
<  *    createfittocycles
<  *
<  *    Use second-order Lagrange interpolation to fit a quadratic form to the
<  *most recent data for time versus cycles, enabling one to extrapolate to
<  *later times
<  *
<  *    Arguments:  none
<  *    Returns:    Nothing
<  *
<  *    Called by:    main
<  *
<  ***/
< void createfittocycles(void) {
<   float x1, x2, x3, a1, a2, a3, b1, b2, b3, y1, y2, y3;
<   float sum_xy, sum_x, sum_y, sum_x2, numpoints;
<   int i1, i2, i3;
<   int increment, done;
---
> *    createfittocycles
> *
> *    Use second-order Lagrange interpolation to fit a quadratic form to the most
> *    recent data for time versus cycles, enabling one to extrapolate to later times
> *
> *    Arguments:  none
> *    Returns:    Nothing
> *
> *    Called by:    main
> *
> ***/
> void createfittocycles(void)
> {
>     float x1,x2,x3,a1,a2,a3,b1,b2,b3,y1,y2,y3;
>     float sum_xy,sum_x,sum_y,sum_x2,numpoints;
>     int i1,i2,i3;
>     int increment,done;
9088,9091c8468,8474
<   i3 = Cyccnt - 1;
<   i1 = i2 = i3;
<   increment = 20;
<   done = 0;
---
>     i3 = Cyccnt - 1;
>     i1 = i2 = i3;
>     increment = 20;
>     done = 0;
>     
>     x3 = (float)(i3);
>     y3 = TimeHistory[i3];
9093,9094c8476,8478
<   x3 = (float)(i3);
<   y3 = TimeHistory[i3];
---
>     do {
>         i2 = i3 - increment;
>         i1 = i2 - increment;
9096,9098c8480,8483
<   do {
<     i2 = i3 - increment;
<     i1 = i2 - increment;
---
>         x2 = (float)(i2);
>         x1 = (float)(i1);
>         y2 = TimeHistory[i2];
>         y1 = TimeHistory[i1];
9100,9103c8485,8487
<     x2 = (float)(i2);
<     x1 = (float)(i1);
<     y2 = TimeHistory[i2];
<     y1 = TimeHistory[i1];
---
>         a1 = (x1 - x2) * (x1 - x3);
>         a2 = (x2 - x1) * (x2 - x3);
>         a3 = (x3 - x1) * (x3 - x2);
9105,9107c8489,8491
<     a1 = (x1 - x2) * (x1 - x3);
<     a2 = (x2 - x1) * (x2 - x3);
<     a3 = (x3 - x1) * (x3 - x2);
---
>         b1 = y1/a1;
>         b2 = y2/a2;
>         b3 = y3/a3;
9109,9111c8493,8497
<     b1 = y1 / a1;
<     b2 = y2 / a2;
<     b3 = y3 / a3;
---
>         Bvec[0] = b1 + b2 + b3; /* quadratic coefficient */
>         Bvec[1] = (b1*(x2+x3)) + (b2*(x1+x3)) + (b3*(x1+x2));
>         Bvec[1] *= (-1.0);  /* linear coefficient */
>         Bvec[2] = (b1*x2*x3) + (b2*x1*x3) + (b3*x1*x2);  /* constant coefficient */
>         increment += 10;
9113,9118c8499
<     Bvec[0] = b1 + b2 + b3; /* quadratic coefficient */
<     Bvec[1] = (b1 * (x2 + x3)) + (b2 * (x1 + x3)) + (b3 * (x1 + x2));
<     Bvec[1] *= (-1.0); /* linear coefficient */
<     Bvec[2] = (b1 * x2 * x3) + (b2 * x1 * x3) +
<               (b3 * x1 * x2); /* constant coefficient */
<     increment += 10;
---
>     } while (Bvec[0] < 0.0 && i1 > increment);
9120c8501
<   } while (Bvec[0] < 0.0 && i1 > increment);
---
>     if (Bvec[0] < 0.0) {
9122c8503,8511
<   if (Bvec[0] < 0.0) {
---
>         /* No quadratic fit was found; default to linear fit with warning */
>         printf("WARNING: No quadratic fit could be found to the measurement data!\n");
>         printf("         This likely is caused by terminating the measurements\n");
>         printf("         too soon.\n\n");
>         printf("         Defaulting to a LINEAR fit, which may not yield good results\n");
>         printf("         at later times.\n\n");
>         
>         increment = 20;
>         numpoints = 3.0;
9124,9138c8513,8520
<     /* No quadratic fit was found; default to linear fit with warning */
<     if (Verbose_flag > 0) {
<       fprintf(Logfile, "WARNING: No quadratic fit could be found to the "
<                        "measurement data!\n");
<       fprintf(
<           Logfile,
<           "         This likely is caused by terminating the measurements\n");
<       fprintf(Logfile, "         too soon.\n\n");
<       fprintf(Logfile,
<               "         Defaulting to a LINEAR fit, which may not yield good "
<               "results\n");
<       fprintf(Logfile, "         at later times.\n\n");
<     }
<     increment = 20;
<     numpoints = 3.0;
---
>         i2 = i3 - increment;
>         i1 = i2 - increment;
>         x2 = (float)(i2);
>         x1 = (float)(i1);
>         y2 = TimeHistory[i2];
>         y1 = TimeHistory[i1];
>         
>         /* Linear regression using three points */
9140,9145c8522
<     i2 = i3 - increment;
<     i1 = i2 - increment;
<     x2 = (float)(i2);
<     x1 = (float)(i1);
<     y2 = TimeHistory[i2];
<     y1 = TimeHistory[i1];
---
>         Bvec[0] = 0.0;
9147,9160c8524,8533
<     /* Linear regression using three points */
< 
<     Bvec[0] = 0.0;
< 
<     sum_xy = (x1 * y1) + (x2 * y2) + (x3 * y3);
<     sum_x = (x1 + x2 + x3);
<     sum_y = (y1 + y2 + y3);
<     sum_x2 = (x1 * x1) + (x2 * x2) + (x3 * x3);
< 
<     Bvec[1] = ((numpoints * sum_xy) - (sum_x * sum_y)) /
<               ((numpoints * sum_x2) - (sum_x * sum_x));
<     Bvec[2] = (sum_y - (Bvec[0] * sum_x)) / numpoints;
<   }
<   return;
---
>         sum_xy = (x1*y1) + (x2*y2) + (x3*y3);
>         sum_x = (x1 + x2 + x3);
>         sum_y = (y1 + y2 + y3);
>         sum_x2 = (x1*x1) + (x2*x2) + (x3*x3);
>       
>         Bvec[1] = ((numpoints * sum_xy) - (sum_x * sum_y)) /
>                     ((numpoints * sum_x2) - (sum_x * sum_x));
>         Bvec[2] = (sum_y - (Bvec[0] * sum_x)) / numpoints;
>     }
>     return;
9164,9182c8537,8556
<  *    freeallmem
<  *
<  *    Releases all dynamically allocated memory for this
<  *    program.
<  *
<  *    SHOULD ONLY BE CALLED IF ALL MEMORY HAS ALREADY BEEN
<  *    DYNAMICALLY ALLOCATED
<  *
<  *    Arguments:    None
<  *    Returns:    Nothing
<  *
<  *    Calls:        free_ccube, free_sicube
<  *    Called by:    main,dissolve
<  *
<  ***/
< void freeallmem(void) {
<   int ntick;
<   struct Ants *curant, *antgone;
<   struct Alksulf *curas, *asgone;
---
> *    freeallmem
> *
> *    Releases all dynamically allocated memory for this
> *    program.
> *
> *    SHOULD ONLY BE CALLED IF ALL MEMORY HAS ALREADY BEEN
> *    DYNAMICALLY ALLOCATED
> *
> *    Arguments:    None
> *    Returns:    Nothing
> *
> *    Calls:        free_ccube, free_sicube
> *    Called by:    main,dissolve
> *
> ***/
> void freeallmem(void)
> {
>     int ntick;
>     struct Ants *curant,*antgone;
>     struct Alksulf *curas,*asgone;
9184,9291c8558,8611
<   if (Mic)
<     free_cbox(Mic, Xsyssize, Ysyssize);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed cbox Mic");
<   if (Micorig)
<     free_cbox(Micorig, Xsyssize, Ysyssize);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed cbox Micorig");
<   if (Micpart)
<     free_sibox(Micpart, Xsyssize, Ysyssize);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed sibox Micpart");
<   if (Cshage)
<     free_sibox(Cshage, Xsyssize, Ysyssize);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed sibox Cshage");
<   if (Deactivated)
<     free_sibox(Deactivated, Xsyssize, Ysyssize);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed sibox Deactivated");
<   if (Startflag)
<     free_ivector(Startflag);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed ivector Startflag");
<   if (Stopflag)
<     free_ivector(Stopflag);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed ivector Stopflag");
<   if (Deactphaselist)
<     free_ivector(Deactphaselist);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed ivector Deactphaselist");
<   if (Deactfrac)
<     free_fvector(Deactfrac);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Deactfrac");
<   if (Reactfrac)
<     free_fvector(Reactfrac);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Reactfrac");
<   if (Deactinit)
<     free_fvector(Deactinit);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Deactinit");
<   if (Deactends)
<     free_fvector(Deactends);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Deactends");
<   if (Deactterm)
<     free_fvector(Deactterm);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Deactterm");
<   if (Molarvcsh)
<     free_fvector(Molarvcsh);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Molarvcsh");
<   if (Watercsh)
<     free_fvector(Watercsh);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Watercsh");
<   if (Disprob)
<     free_fvector(Disprob);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Disprob");
<   if (Disbase)
<     free_fvector(Disbase);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Disbase");
<   if (Discoeff)
<     free_fvector(Discoeff);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Discoeff");
<   if (Soluble)
<     free_ivector(Soluble);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed ivector Soluble");
<   if (Creates)
<     free_ivector(Creates);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed ivector Creates");
<   if (Onepixelbias)
<     free_fvector(Onepixelbias);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector Onepixelbias");
<   if (PHsulfcoeff)
<     free_fvector(PHsulfcoeff);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector PHsulfcoeff");
<   if (PHfactor)
<     free_fvector(PHfactor);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector PHfactor");
<   if (CustomImageTime)
<     free_fvector(CustomImageTime);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector CustomImageTime");
<   if (DataTime)
<     free_fvector(DataTime);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector DataTime");
<   if (DataValue)
<     free_fvector(DataValue);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector DataValue");
<   if (TimeHistory)
<     free_fvector(TimeHistory);
<   if (Verbose_flag > 2)
<     fprintf(Logfile, "\nFreed fvector TimeHistory");
---
>     if (Mic) free_cbox(Mic,Xsyssize,Ysyssize);
>     if (Verbose) printf("\nFreed cbox Mic");
>     if (Micorig) free_cbox(Micorig,Xsyssize,Ysyssize);
>     if (Verbose) printf("\nFreed cbox Micorig");
>     if (Micpart) free_sibox(Micpart,Xsyssize,Ysyssize);
>     if (Verbose) printf("\nFreed sibox Micpart");
>     if (Cshage) free_sibox(Cshage,Xsyssize,Ysyssize);
>     if (Verbose) printf("\nFreed sibox Cshage");
>     if (Deactivated) free_sibox(Deactivated,Xsyssize,Ysyssize);
>     if (Verbose) printf("\nFreed sibox Deactivated");
>     if (Startflag) free_ivector(Startflag);
>     if (Verbose) printf("\nFreed ivector Startflag");
>     if (Stopflag) free_ivector(Stopflag);
>     if (Verbose) printf("\nFreed ivector Stopflag");
>     if (Deactphaselist) free_ivector(Deactphaselist);
>     if (Verbose) printf("\nFreed ivector Deactphaselist");
>     if (Deactfrac) free_fvector(Deactfrac);
>     if (Verbose) printf("\nFreed fvector Deactfrac");
>     if (Reactfrac) free_fvector(Reactfrac);
>     if (Verbose) printf("\nFreed fvector Reactfrac");
>     if (Deactinit) free_fvector(Deactinit);
>     if (Verbose) printf("\nFreed fvector Deactinit");
>     if (Deactends) free_fvector(Deactends);
>     if (Verbose) printf("\nFreed fvector Deactends");
>     if (Deactterm) free_fvector(Deactterm);
>     if (Verbose) printf("\nFreed fvector Deactterm");
>     if (Molarvcsh) free_fvector(Molarvcsh);
>     if (Verbose) printf("\nFreed fvector Molarvcsh");
>     if (Watercsh) free_fvector(Watercsh);
>     if (Verbose) printf("\nFreed fvector Watercsh");
>     if (Disprob) free_fvector(Disprob);
>     if (Verbose) printf("\nFreed fvector Disprob");
>     if (Disbase) free_fvector(Disbase);
>     if (Verbose) printf("\nFreed fvector Disbase");
>     if (Discoeff) free_fvector(Discoeff);
>     if (Verbose) printf("\nFreed fvector Discoeff");
>     if (Soluble) free_ivector(Soluble);
>     if (Verbose) printf("\nFreed ivector Soluble");
>     if (Creates) free_ivector(Creates);
>     if (Verbose) printf("\nFreed ivector Creates");
>     if (Onepixelbias) free_fvector(Onepixelbias);
>     if (Verbose) printf("\nFreed fvector Onepixelbias");
>     if (PHsulfcoeff) free_fvector(PHsulfcoeff);
>     if (Verbose) printf("\nFreed fvector PHsulfcoeff");
>     if (PHfactor) free_fvector(PHfactor);
>     if (Verbose) printf("\nFreed fvector PHfactor");
>     if (CustomImageTime) free_fvector(CustomImageTime);
>     if (Verbose) printf("\nFreed fvector CustomImageTime");
>     if (DataTime) free_fvector(DataTime);
>     if (Verbose) printf("\nFreed fvector DataTime");
>     if (DataValue) free_fvector(DataValue);
>     if (Verbose) printf("\nFreed fvector DataValue");
>     if (TimeHistory) free_fvector(TimeHistory);
>     if (Verbose) printf("\nFreed fvector TimeHistory");
9293c8613
<   /*** Now free the ants ***/
---
>     /*** Now free the ants ***/
9295,9312c8615,8636
<   if (Headant) {
<     ntick = 0;
<     curant = Headant->nextant;
<     while (curant) {
<       ntick++;
<       if (ntick == 1) {
<         Headant->nextant = curant->nextant;
<       } else {
<         (curant->prevant)->nextant = curant->nextant;
<       }
<       if (curant->nextant) {
<         (curant->nextant)->prevant = curant->prevant;
<       } else {
<         Tailant = curant->prevant;
<       }
<       antgone = curant;
<       curant = curant->nextant;
<       free(antgone);
---
>     if (Headant) {
>         ntick = 0;
>         curant = Headant->nextant;
>         while (curant) {
>             ntick++;
>             if (ntick == 1) {
>                 Headant->nextant = curant->nextant;
>             } else {
>                 (curant->prevant)->nextant = curant->nextant;
>             }
>             if (curant->nextant) {
>                 (curant->nextant)->prevant = curant->prevant;
>             } else {
>                 Tailant = curant->prevant;
>             }
>             antgone = curant;
>             curant = curant->nextant;
>             free(antgone);
>         }
>         if (Verbose) printf("\nFreed all ants except Headant... ");
>         free(Headant);
>         if (Verbose) printf("freed Headant\n");
9314,9319d8637
<     if (Verbose_flag > 2)
<       fprintf(Logfile, "\nFreed all ants except Headant... ");
<     free(Headant);
<     if (Verbose_flag > 2)
<       fprintf(Logfile, "freed Headant\n");
<   }
9321,9338c8639,8660
<   if (Headks) {
<     ntick = 0;
<     curas = Headks->nextas;
<     while (curas) {
<       ntick++;
<       if (ntick == 1) {
<         Headks->nextas = curas->nextas;
<       } else {
<         (curas->prevas)->nextas = curas->nextas;
<       }
<       if (curas->nextas) {
<         (curas->nextas)->prevas = curas->prevas;
<       } else {
<         Tailks = curas->prevas;
<       }
<       asgone = curas;
<       curas = curas->nextas;
<       free(asgone);
---
>     if (Headks) {
>         ntick = 0;
>         curas = Headks->nextas;
>         while (curas) {
>             ntick++;
>             if (ntick == 1) {
>                 Headks->nextas = curas->nextas;
>             } else {
>                 (curas->prevas)->nextas = curas->nextas;
>             }
>             if (curas->nextas) {
>                 (curas->nextas)->prevas = curas->prevas;
>             } else {
>                 Tailks = curas->prevas;
>             }
>             asgone = curas;
>             curas = curas->nextas;
>             free(asgone);
>         }
>         if (Verbose) printf("\nFreed all ks except Headks... ");
>         free(Headks);
>         if (Verbose) printf("freed Headks\n");
9340,9345d8661
<     if (Verbose_flag > 2)
<       fprintf(Logfile, "\nFreed all ks except Headks... ");
<     free(Headks);
<     if (Verbose_flag > 2)
<       fprintf(Logfile, "freed Headks\n");
<   }
9347,9364c8663,8684
<   if (Headnas) {
<     ntick = 0;
<     curas = Headnas->nextas;
<     while (curas) {
<       ntick++;
<       if (ntick == 1) {
<         Headnas->nextas = curas->nextas;
<       } else {
<         (curas->prevas)->nextas = curas->nextas;
<       }
<       if (curas->nextas) {
<         (curas->nextas)->prevas = curas->prevas;
<       } else {
<         Tailnas = curas->prevas;
<       }
<       asgone = curas;
<       curas = curas->nextas;
<       free(asgone);
---
>     if (Headnas) {
>         ntick = 0;
>         curas = Headnas->nextas;
>         while (curas) {
>             ntick++;
>             if (ntick == 1) {
>                 Headnas->nextas = curas->nextas;
>             } else {
>                 (curas->prevas)->nextas = curas->nextas;
>             }
>             if (curas->nextas) {
>                 (curas->nextas)->prevas = curas->prevas;
>             } else {
>                 Tailnas = curas->prevas;
>             }
>             asgone = curas;
>             curas = curas->nextas;
>             free(asgone);
>         }
>         if (Verbose) printf("\nFreed all nas except Headnas... ");
>         free(Headnas);
>         if (Verbose) printf("freed Headnas\n");
9366,9371d8685
<     if (Verbose_flag > 2)
<       fprintf(Logfile, "\nFreed all nas except Headnas... ");
<     free(Headnas);
<     if (Verbose_flag > 2)
<       fprintf(Logfile, "freed Headnas\n");
<   }
9373c8687
<   return;
---
>     return;
9375,9404d8688
< 
< char *rfc8601_timespec(struct timespec *tv) {
<   char time_str[127];
<   double fractional_seconds;
<   int milliseconds;
<   struct tm tm; // our "broken down time"
<   char *rfc8601;
< 
<   rfc8601 = malloc(256);
< 
<   memset(&tm, 0, sizeof(struct tm));
<   sprintf(time_str, "%ld UTC", tv->tv_sec);
< 
<   // convert our timespec into broken down time
<   strptime(time_str, "%s %U", &tm);
< 
<   // do the math to convert nanoseconds to integer milliseconds
<   fractional_seconds = (double)tv->tv_nsec;
<   fractional_seconds /= 1e6;
<   fractional_seconds = round(fractional_seconds);
<   milliseconds = (int)fractional_seconds;
< 
<   // print date and time without milliseconds
<   strftime(time_str, sizeof(time_str), "%Y-%m-%dT%H:%M:%S", &tm);
< 
<   // add on the fractional seconds and Z for the UTC Timezone
<   sprintf(rfc8601, "%s.%dZ", time_str, milliseconds);
< 
<   return rfc8601;
< }
